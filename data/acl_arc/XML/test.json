[
    {
        "gold": {
            "text": [
                "The parallel Web pages we collected from various sites are not all of the same quality.",
                "Some are highly parallel and easy to align while others can be very noisy.",
                "Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages.",
                "A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #TARGET_REF ) to lexical methods ( #REF ; #REF ) .",
                "The method we adopted is that of #REF.",
                "Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods.",
                "Cognates are identical sequences of characters in corresponding words in two languages.",
                "They are commonly found in English and French.",
                "In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates.",
                "Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #TARGET_REF ) to lexical methods ( #REF ; #REF ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment.",
        "output": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #TARGET_REF<BACKGROUND/> ) to lexical methods ( #REF ; #REF ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
    },
    {
        "gold": {
            "text": [
                "However, a major obstacle to this approach is the lack of parallel corpora for model training.",
                "Only a few such corpora exist , including the Hansard English-French corpus and the HKUST EnglishChinese corpus ( #TARGET_REF ) .",
                "In this paper, we will describe a method which automatically searches for parallel texts on the Web.",
                "We will discuss the text mining algorithm we adopted, some issues in translation model training using the generated parallel corpus, and finally the translation model's performance in CLIR."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:However, a major obstacle to this approach is the lack of parallel corpora for model training. Only a few such corpora exist , including the Hansard English-French corpus and the HKUST EnglishChinese corpus ( #TARGET_REF ) . In this paper, we will describe a method which automatically searches for parallel texts on the Web. We will discuss the text mining algorithm we adopted, some issues in translation model training using the generated parallel corpus, and finally the translation model's performance in CLIR.",
        "output": "introduction:However, a major obstacle to this approach is the lack of parallel corpora for model training. Only a few such corpora exist , including the Hansard English-French corpus and the HKUST EnglishChinese corpus ( #TARGET_REF<BACKGROUND/> ) . In this paper, we will describe a method which automatically searches for parallel texts on the Web. We will discuss the text mining algorithm we adopted, some issues in translation model training using the generated parallel corpus, and finally the translation model's performance in CLIR."
    },
    {
        "gold": {
            "text": [
                "The parallel Web pages we collected from various sites are not all of the same quality.",
                "Some are highly parallel and easy to align while others can be very noisy.",
                "Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages.",
                "A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #REF ) to lexical methods ( #REF ; #TARGET_REF ) .",
                "The method we adopted is that of #REF.",
                "Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods.",
                "Cognates are identical sequences of characters in corresponding words in two languages.",
                "They are commonly found in English and French.",
                "In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates.",
                "Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #REF ) to lexical methods ( #REF ; #TARGET_REF ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment.",
        "output": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #REF ; #REF ) to lexical methods ( #REF ; #TARGET_REF<BACKGROUND/> ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
    },
    {
        "gold": {
            "text": [
                "Beside HTML markups, other criteria may also be incorporated.",
                "For example , it would be helpful to consider strong correspondence between certain English and Chinese words , as in ( #TARGET_REF ) .",
                "We hope to implement such correspondences in our future research."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "method:Beside HTML markups, other criteria may also be incorporated. For example , it would be helpful to consider strong correspondence between certain English and Chinese words , as in ( #TARGET_REF ) . We hope to implement such correspondences in our future research.",
        "output": "method:Beside HTML markups, other criteria may also be incorporated. For example , it would be helpful to consider strong correspondence between certain English and Chinese words , as in ( #TARGET_REF<MOTIVATION/> ) . We hope to implement such correspondences in our future research."
    },
    {
        "gold": {
            "text": [
                "The parallel Web pages we collected from various sites are not all of the same quality.",
                "Some are highly parallel and easy to align while others can be very noisy.",
                "Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages.",
                "A number of alignment techniques have been proposed , varying from statistical methods ( #TARGET_REF ; #REF ) to lexical methods ( #REF ; #REF ) .",
                "The method we adopted is that of #REF.",
                "Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods.",
                "Cognates are identical sequences of characters in corresponding words in two languages.",
                "They are commonly found in English and French.",
                "In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates.",
                "Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #TARGET_REF ; #REF ) to lexical methods ( #REF ; #REF ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment.",
        "output": "method:The parallel Web pages we collected from various sites are not all of the same quality. Some are highly parallel and easy to align while others can be very noisy. Aligning English-Chinese parallel texts is already very difficult because of the great differences in the syntactic structures and writing systems of the two languages. A number of alignment techniques have been proposed , varying from statistical methods ( #TARGET_REF<BACKGROUND/> ; #REF ) to lexical methods ( #REF ; #REF ) . The method we adopted is that of #REF. Because it considers both length similarity and cognateness as alignment criteria, the method is more robust and better able to deal with noise than pure length-based methods. Cognates are identical sequences of characters in corresponding words in two languages. They are commonly found in English and French. In the case of English-Chinese alignment, where there are no cognates shared by the two languages, only the HTML markup in both texts are taken as cognates. Because the HTML structures of parallel pages are normally similar, the markup was found to be helpful for alignment."
    },
    {
        "gold": {
            "text": [
                "The first system we have implemented with APE is a prototype Atlas-Andes system that replaces the hints usually given for an incorrect acceleration vector by a choice of generated subdialogues.",
                "Figure 4 shows the architecture of Atlas-Andes; any other system built with APE would look similar.",
                "Robust natural language understanding in Atlas-Andes is provided by RosÃ© 's CARMEL system ( RosÃ© 2000 ) ; it uses the spelling correction algorithm devised by #TARGET_REF ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "introduction:The first system we have implemented with APE is a prototype Atlas-Andes system that replaces the hints usually given for an incorrect acceleration vector by a choice of generated subdialogues. Figure 4 shows the architecture of Atlas-Andes; any other system built with APE would look similar. Robust natural language understanding in Atlas-Andes is provided by RosÃ© 's CARMEL system ( RosÃ© 2000 ) ; it uses the spelling correction algorithm devised by #TARGET_REF .",
        "output": "introduction:The first system we have implemented with APE is a prototype Atlas-Andes system that replaces the hints usually given for an incorrect acceleration vector by a choice of generated subdialogues. Figure 4 shows the architecture of Atlas-Andes; any other system built with APE would look similar. Robust natural language understanding in Atlas-Andes is provided by RosÃ© 's CARMEL system ( RosÃ© 2000 ) ; it uses the spelling correction algorithm devised by #TARGET_REF<FUTURE/> ."
    },
    {
        "gold": {
            "text": [
                "2 See ( #TARGET_REF ) for how MIMIC 's dialoguelevel knowledge is used to override default prosodic assignments for concept-to-speech generation ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:2 See ( #TARGET_REF ) for how MIMIC 's dialoguelevel knowledge is used to override default prosodic assignments for concept-to-speech generation .",
        "output": "nan:2 See ( #TARGET_REF<BACKGROUND/> ) for how MIMIC 's dialoguelevel knowledge is used to override default prosodic assignments for concept-to-speech generation ."
    },
    {
        "gold": {
            "text": [
                "The strategies employed when MIMIC has only dialogue initiative are similar to the mixed initiative dialogue strategies employed by many existing spoken dialogue systems ( e.g. , ( #REF ; #TARGET_REF ) ) .",
                "To instantiate an attribute, MIMIC adopts the lnfoSeek dialogue act to solicit the missing information.",
                "In contrast, when MIMIC has both initiatives, it plays a more active role by presenting the user with additional information comprising valid instantiations of the attribute (GiveOptions).",
                "Given an invalid query, MIMIC notifies the user of the failed query and provides an openended prompt when it only has dialogue initiative.",
                "When MIMIC has both initiatives, however, in addition to No-tifyFailure, it suggests an alternative close to the user's original query and provides a limited prompt.",
                "Finally, when MIMIC has neither initiative, it simply adopts No-tifyFailure, allowing the user to determine the next discourse goal."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:The strategies employed when MIMIC has only dialogue initiative are similar to the mixed initiative dialogue strategies employed by many existing spoken dialogue systems ( e.g. , ( #REF ; #TARGET_REF ) ) . To instantiate an attribute, MIMIC adopts the lnfoSeek dialogue act to solicit the missing information. In contrast, when MIMIC has both initiatives, it plays a more active role by presenting the user with additional information comprising valid instantiations of the attribute (GiveOptions). Given an invalid query, MIMIC notifies the user of the failed query and provides an openended prompt when it only has dialogue initiative. When MIMIC has both initiatives, however, in addition to No-tifyFailure, it suggests an alternative close to the user's original query and provides a limited prompt. Finally, when MIMIC has neither initiative, it simply adopts No-tifyFailure, allowing the user to determine the next discourse goal.",
        "output": "nan:The strategies employed when MIMIC has only dialogue initiative are similar to the mixed initiative dialogue strategies employed by many existing spoken dialogue systems ( e.g. , ( #REF ; #TARGET_REF<USE/> ) ) . To instantiate an attribute, MIMIC adopts the lnfoSeek dialogue act to solicit the missing information. In contrast, when MIMIC has both initiatives, it plays a more active role by presenting the user with additional information comprising valid instantiations of the attribute (GiveOptions). Given an invalid query, MIMIC notifies the user of the failed query and provides an openended prompt when it only has dialogue initiative. When MIMIC has both initiatives, however, in addition to No-tifyFailure, it suggests an alternative close to the user's original query and provides a limited prompt. Finally, when MIMIC has neither initiative, it simply adopts No-tifyFailure, allowing the user to determine the next discourse goal."
    },
    {
        "gold": {
            "text": [
                "Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #REF ; #TARGET_REF ; #REF ) .",
                "Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution.",
                "Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work.",
                "rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #REF ; #TARGET_REF ; #REF ) . Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution. Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work. rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1.",
        "output": "nan:Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) . Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution. Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work. rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1."
    },
    {
        "gold": {
            "text": [
                "Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #TARGET_REF ; #REF ; #REF ) .",
                "Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution.",
                "Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work.",
                "rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #TARGET_REF ; #REF ; #REF ) . Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution. Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work. rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1.",
        "output": "nan:Previous work has argued that initiative affects the degree of control an agent has in the dialogue interaction ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . Thus, a cooperative system may adopt different strategies to achieve the same goal depending on the initiative distribution. Since task initiative models contribution to domain/problemsolving goals, while dialogue initiative affects the cur-5An alternative strategy to step ( 4) is to perform a database lookup based on the ambiguous query and summarize the results (#REF), which we leave for future work. rent discourse goal, we developed alternative strategies for achieving the goals in Figure 4 based on initiative distribution, as shown in Table 1."
    },
    {
        "gold": {
            "text": [
                "We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities.",
                "We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems.",
                "In this section we summarize these experiments and their results.",
                "A companion paper describes the evaluation process and results in further detail ( #TARGET_REF ) .",
                "Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information.",
                "User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system.",
                "Furthermore, a number of performance features, largely based on the PARADISE dialogue evaluation scheme (#REF), were automatically logged, derived, or manually annotated.",
                "In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "experiments:We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities. We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems. In this section we summarize these experiments and their results. A companion paper describes the evaluation process and results in further detail ( #TARGET_REF ) . Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information. User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system. Furthermore, a number of performance features, largely based on the PARADISE dialogue evaluation scheme (#REF), were automatically logged, derived, or manually annotated. In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response.",
        "output": "experiments:We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities. We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems. In this section we summarize these experiments and their results. A companion paper describes the evaluation process and results in further detail ( #TARGET_REF<COMPARISON/> ) . Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information. User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system. Furthermore, a number of performance features, largely based on the PARADISE dialogue evaluation scheme (#REF), were automatically logged, derived, or manually annotated. In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response."
    },
    {
        "gold": {
            "text": [
                "5An alternative strategy to step ( 4 ) is to perform a database lookup based on the ambiguous query and summarize the results ( #TARGET_REF ) , which we leave for future work ."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "nan:5An alternative strategy to step ( 4 ) is to perform a database lookup based on the ambiguous query and summarize the results ( #TARGET_REF ) , which we leave for future work .",
        "output": "nan:5An alternative strategy to step ( 4 ) is to perform a database lookup based on the ambiguous query and summarize the results ( #TARGET_REF<MOTIVATION/> ) , which we leave for future work ."
    },
    {
        "gold": {
            "text": [
                "We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities.",
                "We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems.",
                "In this section we summarize these experiments and their results.",
                "A companion paper describes the evaluation process and results in further detail (#REF).",
                "Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information.",
                "User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system.",
                "Furthermore , a number of performance features , largely based on the PARADISE dialogue evaluation scheme ( #TARGET_REF ) , were automatically logged , derived , or manually annotated .",
                "In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities. We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems. In this section we summarize these experiments and their results. A companion paper describes the evaluation process and results in further detail (#REF). Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information. User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system. Furthermore , a number of performance features , largely based on the PARADISE dialogue evaluation scheme ( #TARGET_REF ) , were automatically logged , derived , or manually annotated . In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response.",
        "output": "experiments:We conducted two experiments to evaluate MIMIC's automatic adaptation capabilities. We compared MIMIC with two control systems: MIMIC-SI, a system-initiative version of MIMIC in which the system retains both initiatives throughout the dialogue, and MIMIC-MI, a nonadaptive mixed-initiative version of MIMIC that resembles the behavior of many existing dialogue systems. In this section we summarize these experiments and their results. A companion paper describes the evaluation process and results in further detail (#REF). Each experiment involved eight users interacting with MIMIC and MIMIC-SI or MIMIC-MI to perform a set of tasks, each requiring the user to obtain specific movie information. User satisfaction was assessed by asking the subjects to fill out a questionnaire after interacting with each version of the system. Furthermore , a number of performance features , largely based on the PARADISE dialogue evaluation scheme ( #TARGET_REF<FUTURE/> ) , were automatically logged , derived , or manually annotated . In addition, we logged the cues automatically detected in each user utterance, as well as the initiative distribution for each turn and the dialogue acts selected to generate each system response."
    },
    {
        "gold": {
            "text": [
                "Previous systems to assist in the development of spoken-langnage systems (SLSs) have focused on building stand-alone, customized applications, such as (#REF) and (#REF).",
                "The goal of the JAVOX toolkit is to speech-enable traditional desktop applications -- this is similar to the goals of the MELISSA project ( #TARGET_REF ) .",
                "It is intended to both speed the development of SLSs and to localize the speech-specific code within the application.",
                "JAVOX allows developers to add speech interfaces to applications at the end of the development process; SLSs no longer need to be built from the ground up."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:Previous systems to assist in the development of spoken-langnage systems (SLSs) have focused on building stand-alone, customized applications, such as (#REF) and (#REF). The goal of the JAVOX toolkit is to speech-enable traditional desktop applications -- this is similar to the goals of the MELISSA project ( #TARGET_REF ) . It is intended to both speed the development of SLSs and to localize the speech-specific code within the application. JAVOX allows developers to add speech interfaces to applications at the end of the development process; SLSs no longer need to be built from the ground up.",
        "output": "nan:Previous systems to assist in the development of spoken-langnage systems (SLSs) have focused on building stand-alone, customized applications, such as (#REF) and (#REF). The goal of the JAVOX toolkit is to speech-enable traditional desktop applications -- this is similar to the goals of the MELISSA project ( #TARGET_REF<USE/> ) . It is intended to both speed the development of SLSs and to localize the speech-specific code within the application. JAVOX allows developers to add speech interfaces to applications at the end of the development process; SLSs no longer need to be built from the ground up."
    },
    {
        "gold": {
            "text": [
                "One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints (#REF;#REF;hua #REF;#REF;#REF).",
                "It is also possible to focus on non-compositional compounds , a key point in bilingual applications ( #TARGET_REF ; #REF ; #REF ) .",
                "Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF).",
                "In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags.",
                "An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints (#REF;#REF;hua #REF;#REF;#REF). It is also possible to focus on non-compositional compounds , a key point in bilingual applications ( #TARGET_REF ; #REF ; #REF ) . Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF). In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags. An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%).",
        "output": "method:One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints (#REF;#REF;hua #REF;#REF;#REF). It is also possible to focus on non-compositional compounds , a key point in bilingual applications ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF). In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags. An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%)."
    },
    {
        "gold": {
            "text": [
                "Finding relevant units in a text has been explored in many areas of natural language processing.",
                "Our approach relies on distributional and frequency statistics computed on each sequence of words found in a training corpus.",
                "For sake of efficiency, we used the suffix array technique to get a compact representation of our training corpus.",
                "This method allows the efficient retrieval of arbitrary length n-grams ( #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:Finding relevant units in a text has been explored in many areas of natural language processing. Our approach relies on distributional and frequency statistics computed on each sequence of words found in a training corpus. For sake of efficiency, we used the suffix array technique to get a compact representation of our training corpus. This method allows the efficient retrieval of arbitrary length n-grams ( #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) .",
        "output": "method:Finding relevant units in a text has been explored in many areas of natural language processing. Our approach relies on distributional and frequency statistics computed on each sequence of words found in a training corpus. For sake of efficiency, we used the suffix array technique to get a compact representation of our training corpus. This method allows the efficient retrieval of arbitrary length n-grams ( #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints ( #REF ; #TARGET_REF ; hua #REF ; #REF ; #REF ) .",
                "It is also possible to focus on non-compositional compounds, a key point in bilingual applications (#REF;#REF;#REF).",
                "Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF).",
                "In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags.",
                "An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%)."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints ( #REF ; #TARGET_REF ; hua #REF ; #REF ; #REF ) . It is also possible to focus on non-compositional compounds, a key point in bilingual applications (#REF;#REF;#REF). Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF). In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags. An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%).",
        "output": "method:One way to increase the precision of the mapping process is to impose some linguistic constraints on the sequences such as simple noun-phrase contraints ( #REF ; #TARGET_REF<FUTURE/> ; hua #REF ; #REF ; #REF ) . It is also possible to focus on non-compositional compounds, a key point in bilingual applications (#REF;#REF;#REF). Another interesting approach is to restrict sequences to those that do not cross constituent boundary patterns (#REF;#REF). In this study, we filtered for potential sequences that are likely to be noun phrases, using simple regular expressions over the associated part-of-speech tags. An excerpt of the association probabilities of a unit model trained considering only the NP-sequences is given in table 3. Applying this filter (referred to as JrNp in the following) to the 39,093 english sequences still surviving after previous filters ~'1 and ~'2 removes 35,939 of them (92%)."
    },
    {
        "gold": {
            "text": [
                "The speech and language processing architecture is based on that of the SRI CommandTalk system ( #TARGET_REF ; #REF ) .",
                "The system comprises a suite of about 20 agents, connected together using the SPd Open Agent Architecture (OAA; (#REF)).",
                "Speech recognition is performed using a version of the Nuance recognizer (#REF).",
                "Initial language processing is carried out using the SRI Gemini system (#REF), using a domain~independent unification grammar and a domain-specific lexicon.",
                "The language processing grammar is compiled into a recognition grarnm~kr using the methods of (#REF); the net result is that only grammatically wellformed utterances can be recognized.",
                "Output from the initial language-processing step is represented in a version of Quasi Logical Form (#REF), and passed in that form to the dialogue manager.",
                "We refer to these as linguistic level representations."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:The speech and language processing architecture is based on that of the SRI CommandTalk system ( #TARGET_REF ; #REF ) . The system comprises a suite of about 20 agents, connected together using the SPd Open Agent Architecture (OAA; (#REF)). Speech recognition is performed using a version of the Nuance recognizer (#REF). Initial language processing is carried out using the SRI Gemini system (#REF), using a domain~independent unification grammar and a domain-specific lexicon. The language processing grammar is compiled into a recognition grarnm~kr using the methods of (#REF); the net result is that only grammatically wellformed utterances can be recognized. Output from the initial language-processing step is represented in a version of Quasi Logical Form (#REF), and passed in that form to the dialogue manager. We refer to these as linguistic level representations.",
        "output": "experiments:The speech and language processing architecture is based on that of the SRI CommandTalk system ( #TARGET_REF<FUTURE/> ; #REF ) . The system comprises a suite of about 20 agents, connected together using the SPd Open Agent Architecture (OAA; (#REF)). Speech recognition is performed using a version of the Nuance recognizer (#REF). Initial language processing is carried out using the SRI Gemini system (#REF), using a domain~independent unification grammar and a domain-specific lexicon. The language processing grammar is compiled into a recognition grarnm~kr using the methods of (#REF); the net result is that only grammatically wellformed utterances can be recognized. Output from the initial language-processing step is represented in a version of Quasi Logical Form (#REF), and passed in that form to the dialogue manager. We refer to these as linguistic level representations."
    },
    {
        "gold": {
            "text": [
                "More recent work on spoken language interfaces to semi-antonomous robots include SRrs Flakey robot (#REF) and NCARArs InterBOT project (#REF;#REF).",
                "A number of other systems have addressed part of the task.",
                "CornmandTalk ( #TARGET_REF ) , Circuit Fix-It Shop ( #REF ) and TRAINS-96 ( #REF ; #REF ) are spoken language systems but they interface to simulation or help facilities rather than semi-autonomous agents .",
                "Jack's MOOse Lodge (#REF) takes text rather than speech as natural language input and the avatars being controlled are not semi-autonomous.",
                "Other researchers have considered particular aspects of the problem such as accounting for various aspects of actions (#REF;#REF).",
                "In most of this and other related work the treatment is some variant of the following.",
                "If there is a speech interface, the input speech signal is converted into text.",
                "Text either from the recognizer or directly input by the user is then converted into some kind of logical formula, which abstractly represents the user's intended command; this formula is then fed into a command interpreter, which executes the command."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:More recent work on spoken language interfaces to semi-antonomous robots include SRrs Flakey robot (#REF) and NCARArs InterBOT project (#REF;#REF). A number of other systems have addressed part of the task. CornmandTalk ( #TARGET_REF ) , Circuit Fix-It Shop ( #REF ) and TRAINS-96 ( #REF ; #REF ) are spoken language systems but they interface to simulation or help facilities rather than semi-autonomous agents . Jack's MOOse Lodge (#REF) takes text rather than speech as natural language input and the avatars being controlled are not semi-autonomous. Other researchers have considered particular aspects of the problem such as accounting for various aspects of actions (#REF;#REF). In most of this and other related work the treatment is some variant of the following. If there is a speech interface, the input speech signal is converted into text. Text either from the recognizer or directly input by the user is then converted into some kind of logical formula, which abstractly represents the user's intended command; this formula is then fed into a command interpreter, which executes the command.",
        "output": "introduction:More recent work on spoken language interfaces to semi-antonomous robots include SRrs Flakey robot (#REF) and NCARArs InterBOT project (#REF;#REF). A number of other systems have addressed part of the task. CornmandTalk ( #TARGET_REF<BACKGROUND/> ) , Circuit Fix-It Shop ( #REF ) and TRAINS-96 ( #REF ; #REF ) are spoken language systems but they interface to simulation or help facilities rather than semi-autonomous agents . Jack's MOOse Lodge (#REF) takes text rather than speech as natural language input and the avatars being controlled are not semi-autonomous. Other researchers have considered particular aspects of the problem such as accounting for various aspects of actions (#REF;#REF). In most of this and other related work the treatment is some variant of the following. If there is a speech interface, the input speech signal is converted into text. Text either from the recognizer or directly input by the user is then converted into some kind of logical formula, which abstractly represents the user's intended command; this formula is then fed into a command interpreter, which executes the command."
    },
    {
        "gold": {
            "text": [
                "1.",
                "An aligner.",
                "After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program.",
                "This alignment is done on the basis of both length (#REF) and a notion of cognateness (Simard [161).",
                "2. Transducers.",
                "In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required.",
                "This is done with transducers (#REF).",
                "3. Part-of-speech tagger.",
                "Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates).",
                "~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them.",
                "We do this with a first-order HMM part-ofspeech tagger ( Merialdo #TARGET_REF ) .",
                "I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:1. An aligner. After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program. This alignment is done on the basis of both length (#REF) and a notion of cognateness (Simard [161). 2. Transducers. In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required. This is done with transducers (#REF). 3. Part-of-speech tagger. Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates). ~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them. We do this with a first-order HMM part-ofspeech tagger ( Merialdo #TARGET_REF ) . I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general.",
        "output": "nan:1. An aligner. After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program. This alignment is done on the basis of both length (#REF) and a notion of cognateness (Simard [161). 2. Transducers. In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required. This is done with transducers (#REF). 3. Part-of-speech tagger. Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates). ~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them. We do this with a first-order HMM part-ofspeech tagger ( Merialdo #TARGET_REF<FUTURE/> ) . I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general."
    },
    {
        "gold": {
            "text": [
                "1.",
                "An aligner.",
                "After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program.",
                "This alignment is done on the basis of both length ( Gale and Church #TARGET_REF ) and a notion of cognateness ( #REF ) .",
                "2. Transducers.",
                "In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required.",
                "This is done with transducers (#REF).",
                "3. Part-of-speech tagger.",
                "Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates).",
                "~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them.",
                "We do this with a first-order HMM part-ofspeech tagger (#REF).",
                "I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:1. An aligner. After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program. This alignment is done on the basis of both length ( Gale and Church #TARGET_REF ) and a notion of cognateness ( #REF ) . 2. Transducers. In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required. This is done with transducers (#REF). 3. Part-of-speech tagger. Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates). ~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them. We do this with a first-order HMM part-ofspeech tagger (#REF). I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general.",
        "output": "nan:1. An aligner. After identification of word and sentence boundaries the text is processed into a bi-text by an alignment program. This alignment is done on the basis of both length ( Gale and Church #TARGET_REF<FUTURE/> ) and a notion of cognateness ( #REF ) . 2. Transducers. In order to compare numerical expressions, which often diverge in format between given pairs of languages, normalisation toward a common format is required. This is done with transducers (#REF). 3. Part-of-speech tagger. Misleading similarities in graphical form can sometime induce translation mistakes (deceptive cognates). ~ These forbidden pairs normally involve only one of several possible parts of speech, hence the need to disambiguate them. We do this with a first-order HMM part-ofspeech tagger (#REF). I In the rest of the paper, we will use deceptive cognate very Iosely often to refer to normative usage of word in general."
    },
    {
        "gold": {
            "text": [
                "â¢ Before indexing the text , we process it with Textract ( #REF ; #TARGET_REF ) , which performs lemmatization , and discovers proper names and technical terms .",
                "We added a new module (Resporator) which annotates text segments with QA-Tokens using pattern matching.",
                "Thus the text \"for 5 centuries\" matches the DURATIONS pattern \"for :CARDINAL _timeperiod\", where :CAR-DINAL is the label for cardinal numbers, and _timeperiod marks a time expression."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:â¢ Before indexing the text , we process it with Textract ( #REF ; #TARGET_REF ) , which performs lemmatization , and discovers proper names and technical terms . We added a new module (Resporator) which annotates text segments with QA-Tokens using pattern matching. Thus the text \"for 5 centuries\" matches the DURATIONS pattern \"for :CARDINAL _timeperiod\", where :CAR-DINAL is the label for cardinal numbers, and _timeperiod marks a time expression.",
        "output": "experiments:â¢ Before indexing the text , we process it with Textract ( #REF ; #TARGET_REF<FUTURE/> ) , which performs lemmatization , and discovers proper names and technical terms . We added a new module (Resporator) which annotates text segments with QA-Tokens using pattern matching. Thus the text \"for 5 centuries\" matches the DURATIONS pattern \"for :CARDINAL _timeperiod\", where :CAR-DINAL is the label for cardinal numbers, and _timeperiod marks a time expression."
    },
    {
        "gold": {
            "text": [
                "MorphAna: Morphological Analysis provided by sines yields the word stems of nouns, verbs and adjectives, as well as the full forms of unknown words.",
                "We are using a lexicon of approx.",
                "100000 word stems of German ( #TARGET_REF ) ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:MorphAna: Morphological Analysis provided by sines yields the word stems of nouns, verbs and adjectives, as well as the full forms of unknown words. We are using a lexicon of approx. 100000 word stems of German ( #TARGET_REF ) .",
        "output": "experiments:MorphAna: Morphological Analysis provided by sines yields the word stems of nouns, verbs and adjectives, as well as the full forms of unknown words. We are using a lexicon of approx. 100000 word stems of German ( #TARGET_REF<FUTURE/> ) ."
    },
    {
        "gold": {
            "text": [
                "Linguistic preprocessing of text documents is carried out by re-using smes , an information extraction core system for real-world German text processing ( #TARGET_REF ) .",
                "The fundamental design criterion of sines is to provide a set of basic, powerful, robust, and efficient STP components and 4Almost all tools we examined build a single multicategorizer except for SVM-Light, which builds multiple binary classifiers.",
                "generic linguistic knowledge sources that can easily be customized to deal with different tasks in a flexible manner, sines includes a text tokenizer, a lexical processor and a chunk parser.",
                "The chunk parser itself is subdivided into three components.",
                "In the first step, phrasal fragments like general nominal expressions and verb groups are recognized.",
                "Next, the dependency-based structure of the fragments of each sentence is computed using a set of specific sentence patterns.",
                "Third, the grammatical functions are determined for each dependency-based structure on the basis of a large subcategorization lexicon.",
                "The present application benefits from the high modularity of the usage of the components.",
                "Thus, it is possible to run only a subset of the components and to tailor their output.",
                "The experiments described in Section 4 make use of this feature."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:Linguistic preprocessing of text documents is carried out by re-using smes , an information extraction core system for real-world German text processing ( #TARGET_REF ) . The fundamental design criterion of sines is to provide a set of basic, powerful, robust, and efficient STP components and 4Almost all tools we examined build a single multicategorizer except for SVM-Light, which builds multiple binary classifiers. generic linguistic knowledge sources that can easily be customized to deal with different tasks in a flexible manner, sines includes a text tokenizer, a lexical processor and a chunk parser. The chunk parser itself is subdivided into three components. In the first step, phrasal fragments like general nominal expressions and verb groups are recognized. Next, the dependency-based structure of the fragments of each sentence is computed using a set of specific sentence patterns. Third, the grammatical functions are determined for each dependency-based structure on the basis of a large subcategorization lexicon. The present application benefits from the high modularity of the usage of the components. Thus, it is possible to run only a subset of the components and to tailor their output. The experiments described in Section 4 make use of this feature.",
        "output": "nan:Linguistic preprocessing of text documents is carried out by re-using smes , an information extraction core system for real-world German text processing ( #TARGET_REF<FUTURE/> ) . The fundamental design criterion of sines is to provide a set of basic, powerful, robust, and efficient STP components and 4Almost all tools we examined build a single multicategorizer except for SVM-Light, which builds multiple binary classifiers. generic linguistic knowledge sources that can easily be customized to deal with different tasks in a flexible manner, sines includes a text tokenizer, a lexical processor and a chunk parser. The chunk parser itself is subdivided into three components. In the first step, phrasal fragments like general nominal expressions and verb groups are recognized. Next, the dependency-based structure of the fragments of each sentence is computed using a set of specific sentence patterns. Third, the grammatical functions are determined for each dependency-based structure on the basis of a large subcategorization lexicon. The present application benefits from the high modularity of the usage of the components. Thus, it is possible to run only a subset of the components and to tailor their output. The experiments described in Section 4 make use of this feature."
    },
    {
        "gold": {
            "text": [
                "The NP-based QA System.",
                "Our implementation of the NP-based QA system uses the Empire noun phrase finder , which is described in detail in #TARGET_REF .",
                "Empire identifies base NPs --non-recursive noun phrases --using a very simple algorithm that matches part-of-speech tag sequences based on a learned noun phrase grammar.",
                "The approach is able to achieve 94% precision and recall for base NPs derived from the Penn Treebank Wall Street Journal (#REF).",
                "In the experiments below, the NP filter follows the application of the document retrieval and text summarization components.",
                "Pronoun answer hypotheses are discarded, and the NPs are assembled into 50-byte chunks."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:The NP-based QA System. Our implementation of the NP-based QA system uses the Empire noun phrase finder , which is described in detail in #TARGET_REF . Empire identifies base NPs --non-recursive noun phrases --using a very simple algorithm that matches part-of-speech tag sequences based on a learned noun phrase grammar. The approach is able to achieve 94% precision and recall for base NPs derived from the Penn Treebank Wall Street Journal (#REF). In the experiments below, the NP filter follows the application of the document retrieval and text summarization components. Pronoun answer hypotheses are discarded, and the NPs are assembled into 50-byte chunks.",
        "output": "nan:The NP-based QA System. Our implementation of the NP-based QA system uses the Empire noun phrase finder , which is described in detail in #TARGET_REF<FUTURE/> . Empire identifies base NPs --non-recursive noun phrases --using a very simple algorithm that matches part-of-speech tag sequences based on a learned noun phrase grammar. The approach is able to achieve 94% precision and recall for base NPs derived from the Penn Treebank Wall Street Journal (#REF). In the experiments below, the NP filter follows the application of the document retrieval and text summarization components. Pronoun answer hypotheses are discarded, and the NPs are assembled into 50-byte chunks."
    },
    {
        "gold": {
            "text": [
                "We next hypothesize that query-dependent text summarization algorithms will improve the performance of the QA system by focusing the system on the most relevant portions of the retrieved documents.",
                "The goal for query-dependent summarization algorithms is to provide a short summary of a document with respect to a specific query.",
                "Although a number of methods for query-dependent text summarization are beginning to be developed and evaluated in a variety of realistic settings ( #TARGET_REF ) , we again propose the use of vector space methods from IR , which can be easily extended to the summarization task ( #REF ) :"
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:We next hypothesize that query-dependent text summarization algorithms will improve the performance of the QA system by focusing the system on the most relevant portions of the retrieved documents. The goal for query-dependent summarization algorithms is to provide a short summary of a document with respect to a specific query. Although a number of methods for query-dependent text summarization are beginning to be developed and evaluated in a variety of realistic settings ( #TARGET_REF ) , we again propose the use of vector space methods from IR , which can be easily extended to the summarization task ( #REF ) :",
        "output": "nan:We next hypothesize that query-dependent text summarization algorithms will improve the performance of the QA system by focusing the system on the most relevant portions of the retrieved documents. The goal for query-dependent summarization algorithms is to provide a short summary of a document with respect to a specific query. Although a number of methods for query-dependent text summarization are beginning to be developed and evaluated in a variety of realistic settings ( #TARGET_REF<USE/> ) , we again propose the use of vector space methods from IR , which can be easily extended to the summarization task ( #REF ) :"
    },
    {
        "gold": {
            "text": [
                "The aim of this paper is to give a detailed account of the techniques used in TnT.",
                "Additionally, we present results of the tagger on the NEGRA corpus (#REF) and the Penn Treebank (#REF).",
                "The Penn Treebank results reported here for the Markov model approach are at least equivalent to those reported for the Maximum Entropy approach in ( #TARGET_REF ) .",
                "For a comparison to other taggers, the reader is referred to (#REF)."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:The aim of this paper is to give a detailed account of the techniques used in TnT. Additionally, we present results of the tagger on the NEGRA corpus (#REF) and the Penn Treebank (#REF). The Penn Treebank results reported here for the Markov model approach are at least equivalent to those reported for the Maximum Entropy approach in ( #TARGET_REF ) . For a comparison to other taggers, the reader is referred to (#REF).",
        "output": "introduction:The aim of this paper is to give a detailed account of the techniques used in TnT. Additionally, we present results of the tagger on the NEGRA corpus (#REF) and the Penn Treebank (#REF). The Penn Treebank results reported here for the Markov model approach are at least equivalent to those reported for the Maximum Entropy approach in ( #TARGET_REF<USE/> ) . For a comparison to other taggers, the reader is referred to (#REF)."
    },
    {
        "gold": {
            "text": [
                "We have shown that a tagger based on Markov models yields state-of-the-art results, despite contrary claims found in the literature.",
                "For example, the Markov model tagger used in the comparison of (#REF) yielded worse results than all other taggers.",
                "In our opinion, a reason for the wrong claim is that the basic algorithms leave several decisions to the implementor.",
                "The rather large amount of freedom was not handled in detail in previous publications: handling of start-and end-of-sequence, the exact smoothing technique, how to determine the weights for context probabilities, details on handling unknown words, and how to determine the weights for unknown words.",
                "Note that the decisions we made yield good results for both the German and the English Corpus.",
                "They do so for several other corpora as well.",
                "The architecture remains applicable to a large variety of languages.",
                "According to current tagger comparisons ( #REF ; #REF ) , and according to a comparsion of the results presented here with those in ( #TARGET_REF ) , the Maximum Entropy framework seems to be the only other approach yielding comparable results to the one presented here .",
                "It is a very interesting future research topic to determine the advantages of either of these approaches, to find the reason for their high accuracies, and to find a good combination of both."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:We have shown that a tagger based on Markov models yields state-of-the-art results, despite contrary claims found in the literature. For example, the Markov model tagger used in the comparison of (#REF) yielded worse results than all other taggers. In our opinion, a reason for the wrong claim is that the basic algorithms leave several decisions to the implementor. The rather large amount of freedom was not handled in detail in previous publications: handling of start-and end-of-sequence, the exact smoothing technique, how to determine the weights for context probabilities, details on handling unknown words, and how to determine the weights for unknown words. Note that the decisions we made yield good results for both the German and the English Corpus. They do so for several other corpora as well. The architecture remains applicable to a large variety of languages. According to current tagger comparisons ( #REF ; #REF ) , and according to a comparsion of the results presented here with those in ( #TARGET_REF ) , the Maximum Entropy framework seems to be the only other approach yielding comparable results to the one presented here . It is a very interesting future research topic to determine the advantages of either of these approaches, to find the reason for their high accuracies, and to find a good combination of both.",
        "output": "conclusion:We have shown that a tagger based on Markov models yields state-of-the-art results, despite contrary claims found in the literature. For example, the Markov model tagger used in the comparison of (#REF) yielded worse results than all other taggers. In our opinion, a reason for the wrong claim is that the basic algorithms leave several decisions to the implementor. The rather large amount of freedom was not handled in detail in previous publications: handling of start-and end-of-sequence, the exact smoothing technique, how to determine the weights for context probabilities, details on handling unknown words, and how to determine the weights for unknown words. Note that the decisions we made yield good results for both the German and the English Corpus. They do so for several other corpora as well. The architecture remains applicable to a large variety of languages. According to current tagger comparisons ( #REF ; #REF ) , and according to a comparsion of the results presented here with those in ( #TARGET_REF<USE/> ) , the Maximum Entropy framework seems to be the only other approach yielding comparable results to the one presented here . It is a very interesting future research topic to determine the advantages of either of these approaches, to find the reason for their high accuracies, and to find a good combination of both."
    },
    {
        "gold": {
            "text": [
                "Four similarity measures were examined.",
                "The cosine coefficient (R98(s,co,)) and dot density measure (R98(m,(lot)) yield similar results.",
                "Our spread activation based semantic measure (R98( .....,)) improved a.ccura(:y.",
                "This confirms that although Kozima 's approach ( #TARGET_REF ) is computationally expensive , it does produce more precise segmentation ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:Four similarity measures were examined. The cosine coefficient (R98(s,co,)) and dot density measure (R98(m,(lot)) yield similar results. Our spread activation based semantic measure (R98( .....,)) improved a.ccura(:y. This confirms that although Kozima 's approach ( #TARGET_REF ) is computationally expensive , it does produce more precise segmentation .",
        "output": "nan:Four similarity measures were examined. The cosine coefficient (R98(s,co,)) and dot density measure (R98(m,(lot)) yield similar results. Our spread activation based semantic measure (R98( .....,)) improved a.ccura(:y. This confirms that although Kozima 's approach ( #TARGET_REF<USE/> ) is computationally expensive , it does produce more precise segmentation ."
    },
    {
        "gold": {
            "text": [
                "R98 ( , , , , â ) uses a variant of Kozima 's semantic similarity measure ( #TARGET_REF ) to compute block similarity .",
                "Word similarity is a function of word co- occurrence statistics in the given document.",
                "Words that belong to the same sentence are considered to be related.",
                "Given the co-occurrence frequencies f(wi, wj), the transition probability matrix t is computed by equation 10.",
                "Equation 11 defines our spread activation scheme, s denotes the word similarity matrix, x is the number of activation steps and norm(y) converts a matrix y into a transition matrix, x = 5 was used in the experiment."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "nan:R98 ( , , , , â ) uses a variant of Kozima 's semantic similarity measure ( #TARGET_REF ) to compute block similarity . Word similarity is a function of word co- occurrence statistics in the given document. Words that belong to the same sentence are considered to be related. Given the co-occurrence frequencies f(wi, wj), the transition probability matrix t is computed by equation 10. Equation 11 defines our spread activation scheme, s denotes the word similarity matrix, x is the number of activation steps and norm(y) converts a matrix y into a transition matrix, x = 5 was used in the experiment.",
        "output": "nan:R98 ( , , , , â ) uses a variant of Kozima 's semantic similarity measure ( #TARGET_REF<COMPARISON/> ) to compute block similarity . Word similarity is a function of word co- occurrence statistics in the given document. Words that belong to the same sentence are considered to be related. Given the co-occurrence frequencies f(wi, wj), the transition probability matrix t is computed by equation 10. Equation 11 defines our spread activation scheme, s denotes the word similarity matrix, x is the number of activation steps and norm(y) converts a matrix y into a transition matrix, x = 5 was used in the experiment."
    },
    {
        "gold": {
            "text": [
                "In related work, #REF describes an ap- proach to packing in which alternative feature structures are represented as packed, distributed disjunctions of feature structure fragments.",
                "Although the approach may have potential , the shifting of complex accounting into the unification algorithm is at variance with the findings of #TARGET_REF , who report large speed-ups from the elimination of disjunction processing during unification .",
                "Unfortunately, the reported evaluation measures and lack of discussion of parser control issues are insufficient to allow a precise comparison."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:In related work, #REF describes an ap- proach to packing in which alternative feature structures are represented as packed, distributed disjunctions of feature structure fragments. Although the approach may have potential , the shifting of complex accounting into the unification algorithm is at variance with the findings of #TARGET_REF , who report large speed-ups from the elimination of disjunction processing during unification . Unfortunately, the reported evaluation measures and lack of discussion of parser control issues are insufficient to allow a precise comparison.",
        "output": "conclusion:In related work, #REF describes an ap- proach to packing in which alternative feature structures are represented as packed, distributed disjunctions of feature structure fragments. Although the approach may have potential , the shifting of complex accounting into the unification algorithm is at variance with the findings of #TARGET_REF<USE/> , who report large speed-ups from the elimination of disjunction processing during unification . Unfortunately, the reported evaluation measures and lack of discussion of parser control issues are insufficient to allow a precise comparison."
    },
    {
        "gold": {
            "text": [
                "In this paper we have provided an original mathematical argument in favour of this thesis.",
                "Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1).",
                "We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #TARGET_REF ) and ( #REF ) .",
                "We leave this for future work."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:In this paper we have provided an original mathematical argument in favour of this thesis. Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1). We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #TARGET_REF ) and ( #REF ) . We leave this for future work.",
        "output": "conclusion:In this paper we have provided an original mathematical argument in favour of this thesis. Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1). We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #TARGET_REF<MOTIVATION/> ) and ( #REF ) . We leave this for future work."
    },
    {
        "gold": {
            "text": [
                "In this paper we have provided an original mathematical argument in favour of this thesis.",
                "Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1).",
                "We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #REF ) and ( #TARGET_REF ) .",
                "We leave this for future work."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:In this paper we have provided an original mathematical argument in favour of this thesis. Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1). We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #REF ) and ( #TARGET_REF ) . We leave this for future work.",
        "output": "conclusion:In this paper we have provided an original mathematical argument in favour of this thesis. Our results hold for bilexical context-free grammars and directly transfer to several language models that can be seen as stochastic versions of this formalism (see Section 1). We perceive that these results can be extended to other language models that properly embed bilexical context-free grammars , as for instance the more general history-based models used in ( #REF ) and ( #TARGET_REF<MOTIVATION/> ) . We leave this for future work."
    },
    {
        "gold": {
            "text": [
                "Accuracy is not the best measure to assess segmentation quality , therefore we also conducted experiments using the WindowDiff measure as proposed by #TARGET_REF .",
                "WindowDiff returns 0 in case of a perfect segmentation; 1 is the worst possible score.",
                "However, it only takes into account segment boundaries and disregards segment types.",
                "In section 5.2, we mentioned that loopy BP is not guaranteed to converge in a finite number of iterations.",
                "Since we optimize pseudolikelihood for parameter estimation, we are not affected by this limitation in the training phase.",
                "However, we use loopy BP with a TRP schedule during testing, so we must expect to encounter non-convergence for some examples.",
                "Theoretical results on this topic are discussed by #REF.",
                "We give here an empirical observation of convergence behaviour of loopy BP in our setting; the maximum number of iterations of the TRP schedule was restricted to 1,000.",
                "Table 4 shows the percentage of examples converging within this limit and the average number of iterations required by the converging examples, broken down by the different corpora.",
                "From these results, we conclude that there is a connection between the quality of the annotation and the convergence behaviour of loopy BP."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:Accuracy is not the best measure to assess segmentation quality , therefore we also conducted experiments using the WindowDiff measure as proposed by #TARGET_REF . WindowDiff returns 0 in case of a perfect segmentation; 1 is the worst possible score. However, it only takes into account segment boundaries and disregards segment types. In section 5.2, we mentioned that loopy BP is not guaranteed to converge in a finite number of iterations. Since we optimize pseudolikelihood for parameter estimation, we are not affected by this limitation in the training phase. However, we use loopy BP with a TRP schedule during testing, so we must expect to encounter non-convergence for some examples. Theoretical results on this topic are discussed by #REF. We give here an empirical observation of convergence behaviour of loopy BP in our setting; the maximum number of iterations of the TRP schedule was restricted to 1,000. Table 4 shows the percentage of examples converging within this limit and the average number of iterations required by the converging examples, broken down by the different corpora. From these results, we conclude that there is a connection between the quality of the annotation and the convergence behaviour of loopy BP.",
        "output": "experiments:Accuracy is not the best measure to assess segmentation quality , therefore we also conducted experiments using the WindowDiff measure as proposed by #TARGET_REF<FUTURE/> . WindowDiff returns 0 in case of a perfect segmentation; 1 is the worst possible score. However, it only takes into account segment boundaries and disregards segment types. In section 5.2, we mentioned that loopy BP is not guaranteed to converge in a finite number of iterations. Since we optimize pseudolikelihood for parameter estimation, we are not affected by this limitation in the training phase. However, we use loopy BP with a TRP schedule during testing, so we must expect to encounter non-convergence for some examples. Theoretical results on this topic are discussed by #REF. We give here an empirical observation of convergence behaviour of loopy BP in our setting; the maximum number of iterations of the TRP schedule was restricted to 1,000. Table 4 shows the percentage of examples converging within this limit and the average number of iterations required by the converging examples, broken down by the different corpora. From these results, we conclude that there is a connection between the quality of the annotation and the convergence behaviour of loopy BP."
    },
    {
        "gold": {
            "text": [
                "Meronyms: For some relations, there is no contradiction when y 1 and y 2 share a meronym, i.e. \"part of\" relation.",
                "For example, in the set born in(Mozart,•) there is no contradiction between the y values \"Salzburg\" and \"Austria\", but \"Salzburg\" conflicts with \"Vienna\".",
                "Although this is only true in cases where y occurs in an upward monotone context ( #TARGET_REF ) , in practice genuine contradictions between y-values sharing a meronym relationship are extremely rare .",
                "We therefore simply assigned contradictions between meronyms a probability close to zero.",
                "We used the Tipster Gazetteer 4 and WordNet to identify meronyms, both of which have high precision but low coverage."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "experiments:Meronyms: For some relations, there is no contradiction when y 1 and y 2 share a meronym, i.e. \"part of\" relation. For example, in the set born in(Mozart,•) there is no contradiction between the y values \"Salzburg\" and \"Austria\", but \"Salzburg\" conflicts with \"Vienna\". Although this is only true in cases where y occurs in an upward monotone context ( #TARGET_REF ) , in practice genuine contradictions between y-values sharing a meronym relationship are extremely rare . We therefore simply assigned contradictions between meronyms a probability close to zero. We used the Tipster Gazetteer 4 and WordNet to identify meronyms, both of which have high precision but low coverage.",
        "output": "experiments:Meronyms: For some relations, there is no contradiction when y 1 and y 2 share a meronym, i.e. \"part of\" relation. For example, in the set born in(Mozart,•) there is no contradiction between the y values \"Salzburg\" and \"Austria\", but \"Salzburg\" conflicts with \"Vienna\". Although this is only true in cases where y occurs in an upward monotone context ( #TARGET_REF<EXTENSION/> ) , in practice genuine contradictions between y-values sharing a meronym relationship are extremely rare . We therefore simply assigned contradictions between meronyms a probability close to zero. We used the Tipster Gazetteer 4 and WordNet to identify meronyms, both of which have high precision but low coverage."
    },
    {
        "gold": {
            "text": [
                "To train our model, we use L-BFGS to locally maximize the log of the objective function (1): 15 These are the function words with count ≥ 40 in a random sample of 100 documents, and which were associated with the O-I tag transition at more than twice the average rate.",
                "We do not use any other lexical φ-features that reference x, for fear that they would enable the learner to explain the rationales without changing θ as desired (see the end of section 5.3). 14",
                "We parse each sentence with the Collins parser ( #TARGET_REF ) .",
                "Then the document has one big parse tree, whose root is DOC, with each sentence being a child of DOC."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:To train our model, we use L-BFGS to locally maximize the log of the objective function (1): 15 These are the function words with count ≥ 40 in a random sample of 100 documents, and which were associated with the O-I tag transition at more than twice the average rate. We do not use any other lexical φ-features that reference x, for fear that they would enable the learner to explain the rationales without changing θ as desired (see the end of section 5.3). 14 We parse each sentence with the Collins parser ( #TARGET_REF ) . Then the document has one big parse tree, whose root is DOC, with each sentence being a child of DOC.",
        "output": "nan:To train our model, we use L-BFGS to locally maximize the log of the objective function (1): 15 These are the function words with count ≥ 40 in a random sample of 100 documents, and which were associated with the O-I tag transition at more than twice the average rate. We do not use any other lexical φ-features that reference x, for fear that they would enable the learner to explain the rationales without changing θ as desired (see the end of section 5.3). 14 We parse each sentence with the Collins parser ( #TARGET_REF<FUTURE/> ) . Then the document has one big parse tree, whose root is DOC, with each sentence being a child of DOC."
    },
    {
        "gold": {
            "text": [
                "In #REF, we introduced the �Movie Review Polarity Dataset Enriched with Annotator Rationales.�8",
                "It is based on the dataset of #TARGET_REF ,9 which consists of 1000 positive and 1000 negative movie reviews , tokenized and divided into 10 folds ( F0 -- F9 ) .",
                "All our experiments use F9 as their final blind test set."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "experiments:In #REF, we introduced the �Movie Review Polarity Dataset Enriched with Annotator Rationales.�8 It is based on the dataset of #TARGET_REF ,9 which consists of 1000 positive and 1000 negative movie reviews , tokenized and divided into 10 folds ( F0 -- F9 ) . All our experiments use F9 as their final blind test set.",
        "output": "experiments:In #REF, we introduced the �Movie Review Polarity Dataset Enriched with Annotator Rationales.�8 It is based on the dataset of #TARGET_REF<COMPARISON/> ,9 which consists of 1000 positive and 1000 negative movie reviews , tokenized and divided into 10 folds ( F0 -- F9 ) . All our experiments use F9 as their final blind test set."
    },
    {
        "gold": {
            "text": [
                "A human annotator can provide hints to a machine learner by highlighting contextual \"rationales\" for each of his or her annotations (#REF).",
                "How can one exploit this side information to better learn the desired parameters θ?",
                "We present a generative model of how a given annotator, knowing the true θ, stochastically chooses rationales.",
                "Thus, observing the rationales helps us infer the true θ.",
                "We collect substring rationales for a sentiment classification task ( #TARGET_REF ) and use them to obtain significant accuracy improvements for each annotator .",
                "Our new generative approach exploits the rationales more effectively than our previous \"masking SVM\" approach.",
                "It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:A human annotator can provide hints to a machine learner by highlighting contextual \"rationales\" for each of his or her annotations (#REF). How can one exploit this side information to better learn the desired parameters θ? We present a generative model of how a given annotator, knowing the true θ, stochastically chooses rationales. Thus, observing the rationales helps us infer the true θ. We collect substring rationales for a sentiment classification task ( #TARGET_REF ) and use them to obtain significant accuracy improvements for each annotator . Our new generative approach exploits the rationales more effectively than our previous \"masking SVM\" approach. It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks.",
        "output": "nan:A human annotator can provide hints to a machine learner by highlighting contextual \"rationales\" for each of his or her annotations (#REF). How can one exploit this side information to better learn the desired parameters θ? We present a generative model of how a given annotator, knowing the true θ, stochastically chooses rationales. Thus, observing the rationales helps us infer the true θ. We collect substring rationales for a sentiment classification task ( #TARGET_REF<FUTURE/> ) and use them to obtain significant accuracy improvements for each annotator . Our new generative approach exploits the rationales more effectively than our previous \"masking SVM\" approach. It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks."
    },
    {
        "gold": {
            "text": [
                "where f (•) extracts a feature vector from a classified document, θ are the corresponding weights of those features, and Z θ (x) def = y u(x, y) is a normalizer.",
                "We use the same set of binary features as in previous work on this dataset ( #REF ; #TARGET_REF ; #REF ) .",
                "Specifically, let V = {v 1 , ..., v 17744 } be the set of word types with count ≥ 4 in the full 2000-document corpus.",
                "Define f h (x, y) to be y if v h appears at least once in x, and 0 otherwise.",
                "Thus θ ∈ R 17744 , and positive weights in θ favor class label y = +1 and equally discourage y = −1, while negative weights do the opposite.",
                "This standard unigram feature set is linguistically impoverished, but serves as a good starting point for studying rationales.",
                "Future work should consider more complex features and how they are signaled by rationales, as discussed in section 3.2."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:where f (•) extracts a feature vector from a classified document, θ are the corresponding weights of those features, and Z θ (x) def = y u(x, y) is a normalizer. We use the same set of binary features as in previous work on this dataset ( #REF ; #TARGET_REF ; #REF ) . Specifically, let V = {v 1 , ..., v 17744 } be the set of word types with count ≥ 4 in the full 2000-document corpus. Define f h (x, y) to be y if v h appears at least once in x, and 0 otherwise. Thus θ ∈ R 17744 , and positive weights in θ favor class label y = +1 and equally discourage y = −1, while negative weights do the opposite. This standard unigram feature set is linguistically impoverished, but serves as a good starting point for studying rationales. Future work should consider more complex features and how they are signaled by rationales, as discussed in section 3.2.",
        "output": "method:where f (•) extracts a feature vector from a classified document, θ are the corresponding weights of those features, and Z θ (x) def = y u(x, y) is a normalizer. We use the same set of binary features as in previous work on this dataset ( #REF ; #TARGET_REF<FUTURE/> ; #REF ) . Specifically, let V = {v 1 , ..., v 17744 } be the set of word types with count ≥ 4 in the full 2000-document corpus. Define f h (x, y) to be y if v h appears at least once in x, and 0 otherwise. Thus θ ∈ R 17744 , and positive weights in θ favor class label y = +1 and equally discourage y = −1, while negative weights do the opposite. This standard unigram feature set is linguistically impoverished, but serves as a good starting point for studying rationales. Future work should consider more complex features and how they are signaled by rationales, as discussed in section 3.2."
    },
    {
        "gold": {
            "text": [
                "We first evaluate D S P on disambiguating positives from pseudo-negatives, comparing to recently-proposed systems that also require no manually- compiled resources like WordNet.",
                "We convert Da- gan et al. (1999)�s similarity-smoothed probability to MI by replacing the empirical Pr n|v in Equa- tion (2) with the smoothed PrSIM from Equation (1).",
                "We also test an MI model inspired by #REF: MISIM n;v =log X Simn_;n Prv;n_ n__SIMS n",
                "We gather similar words using #TARGET_REFa ) , mining similar verbs from a comparable-sized parsed corpus , and collecting similar nouns from a broader 10 GB corpus of English text .4 We also use #REF 's approach to obtaining web-counts ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We first evaluate D S P on disambiguating positives from pseudo-negatives, comparing to recently-proposed systems that also require no manually- compiled resources like WordNet. We convert Da- gan et al. (1999)�s similarity-smoothed probability to MI by replacing the empirical Pr n|v in Equa- tion (2) with the smoothed PrSIM from Equation (1). We also test an MI model inspired by #REF: MISIM n;v =log X Simn_;n Prv;n_ n__SIMS n We gather similar words using #TARGET_REFa ) , mining similar verbs from a comparable-sized parsed corpus , and collecting similar nouns from a broader 10 GB corpus of English text .4 We also use #REF 's approach to obtaining web-counts .",
        "output": "experiments:We first evaluate D S P on disambiguating positives from pseudo-negatives, comparing to recently-proposed systems that also require no manually- compiled resources like WordNet. We convert Da- gan et al. (1999)�s similarity-smoothed probability to MI by replacing the empirical Pr n|v in Equa- tion (2) with the smoothed PrSIM from Equation (1). We also test an MI model inspired by #REF: MISIM n;v =log X Simn_;n Prv;n_ n__SIMS n We gather similar words using #TARGET_REF<FUTURE/>a ) , mining similar verbs from a comparable-sized parsed corpus , and collecting similar nouns from a broader 10 GB corpus of English text .4 We also use #REF 's approach to obtaining web-counts ."
    },
    {
        "gold": {
            "text": [
                "We also made use of the person-name/instance pairs automatically extracted by #TARGET_REF .2This data provides counts for pairs such as \"Edwin Moses , hurdler\" and \"William Farley , industrialist.",
                "We have features for all concepts and therefore learn their association with each verb."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:We also made use of the person-name/instance pairs automatically extracted by #TARGET_REF .2This data provides counts for pairs such as \"Edwin Moses , hurdler\" and \"William Farley , industrialist. We have features for all concepts and therefore learn their association with each verb.",
        "output": "method:We also made use of the person-name/instance pairs automatically extracted by #TARGET_REF<FUTURE/> .2This data provides counts for pairs such as \"Edwin Moses , hurdler\" and \"William Farley , industrialist. We have features for all concepts and therefore learn their association with each verb."
    },
    {
        "gold": {
            "text": [
                "Finally, we evaluate DSP on a common application of selectional preferences: choosing the correct antecedent for pronouns in text (#REF;#REF).",
                "We study the cases where a 9Recall that even the #TARGET_REF system , built on the world 's largest corpus , achieves only 34 % recall ( Table 1 ) ( with only 48 % of positives and 27 % of all pairs previously observed , but see Footnote 5 ) .",
                "pronoun is the direct object of a verb predicate, v.",
                "A pronoun's antecedent must obey v's selectional preferences.",
                "If we have a better model of SP, we should be able to better select pronoun antecedents."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:Finally, we evaluate DSP on a common application of selectional preferences: choosing the correct antecedent for pronouns in text (#REF;#REF). We study the cases where a 9Recall that even the #TARGET_REF system , built on the world 's largest corpus , achieves only 34 % recall ( Table 1 ) ( with only 48 % of positives and 27 % of all pairs previously observed , but see Footnote 5 ) . pronoun is the direct object of a verb predicate, v. A pronoun's antecedent must obey v's selectional preferences. If we have a better model of SP, we should be able to better select pronoun antecedents.",
        "output": "experiments:Finally, we evaluate DSP on a common application of selectional preferences: choosing the correct antecedent for pronouns in text (#REF;#REF). We study the cases where a 9Recall that even the #TARGET_REF<USE/> system , built on the world 's largest corpus , achieves only 34 % recall ( Table 1 ) ( with only 48 % of positives and 27 % of all pairs previously observed , but see Footnote 5 ) . pronoun is the direct object of a verb predicate, v. A pronoun's antecedent must obey v's selectional preferences. If we have a better model of SP, we should be able to better select pronoun antecedents."
    },
    {
        "gold": {
            "text": [
                "It is interesting to inspect the feature weights returned by our system.",
                "In particular, the weights on the verb co-occurrence features (Section 3.3.1)",
                "provide a high-quality, argument-specific similarityranking of other verb contexts.",
                "The DSP parameters for eat, for example, place high weight on features like Pr(n|braise), Pr(n|ration), and Pr(n|garnish).",
                "#TARGET_REFa ) 's similar word list for eat misses these but includes sleep ( ranked 6 ) and sit ( ranked 14 ) , because these have similar subjects to eat .",
                "Discriminative, context-specific training seems to yield a better set of similar predicates, e.g. the highest-ranked contexts for DSP cooc on the verb join, 3 lead 1.42, rejoin 1.39, form 1.34, belong to 1.31, found 1.31, quit 1.29, guide 1.19, induct 1.19, launch (subj) 1.18, work at 1.14 give a better SIMS(join) for Equation (1) than the top similarities returned by (#REFa Other features are also weighted intuitively."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "experiments:It is interesting to inspect the feature weights returned by our system. In particular, the weights on the verb co-occurrence features (Section 3.3.1) provide a high-quality, argument-specific similarityranking of other verb contexts. The DSP parameters for eat, for example, place high weight on features like Pr(n|braise), Pr(n|ration), and Pr(n|garnish). #TARGET_REFa ) 's similar word list for eat misses these but includes sleep ( ranked 6 ) and sit ( ranked 14 ) , because these have similar subjects to eat . Discriminative, context-specific training seems to yield a better set of similar predicates, e.g. the highest-ranked contexts for DSP cooc on the verb join, 3 lead 1.42, rejoin 1.39, form 1.34, belong to 1.31, found 1.31, quit 1.29, guide 1.19, induct 1.19, launch (subj) 1.18, work at 1.14 give a better SIMS(join) for Equation (1) than the top similarities returned by (#REFa Other features are also weighted intuitively.",
        "output": "experiments:It is interesting to inspect the feature weights returned by our system. In particular, the weights on the verb co-occurrence features (Section 3.3.1) provide a high-quality, argument-specific similarityranking of other verb contexts. The DSP parameters for eat, for example, place high weight on features like Pr(n|braise), Pr(n|ration), and Pr(n|garnish). #TARGET_REF<BACKGROUND/>a ) 's similar word list for eat misses these but includes sleep ( ranked 6 ) and sit ( ranked 14 ) , because these have similar subjects to eat . Discriminative, context-specific training seems to yield a better set of similar predicates, e.g. the highest-ranked contexts for DSP cooc on the verb join, 3 lead 1.42, rejoin 1.39, form 1.34, belong to 1.31, found 1.31, quit 1.29, guide 1.19, induct 1.19, launch (subj) 1.18, work at 1.14 give a better SIMS(join) for Equation (1) than the top similarities returned by (#REFa Other features are also weighted intuitively."
    },
    {
        "gold": {
            "text": [
                "5 Available from the LDC as LDC2006T13.",
                "This collection was generated from approximately 1 trillion tokens of online text.",
                "Unfortunately, tokens appearing less than 200 times have been mapped to the UNK symbol, and only N-grams appearing more than 40 times are included.",
                "Unlike results from search engines, however, experiments with this corpus are replicable.",
                "not be able to provide a score for each example.",
                "The similarity-smoothed examples will be undefined if SIMS(w) is empty.",
                "Also , the #TARGET_REF approach will be undefined if the pair is unobserved on the web .",
                "As a reasonable default for these cases, we assign them a negative decision."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:5 Available from the LDC as LDC2006T13. This collection was generated from approximately 1 trillion tokens of online text. Unfortunately, tokens appearing less than 200 times have been mapped to the UNK symbol, and only N-grams appearing more than 40 times are included. Unlike results from search engines, however, experiments with this corpus are replicable. not be able to provide a score for each example. The similarity-smoothed examples will be undefined if SIMS(w) is empty. Also , the #TARGET_REF approach will be undefined if the pair is unobserved on the web . As a reasonable default for these cases, we assign them a negative decision.",
        "output": "experiments:5 Available from the LDC as LDC2006T13. This collection was generated from approximately 1 trillion tokens of online text. Unfortunately, tokens appearing less than 200 times have been mapped to the UNK symbol, and only N-grams appearing more than 40 times are included. Unlike results from search engines, however, experiments with this corpus are replicable. not be able to provide a score for each example. The similarity-smoothed examples will be undefined if SIMS(w) is empty. Also , the #TARGET_REF<FUTURE/> approach will be undefined if the pair is unobserved on the web . As a reasonable default for these cases, we assign them a negative decision."
    },
    {
        "gold": {
            "text": [
                "Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #REF ; #TARGET_REF ) .",
                "This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed.",
                "The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones.",
                "We refer to this as Pairwise Disambiguation.",
                "Unlike this task, we classify each predicate-argument pair independently as plausible/implausible.",
                "We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1"
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #REF ; #TARGET_REF ) . This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed. The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones. We refer to this as Pairwise Disambiguation. Unlike this task, we classify each predicate-argument pair independently as plausible/implausible. We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1",
        "output": "method:Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #REF ; #TARGET_REF<USE/> ) . This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed. The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones. We refer to this as Pairwise Disambiguation. Unlike this task, we classify each predicate-argument pair independently as plausible/implausible. We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1"
    },
    {
        "gold": {
            "text": [
                "The advantage of tuning similarity to the application of interest has been shown previously by #TARGET_REF .",
                "They optimize a few metaparameters separately for the tasks of thesaurus generation and pseudodisambiguation.",
                "Our approach, on the other hand, discriminatively sets millions of individual similarity values.",
                "Like #REF, our similarity values are asymmetric."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:The advantage of tuning similarity to the application of interest has been shown previously by #TARGET_REF . They optimize a few metaparameters separately for the tasks of thesaurus generation and pseudodisambiguation. Our approach, on the other hand, discriminatively sets millions of individual similarity values. Like #REF, our similarity values are asymmetric.",
        "output": "method:The advantage of tuning similarity to the application of interest has been shown previously by #TARGET_REF<USE/> . They optimize a few metaparameters separately for the tasks of thesaurus generation and pseudodisambiguation. Our approach, on the other hand, discriminatively sets millions of individual similarity values. Like #REF, our similarity values are asymmetric."
    },
    {
        "gold": {
            "text": [
                ". That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n).",
                "For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\"",
                "In this representation, features for one predicate will be completely independent from those for every other predicate.",
                "Thus rather than a single training procedure, we can actually partition the examples by predicate, and train a For a fixed verb, MI is proportional to #REF's conditional probability scores for pseudodisambiguation of (v, n, n ′ ) triples: Pr(v|n) = Pr(v, n)/Pr(n), which was shown to be a better measure of association than co-occurrence frequency f (v, n).",
                "Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs.",
                "MI was also recently used for inference-rule SPs by #TARGET_REF ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:. That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n). For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\" In this representation, features for one predicate will be completely independent from those for every other predicate. Thus rather than a single training procedure, we can actually partition the examples by predicate, and train a For a fixed verb, MI is proportional to #REF's conditional probability scores for pseudodisambiguation of (v, n, n ′ ) triples: Pr(v|n) = Pr(v, n)/Pr(n), which was shown to be a better measure of association than co-occurrence frequency f (v, n). Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs. MI was also recently used for inference-rule SPs by #TARGET_REF .",
        "output": "method:. That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n). For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\" In this representation, features for one predicate will be completely independent from those for every other predicate. Thus rather than a single training procedure, we can actually partition the examples by predicate, and train a For a fixed verb, MI is proportional to #REF's conditional probability scores for pseudodisambiguation of (v, n, n ′ ) triples: Pr(v|n) = Pr(v, n)/Pr(n), which was shown to be a better measure of association than co-occurrence frequency f (v, n). Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs. MI was also recently used for inference-rule SPs by #TARGET_REF<BACKGROUND/> ."
    },
    {
        "gold": {
            "text": [
                "Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #TARGET_REF ; #REF ) .",
                "This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed.",
                "The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones.",
                "We refer to this as Pairwise Disambiguation.",
                "Unlike this task, we classify each predicate-argument pair independently as plausible/implausible.",
                "We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1"
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #TARGET_REF ; #REF ) . This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed. The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones. We refer to this as Pairwise Disambiguation. Unlike this task, we classify each predicate-argument pair independently as plausible/implausible. We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1",
        "output": "method:Our training examples are similar to the data created for pseudodisambiguation , the usual evaluation task for SP models ( #REF ; #TARGET_REF<USE/> ; #REF ) . This data consists of triples (v, n, n ′ ) where v, n is a predicateargument pair observed in the corpus and v, n ′ has not been observed. The models score correctly if they rank observed (and thus plausible) arguments above corresponding unobserved (and thus likely implausible) ones. We refer to this as Pairwise Disambiguation. Unlike this task, we classify each predicate-argument pair independently as plausible/implausible. We also use MI rather than frequency to define the positive pairs, ensuring that the positive pairs truly have a statistical association, and are not simply the result of parser error or noise. 1"
    },
    {
        "gold": {
            "text": [
                "Most approaches to SPs generalize from observed predicate-argument pairs to semantically similar ones by modeling the semantic class of the argument, following #REF.",
                "For example, we might have a class Mexican Food and learn that the entire class is suitable for eating.",
                "Usually , the classes are from WordNet ( #REF ) , although they can also be inferred from clustering ( #TARGET_REF ) .",
                "#REF compare a number of WordNet-based approaches, including #REF, #REF, and #REF, and found that the more sophisticated class-based approaches do not always outperform simple frequency-based models."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Most approaches to SPs generalize from observed predicate-argument pairs to semantically similar ones by modeling the semantic class of the argument, following #REF. For example, we might have a class Mexican Food and learn that the entire class is suitable for eating. Usually , the classes are from WordNet ( #REF ) , although they can also be inferred from clustering ( #TARGET_REF ) . #REF compare a number of WordNet-based approaches, including #REF, #REF, and #REF, and found that the more sophisticated class-based approaches do not always outperform simple frequency-based models.",
        "output": "related work:Most approaches to SPs generalize from observed predicate-argument pairs to semantically similar ones by modeling the semantic class of the argument, following #REF. For example, we might have a class Mexican Food and learn that the entire class is suitable for eating. Usually , the classes are from WordNet ( #REF ) , although they can also be inferred from clustering ( #TARGET_REF<BACKGROUND/> ) . #REF compare a number of WordNet-based approaches, including #REF, #REF, and #REF, and found that the more sophisticated class-based approaches do not always outperform simple frequency-based models."
    },
    {
        "gold": {
            "text": [
                "Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #REF ; #TARGET_REF ) .",
                "Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness.",
                "We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)).",
                "We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise.",
                "Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature.",
                "When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #REF ; #TARGET_REF ) . Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness. We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)). We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise. Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature. When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns.",
        "output": "experiments:Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #REF ; #TARGET_REF<USE/> ) . Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness. We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)). We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise. Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature. When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns."
    },
    {
        "gold": {
            "text": [
                "Selectional Preferences have also been a recent focus of researchers investigating the learning of paraphrases and inference rules ( #TARGET_REF ; #REF ) .",
                "Inferences such as \"[X wins Y] ⇒ [X plays Y]\" are only valid for certain argu-ments X and Y.",
                "We follow #REF in using automatically-extracted semantic classes to help characterize plausible arguments."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Selectional Preferences have also been a recent focus of researchers investigating the learning of paraphrases and inference rules ( #TARGET_REF ; #REF ) . Inferences such as \"[X wins Y] ⇒ [X plays Y]\" are only valid for certain argu-ments X and Y. We follow #REF in using automatically-extracted semantic classes to help characterize plausible arguments.",
        "output": "related work:Selectional Preferences have also been a recent focus of researchers investigating the learning of paraphrases and inference rules ( #TARGET_REF<BACKGROUND/> ; #REF ) . Inferences such as \"[X wins Y] ⇒ [X plays Y]\" are only valid for certain argu-ments X and Y. We follow #REF in using automatically-extracted semantic classes to help characterize plausible arguments."
    },
    {
        "gold": {
            "text": [
                "where Sim(v ′ , v) returns a real-valued similarity between two verbs v ′ and v (normalized over all pair similarities in the sum).",
                "In contrast, #REF generalizes by substituting similar arguments, while #REF use the cross-product of similar pairs.",
                "One key issue is how to define the set of similar words, SIMS(w).",
                "#REF compared a number of techniques for creating similar-word sets and found that both the Jaccard coefficient and #TARGET_REFa ) 's information-theoretic metric work best .",
                "Similarity-smoothed models are simple to compute, potentially adaptable to new domains, and require no manually-compiled resources such as WordNet."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:where Sim(v ′ , v) returns a real-valued similarity between two verbs v ′ and v (normalized over all pair similarities in the sum). In contrast, #REF generalizes by substituting similar arguments, while #REF use the cross-product of similar pairs. One key issue is how to define the set of similar words, SIMS(w). #REF compared a number of techniques for creating similar-word sets and found that both the Jaccard coefficient and #TARGET_REFa ) 's information-theoretic metric work best . Similarity-smoothed models are simple to compute, potentially adaptable to new domains, and require no manually-compiled resources such as WordNet.",
        "output": "related work:where Sim(v ′ , v) returns a real-valued similarity between two verbs v ′ and v (normalized over all pair similarities in the sum). In contrast, #REF generalizes by substituting similar arguments, while #REF use the cross-product of similar pairs. One key issue is how to define the set of similar words, SIMS(w). #REF compared a number of techniques for creating similar-word sets and found that both the Jaccard coefficient and #TARGET_REF<BACKGROUND/>a ) 's information-theoretic metric work best . Similarity-smoothed models are simple to compute, potentially adaptable to new domains, and require no manually-compiled resources such as WordNet."
    },
    {
        "gold": {
            "text": [
                "We parsed the 3 GB AQUAINT corpus ( #REF ) using Minipar ( #TARGET_REFb ) , and collected verb-object and verb-subject frequencies , building an empirical MI model from this data .",
                "Verbs and nouns were converted to their (possibly multi-token) root, and string case was preserved.",
                "Passive subjects (the car was bought) were converted to objects (bought car).",
                "We set the MI-threshold, τ , to be 0, and the negative-to-positive ratio, K, to be 2."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We parsed the 3 GB AQUAINT corpus ( #REF ) using Minipar ( #TARGET_REFb ) , and collected verb-object and verb-subject frequencies , building an empirical MI model from this data . Verbs and nouns were converted to their (possibly multi-token) root, and string case was preserved. Passive subjects (the car was bought) were converted to objects (bought car). We set the MI-threshold, τ , to be 0, and the negative-to-positive ratio, K, to be 2.",
        "output": "experiments:We parsed the 3 GB AQUAINT corpus ( #REF ) using Minipar ( #TARGET_REF<FUTURE/>b ) , and collected verb-object and verb-subject frequencies , building an empirical MI model from this data . Verbs and nouns were converted to their (possibly multi-token) root, and string case was preserved. Passive subjects (the car was bought) were converted to objects (bought car). We set the MI-threshold, τ , to be 0, and the negative-to-positive ratio, K, to be 2."
    },
    {
        "gold": {
            "text": [
                "Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #TARGET_REF ; #REF ) .",
                "Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness.",
                "We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)).",
                "We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise.",
                "Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature.",
                "When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #TARGET_REF ; #REF ) . Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness. We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)). We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise. Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature. When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns.",
        "output": "experiments:Numerous previous pseudodisambiguation evaluations only include arguments that occur between 30 and 3000 times ( #REF ; #TARGET_REF<USE/> ; #REF ) . Presumably the lower bound is to help ensure the negative argument is unobserved because it is unsuitable, not because of data sparseness. We wish to use our model on arguments of any frequency, including those that never occurred in the training corpus (and therefore have empty cooccurrence features (Section 3.3.1)). We proceed as follows: first, we exclude pairs whenever the noun occurs less than 3 times in our corpus, removing many misspellings and other noun noise. Next, we omit verb co-occurrence features for nouns that occur less than 10 times, and instead fire a low-count feature. When we move to a new corpus, previouslyunseen nouns are treated like these low-count training nouns."
    },
    {
        "gold": {
            "text": [
                "To learn a discriminative model of selectional preference, we create positive and negative training examples automatically from raw text.",
                "To create the positives, we automatically parse a large corpus, and then extract the predicate-argument pairs that have a statistical association in this data.",
                "We measure this association using pointwise Mutual Information ( MI ) ( #TARGET_REF ) .",
                "The MI between a verb predicate, v, and its object argument, n, is:"
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:To learn a discriminative model of selectional preference, we create positive and negative training examples automatically from raw text. To create the positives, we automatically parse a large corpus, and then extract the predicate-argument pairs that have a statistical association in this data. We measure this association using pointwise Mutual Information ( MI ) ( #TARGET_REF ) . The MI between a verb predicate, v, and its object argument, n, is:",
        "output": "method:To learn a discriminative model of selectional preference, we create positive and negative training examples automatically from raw text. To create the positives, we automatically parse a large corpus, and then extract the predicate-argument pairs that have a statistical association in this data. We measure this association using pointwise Mutual Information ( MI ) ( #TARGET_REF<FUTURE/> ) . The MI between a verb predicate, v, and its object argument, n, is:"
    },
    {
        "gold": {
            "text": [
                ". That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n).",
                "For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\"",
                "In this representation, features for one predicate will be completely independent from those for every other predicate.",
                "Thus rather than a single training procedure , we can actually partition the examples by predicate , and train a 1For a fixed verb , MI is proportional to #TARGET_REF 's conditional probability scores for pseudodisambiguation of ( v , n , n â² ) triples : Pr ( v | n ) = Pr ( v , n ) / Pr ( n ) , which was shown to be a better measure of association than co-occurrence frequency f ( v , n ) .",
                "Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs.",
                "MI was also recently used for inference-rule SPs by #REF."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "method:. That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n). For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\" In this representation, features for one predicate will be completely independent from those for every other predicate. Thus rather than a single training procedure , we can actually partition the examples by predicate , and train a 1For a fixed verb , MI is proportional to #TARGET_REF 's conditional probability scores for pseudodisambiguation of ( v , n , n â² ) triples : Pr ( v | n ) = Pr ( v , n ) / Pr ( n ) , which was shown to be a better measure of association than co-occurrence frequency f ( v , n ) . Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs. MI was also recently used for inference-rule SPs by #REF.",
        "output": "method:. That is, every feature is an intersection of the occurrence of a particular predicate,v, and some feature of the argument f (n). For example, a feature for a verb-object pair might be, \"the verb is eat and the object is lower-case.\" In this representation, features for one predicate will be completely independent from those for every other predicate. Thus rather than a single training procedure , we can actually partition the examples by predicate , and train a 1For a fixed verb , MI is proportional to #TARGET_REF<EXTENSION/> 's conditional probability scores for pseudodisambiguation of ( v , n , n â² ) triples : Pr ( v | n ) = Pr ( v , n ) / Pr ( n ) , which was shown to be a better measure of association than co-occurrence frequency f ( v , n ) . Normalizing by Pr(v) (yielding MI) allows us to use a constant threshold across all verbs. MI was also recently used for inference-rule SPs by #REF."
    },
    {
        "gold": {
            "text": [
                "HOLMES is given the following set of six domainindependent rules , which are similar to the upward monotone rules introduced by ( #TARGET_REF ) ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:HOLMES is given the following set of six domainindependent rules , which are similar to the upward monotone rules introduced by ( #TARGET_REF ) .",
        "output": "introduction:HOLMES is given the following set of six domainindependent rules , which are similar to the upward monotone rules introduced by ( #TARGET_REF<USE/> ) ."
    },
    {
        "gold": {
            "text": [
                "Textual Entailment systems are given two textual fragments, text T and hypothesis H, and attempt to decide if the meaning of H can be inferred from the meaning of T (#REF).",
                "While many approaches have addressed this problem , our work is most closely related to that of ( #REF ; #TARGET_REF ; #REF ; #REF ) , which convert the inputs into logical forms and then attempt to ` prove ' H from T plus a set of axioms .",
                "For instance, (#REF) represents T , H , and a set of rewrite rules in a description logic framework, and determines entailment by solving an integer linear program derived from that representation."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:Textual Entailment systems are given two textual fragments, text T and hypothesis H, and attempt to decide if the meaning of H can be inferred from the meaning of T (#REF). While many approaches have addressed this problem , our work is most closely related to that of ( #REF ; #TARGET_REF ; #REF ; #REF ) , which convert the inputs into logical forms and then attempt to ` prove ' H from T plus a set of axioms . For instance, (#REF) represents T , H , and a set of rewrite rules in a description logic framework, and determines entailment by solving an integer linear program derived from that representation.",
        "output": "related work:Textual Entailment systems are given two textual fragments, text T and hypothesis H, and attempt to decide if the meaning of H can be inferred from the meaning of T (#REF). While many approaches have addressed this problem , our work is most closely related to that of ( #REF ; #TARGET_REF<USE/> ; #REF ; #REF ) , which convert the inputs into logical forms and then attempt to ` prove ' H from T plus a set of axioms . For instance, (#REF) represents T , H , and a set of rewrite rules in a description logic framework, and determines entailment by solving an integer linear program derived from that representation."
    },
    {
        "gold": {
            "text": [
                "The studies presented by #TARGET_REF and #REF differed in the number of states that they used .",
                "evaluated against the reduced tag set of 17 tags developed by #REF, while #REF evaluated against the full Penn Treebank tag set.",
                "We ran all our estimators in both conditions here (thanks to Noah Smith for supplying us with his tag set)."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:The studies presented by #TARGET_REF and #REF differed in the number of states that they used . evaluated against the reduced tag set of 17 tags developed by #REF, while #REF evaluated against the full Penn Treebank tag set. We ran all our estimators in both conditions here (thanks to Noah Smith for supplying us with his tag set).",
        "output": "nan:The studies presented by #TARGET_REF<USE/> and #REF differed in the number of states that they used . evaluated against the reduced tag set of 17 tags developed by #REF, while #REF evaluated against the full Penn Treebank tag set. We ran all our estimators in both conditions here (thanks to Noah Smith for supplying us with his tag set)."
    },
    {
        "gold": {
            "text": [
                "As might be expected, our evaluation measures disagree somewhat, but the following broad tendancies seem clear.",
                "On small data sets all of the Bayesian estimators strongly outperform EM ( and , to a lesser extent , VB ) with respect to all of our evaluation measures , confirming the results reported in #TARGET_REF .",
                "This is perhaps not too surprising, as the Bayesian prior plays a comparatively stronger role with a smaller training corpus (which makes the likelihood term smaller) and the approximation used by Variational Bayes is likely to be less accurate on smaller data sets."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:As might be expected, our evaluation measures disagree somewhat, but the following broad tendancies seem clear. On small data sets all of the Bayesian estimators strongly outperform EM ( and , to a lesser extent , VB ) with respect to all of our evaluation measures , confirming the results reported in #TARGET_REF . This is perhaps not too surprising, as the Bayesian prior plays a comparatively stronger role with a smaller training corpus (which makes the likelihood term smaller) and the approximation used by Variational Bayes is likely to be less accurate on smaller data sets.",
        "output": "conclusion:As might be expected, our evaluation measures disagree somewhat, but the following broad tendancies seem clear. On small data sets all of the Bayesian estimators strongly outperform EM ( and , to a lesser extent , VB ) with respect to all of our evaluation measures , confirming the results reported in #TARGET_REF<USE/> . This is perhaps not too surprising, as the Bayesian prior plays a comparatively stronger role with a smaller training corpus (which makes the likelihood term smaller) and the approximation used by Variational Bayes is likely to be less accurate on smaller data sets."
    },
    {
        "gold": {
            "text": [
                "The resulting training procedure is analogous to the one presented in ( #REF ) and ( #TARGET_REF ) ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:The resulting training procedure is analogous to the one presented in ( #REF ) and ( #TARGET_REF ) .",
        "output": "method:The resulting training procedure is analogous to the one presented in ( #REF ) and ( #TARGET_REF<USE/> ) ."
    },
    {
        "gold": {
            "text": [
                "This tree kernel was slightly generalized by #REF to compute similarity between two dependency trees.",
                "In addition to the words, this kernel also incorporates word classes into the kernel.",
                "The kernel is based on counting matching subsequences of children of matching nodes.",
                "But as was also noted in (#REFa), this kernel is opaque i.e. it is not obvious what the implicit features are and the authors do not describe it either.",
                "In contrast, our dependency-based word subsequence kernel, which also computes similarity between two dependency trees, is very transparent with the implicit features being simply the dependency paths.",
                "Their kernel is also very time consuming and in their more general sparse setting it requires O ( mn3 ) time and O ( mn2 ) space , where m and n are the number of nodes of the two trees ( m > = n ) ( #TARGET_REF ) .",
                "Bunescu and Mooney (2005a) give a shortest path dependency kernel for relation extraction.",
                "Their kernel, however, does not find similarity between two sentences but between the shortest dependency paths connecting the two entities of interests in the sentences.",
                "This kernel uses general dependency graphs but if the graph is a tree then the shortest path is the only path between the entities.",
                "Their kernel also uses word classes in addition to the words themselves."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "related work:This tree kernel was slightly generalized by #REF to compute similarity between two dependency trees. In addition to the words, this kernel also incorporates word classes into the kernel. The kernel is based on counting matching subsequences of children of matching nodes. But as was also noted in (#REFa), this kernel is opaque i.e. it is not obvious what the implicit features are and the authors do not describe it either. In contrast, our dependency-based word subsequence kernel, which also computes similarity between two dependency trees, is very transparent with the implicit features being simply the dependency paths. Their kernel is also very time consuming and in their more general sparse setting it requires O ( mn3 ) time and O ( mn2 ) space , where m and n are the number of nodes of the two trees ( m > = n ) ( #TARGET_REF ) . Bunescu and Mooney (2005a) give a shortest path dependency kernel for relation extraction. Their kernel, however, does not find similarity between two sentences but between the shortest dependency paths connecting the two entities of interests in the sentences. This kernel uses general dependency graphs but if the graph is a tree then the shortest path is the only path between the entities. Their kernel also uses word classes in addition to the words themselves.",
        "output": "related work:This tree kernel was slightly generalized by #REF to compute similarity between two dependency trees. In addition to the words, this kernel also incorporates word classes into the kernel. The kernel is based on counting matching subsequences of children of matching nodes. But as was also noted in (#REFa), this kernel is opaque i.e. it is not obvious what the implicit features are and the authors do not describe it either. In contrast, our dependency-based word subsequence kernel, which also computes similarity between two dependency trees, is very transparent with the implicit features being simply the dependency paths. Their kernel is also very time consuming and in their more general sparse setting it requires O ( mn3 ) time and O ( mn2 ) space , where m and n are the number of nodes of the two trees ( m > = n ) ( #TARGET_REF<MOTIVATION/> ) . Bunescu and Mooney (2005a) give a shortest path dependency kernel for relation extraction. Their kernel, however, does not find similarity between two sentences but between the shortest dependency paths connecting the two entities of interests in the sentences. This kernel uses general dependency graphs but if the graph is a tree then the shortest path is the only path between the entities. Their kernel also uses word classes in addition to the words themselves."
    },
    {
        "gold": {
            "text": [
                "There are various strands of future research.",
                "Firstly, we plan to explore our estimator on other language pairs in order to obtain more evidence on its behavior.",
                "Secondly , as ( #TARGET_REF ) show , marginalizing out the different segmentations during decoding leads to improved performance .",
                "We plan to build our own decoder (based on ITG) where different ideas can be tested including tractable ways for achieving a marginalization effect.",
                "Apart from a new decoder, it will be worthwhile adapting the prior probability in our model to allow for consistent estimation.",
                "Finally, it would be interesting to study properties of the penalized Deleted Estimation used in this paper."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:There are various strands of future research. Firstly, we plan to explore our estimator on other language pairs in order to obtain more evidence on its behavior. Secondly , as ( #TARGET_REF ) show , marginalizing out the different segmentations during decoding leads to improved performance . We plan to build our own decoder (based on ITG) where different ideas can be tested including tractable ways for achieving a marginalization effect. Apart from a new decoder, it will be worthwhile adapting the prior probability in our model to allow for consistent estimation. Finally, it would be interesting to study properties of the penalized Deleted Estimation used in this paper.",
        "output": "conclusion:There are various strands of future research. Firstly, we plan to explore our estimator on other language pairs in order to obtain more evidence on its behavior. Secondly , as ( #TARGET_REF<MOTIVATION/> ) show , marginalizing out the different segmentations during decoding leads to improved performance . We plan to build our own decoder (based on ITG) where different ideas can be tested including tractable ways for achieving a marginalization effect. Apart from a new decoder, it will be worthwhile adapting the prior probability in our model to allow for consistent estimation. Finally, it would be interesting to study properties of the penalized Deleted Estimation used in this paper."
    },
    {
        "gold": {
            "text": [
                "A good study comparing document categorization algorithms can be found in (#REF).",
                "More recently , ( #REF ) has performed a good survey of document categorization ; recent works can also be found in ( #REF ) , ( #TARGET_REF ) , and ( #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:A good study comparing document categorization algorithms can be found in (#REF). More recently , ( #REF ) has performed a good survey of document categorization ; recent works can also be found in ( #REF ) , ( #TARGET_REF ) , and ( #REF ) .",
        "output": "related work:A good study comparing document categorization algorithms can be found in (#REF). More recently , ( #REF ) has performed a good survey of document categorization ; recent works can also be found in ( #REF ) , ( #TARGET_REF<BACKGROUND/> ) , and ( #REF ) ."
    },
    {
        "gold": {
            "text": [
                "The most similar efforts to ours, mainly (#REF), conclude that segmentation variables in the generative translation model lead to overfitting while attaining higher likelihood of the training data than the heuristic estimator.",
                "Based on this advise ( Moore and #TARGET_REF ) exclude the latent segmentation variables and opt for a heuristic training procedure .",
                "In this work we also start out from a generative model with latent segmentation variables.",
                "However, we find out that concentrating the learning effort on smoothing is crucial for good performance.",
                "For this, we devise ITG-based priors over segmentations and employ a penalized version of Deleted Estimation working with EM at its core.",
                "The fact that our results (at least) match the heuristic estimates on a reasonably sized data set (947k parallel sentence pairs) is rather encouraging."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:The most similar efforts to ours, mainly (#REF), conclude that segmentation variables in the generative translation model lead to overfitting while attaining higher likelihood of the training data than the heuristic estimator. Based on this advise ( Moore and #TARGET_REF ) exclude the latent segmentation variables and opt for a heuristic training procedure . In this work we also start out from a generative model with latent segmentation variables. However, we find out that concentrating the learning effort on smoothing is crucial for good performance. For this, we devise ITG-based priors over segmentations and employ a penalized version of Deleted Estimation working with EM at its core. The fact that our results (at least) match the heuristic estimates on a reasonably sized data set (947k parallel sentence pairs) is rather encouraging.",
        "output": "conclusion:The most similar efforts to ours, mainly (#REF), conclude that segmentation variables in the generative translation model lead to overfitting while attaining higher likelihood of the training data than the heuristic estimator. Based on this advise ( Moore and #TARGET_REF<USE/> ) exclude the latent segmentation variables and opt for a heuristic training procedure . In this work we also start out from a generative model with latent segmentation variables. However, we find out that concentrating the learning effort on smoothing is crucial for good performance. For this, we devise ITG-based priors over segmentations and employ a penalized version of Deleted Estimation working with EM at its core. The fact that our results (at least) match the heuristic estimates on a reasonably sized data set (947k parallel sentence pairs) is rather encouraging."
    },
    {
        "gold": {
            "text": [
                "In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks.",
                "We would like to use features that look at wide context on the input side, which is inexpensive (#REF).",
                "Latent variables we wish to consider are an increased number of word classes ; more flexible regions -- see #TARGET_REF on learning a state transition diagram for acoustic regions in phone recognition -- and phonological features and syllable boundaries .",
                "Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF).",
                "Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows.",
                "Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks. We would like to use features that look at wide context on the input side, which is inexpensive (#REF). Latent variables we wish to consider are an increased number of word classes ; more flexible regions -- see #TARGET_REF on learning a state transition diagram for acoustic regions in phone recognition -- and phonological features and syllable boundaries . Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF). Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows. Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods.",
        "output": "conclusion:In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks. We would like to use features that look at wide context on the input side, which is inexpensive (#REF). Latent variables we wish to consider are an increased number of word classes ; more flexible regions -- see #TARGET_REF<BACKGROUND/> on learning a state transition diagram for acoustic regions in phone recognition -- and phonological features and syllable boundaries . Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF). Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows. Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods."
    },
    {
        "gold": {
            "text": [
                "In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks.",
                "We would like to use features that look at wide context on the input side , which is inexpensive ( #TARGET_REF ) .",
                "Latent variables we wish to consider are an increased number of word classes; more flexible regions-see #REF on learning a state transition diagram for acoustic regions in phone recognition-and phonological features and syllable boundaries.",
                "Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF).",
                "Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows.",
                "Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks. We would like to use features that look at wide context on the input side , which is inexpensive ( #TARGET_REF ) . Latent variables we wish to consider are an increased number of word classes; more flexible regions-see #REF on learning a state transition diagram for acoustic regions in phone recognition-and phonological features and syllable boundaries. Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF). Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows. Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods.",
        "output": "conclusion:In future work, we would like to identify a set of features, latent variables, and training methods that port well across languages and string-transduction tasks. We would like to use features that look at wide context on the input side , which is inexpensive ( #TARGET_REF<MOTIVATION/> ) . Latent variables we wish to consider are an increased number of word classes; more flexible regions-see #REF on learning a state transition diagram for acoustic regions in phone recognition-and phonological features and syllable boundaries. Indeed, our local log-linear features over several aligned latent strings closely resemble the soft constraints used by phonologists (#REF). Finally, rather than define a fixed set of feature templates as in Fig. 2, we would like to refine empirically useful features during training, resulting in language-specific backoff patterns and adaptively sized n-gram windows. Many of these enhancements will increase the computational burden, and we are interested in strategies to mitigate this, including approximation methods."
    },
    {
        "gold": {
            "text": [
                "Our best performing method showed a significant improvement over the supervised model and over methods previously proposed in the literature.",
                "On the full training set the best method performed 2.33% better than the fully supervised model, which is a 10.91% error reduction.",
                "Using only 5% of the training data the best semi-supervised model still achieved 60.29%, compared to 40.49% by the supervised model, which is an error reduction of 33.27%.",
                "These results demonstrate that the latent words learned by the LWLM help for this complex information extraction task.",
                "Furthermore we have shown that the latent words are simple to incorporate in an existing classifier by adding additional features.",
                "We would like to perform experiments on employing this model in other information extraction tasks, such as Word Sense Disambiguation or Named Entity Recognition.",
                "The current model uses the context in a very straightforward way, i.e. the two words left and right of the current word, but in the future we would like to explore more advanced methods to improve the similarity estimates.",
                "#TARGET_REF for example discusses a method where a syntactic parse of the text is performed and the context of a word is modeled using dependency triples ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:Our best performing method showed a significant improvement over the supervised model and over methods previously proposed in the literature. On the full training set the best method performed 2.33% better than the fully supervised model, which is a 10.91% error reduction. Using only 5% of the training data the best semi-supervised model still achieved 60.29%, compared to 40.49% by the supervised model, which is an error reduction of 33.27%. These results demonstrate that the latent words learned by the LWLM help for this complex information extraction task. Furthermore we have shown that the latent words are simple to incorporate in an existing classifier by adding additional features. We would like to perform experiments on employing this model in other information extraction tasks, such as Word Sense Disambiguation or Named Entity Recognition. The current model uses the context in a very straightforward way, i.e. the two words left and right of the current word, but in the future we would like to explore more advanced methods to improve the similarity estimates. #TARGET_REF for example discusses a method where a syntactic parse of the text is performed and the context of a word is modeled using dependency triples .",
        "output": "conclusion:Our best performing method showed a significant improvement over the supervised model and over methods previously proposed in the literature. On the full training set the best method performed 2.33% better than the fully supervised model, which is a 10.91% error reduction. Using only 5% of the training data the best semi-supervised model still achieved 60.29%, compared to 40.49% by the supervised model, which is an error reduction of 33.27%. These results demonstrate that the latent words learned by the LWLM help for this complex information extraction task. Furthermore we have shown that the latent words are simple to incorporate in an existing classifier by adding additional features. We would like to perform experiments on employing this model in other information extraction tasks, such as Word Sense Disambiguation or Named Entity Recognition. The current model uses the context in a very straightforward way, i.e. the two words left and right of the current word, but in the future we would like to explore more advanced methods to improve the similarity estimates. #TARGET_REF<BACKGROUND/> for example discusses a method where a syntactic parse of the text is performed and the context of a word is modeled using dependency triples ."
    },
    {
        "gold": {
            "text": [
                "In this paper , we extend two classes of model adaptation methods ( i.e. , model interpolation and error-driven learning ) , which have been well studied in statistical language modeling for speech and natural language applications ( e.g. , #TARGET_REF ; #REF ; #REF ) , to ranking models for Web search applications ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:In this paper , we extend two classes of model adaptation methods ( i.e. , model interpolation and error-driven learning ) , which have been well studied in statistical language modeling for speech and natural language applications ( e.g. , #TARGET_REF ; #REF ; #REF ) , to ranking models for Web search applications .",
        "output": "conclusion:In this paper , we extend two classes of model adaptation methods ( i.e. , model interpolation and error-driven learning ) , which have been well studied in statistical language modeling for speech and natural language applications ( e.g. , #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) , to ranking models for Web search applications ."
    },
    {
        "gold": {
            "text": [
                "As already mentioned in the literature , see for example ( #TARGET_REF ) , knowledge about implicit predicates could be potentially useful for a variety of NLP tasks such as language generation , information extraction , question answering or machine translation .",
                "Many applications of semantic relations in NLP are connected to paraphrasing or query expansion, see for example (#REF).",
                "Suppose that a search engine or a question answering system receives the query schnelle Bombe 'quick bomb'.",
                "Probably, in this case the user is interested in finding information about bombs that explode quickly rather then about bombs in general.",
                "Knowledge about predicates associated with the noun Bombe 'bomb' could be used for predicting a set of probable implicit predicates.",
                "For generation of the semantically and syntactically correct paraphrases it is sometimes not enough to guess the most probable argument-predicate pairs.",
                "Information about types of an argument-predicate relation could be helpful, i.e. which semantic and syntactic position does the argument fill in the argument structure of the predicate.",
                "For example, compare eine Bombe explodiert schnell 'a bomb explodes quickly' for schnelle Bombe with ein Buch schnell lesen/schreiben 'to read/write a book quickly' for schnelles Buch 'quick book'."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:As already mentioned in the literature , see for example ( #TARGET_REF ) , knowledge about implicit predicates could be potentially useful for a variety of NLP tasks such as language generation , information extraction , question answering or machine translation . Many applications of semantic relations in NLP are connected to paraphrasing or query expansion, see for example (#REF). Suppose that a search engine or a question answering system receives the query schnelle Bombe 'quick bomb'. Probably, in this case the user is interested in finding information about bombs that explode quickly rather then about bombs in general. Knowledge about predicates associated with the noun Bombe 'bomb' could be used for predicting a set of probable implicit predicates. For generation of the semantically and syntactically correct paraphrases it is sometimes not enough to guess the most probable argument-predicate pairs. Information about types of an argument-predicate relation could be helpful, i.e. which semantic and syntactic position does the argument fill in the argument structure of the predicate. For example, compare eine Bombe explodiert schnell 'a bomb explodes quickly' for schnelle Bombe with ein Buch schnell lesen/schreiben 'to read/write a book quickly' for schnelles Buch 'quick book'.",
        "output": "conclusion:As already mentioned in the literature , see for example ( #TARGET_REF<BACKGROUND/> ) , knowledge about implicit predicates could be potentially useful for a variety of NLP tasks such as language generation , information extraction , question answering or machine translation . Many applications of semantic relations in NLP are connected to paraphrasing or query expansion, see for example (#REF). Suppose that a search engine or a question answering system receives the query schnelle Bombe 'quick bomb'. Probably, in this case the user is interested in finding information about bombs that explode quickly rather then about bombs in general. Knowledge about predicates associated with the noun Bombe 'bomb' could be used for predicting a set of probable implicit predicates. For generation of the semantically and syntactically correct paraphrases it is sometimes not enough to guess the most probable argument-predicate pairs. Information about types of an argument-predicate relation could be helpful, i.e. which semantic and syntactic position does the argument fill in the argument structure of the predicate. For example, compare eine Bombe explodiert schnell 'a bomb explodes quickly' for schnelle Bombe with ein Buch schnell lesen/schreiben 'to read/write a book quickly' for schnelles Buch 'quick book'."
    },
    {
        "gold": {
            "text": [
                "Two primary factors appear to be determining the efficacy of our self-training approach.",
                "First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars.",
                "Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model.",
                "Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set, rivaling discriminative reranking approaches (#REF) and products of latent variable grammars (#REF), despite being a single generative PCFG.",
                "Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set ( #TARGET_REF ) .",
                "In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models.",
                "One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models.",
                "It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more.",
                "A simple but computationally expensive way to do this would be to parse the data with an SM7 product model."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set, rivaling discriminative reranking approaches (#REF) and products of latent variable grammars (#REF), despite being a single generative PCFG. Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set ( #TARGET_REF ) . In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more. A simple but computationally expensive way to do this would be to parse the data with an SM7 product model.",
        "output": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set, rivaling discriminative reranking approaches (#REF) and products of latent variable grammars (#REF), despite being a single generative PCFG. Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set ( #TARGET_REF<USE/> ) . In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more. A simple but computationally expensive way to do this would be to parse the data with an SM7 product model."
    },
    {
        "gold": {
            "text": [
                "Two primary factors appear to be determining the efficacy of our self-training approach.",
                "First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars.",
                "Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model.",
                "Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #TARGET_REF ) and products of latent variable grammars ( #REF ) , despite being a single generative PCFG .",
                "Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF).",
                "In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models.",
                "One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models.",
                "It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #TARGET_REF ) and products of latent variable grammars ( #REF ) , despite being a single generative PCFG . Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF). In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more.",
        "output": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #TARGET_REF<USE/> ) and products of latent variable grammars ( #REF ) , despite being a single generative PCFG . Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF). In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more."
    },
    {
        "gold": {
            "text": [
                "Two primary factors appear to be determining the efficacy of our self-training approach.",
                "First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars.",
                "Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model.",
                "Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #REF ) and products of latent variable grammars ( #TARGET_REF ) , despite being a single generative PCFG .",
                "Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF).",
                "In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models.",
                "One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models.",
                "It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more.",
                "A simple but computationally expensive way to do this would be to parse the data with an SM7 product model."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #REF ) and products of latent variable grammars ( #TARGET_REF ) , despite being a single generative PCFG . Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF). In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more. A simple but computationally expensive way to do this would be to parse the data with an SM7 product model.",
        "output": "conclusion:Two primary factors appear to be determining the efficacy of our self-training approach. First, the accuracy of the model used for parsing the unlabeled data is important for the accuracy of the resulting single self-trained grammars. Second, the diversity of the individual grammars controls the gains that can be obtained by combining multiple grammars into a product model. Our most accurate single grammar achieves an F score of 91.6 on the WSJ test set , rivaling discriminative reranking approaches ( #REF ) and products of latent variable grammars ( #TARGET_REF<USE/> ) , despite being a single generative PCFG . Our most accurate product model achieves an F score of 92.5 without the use of discriminative reranking and comes close to the best known numbers on this test set (#REF). In future work, we plan to investigate additional methods for increasing the diversity of our selftrained models. One possibility would be to utilize more unlabeled data or to identify additional ways to bias the models. It would also be interesting to determine whether further increasing the accuracy of the model used for automatically labeling the unlabeled data can enhance performance even more. A simple but computationally expensive way to do this would be to parse the data with an SM7 product model."
    },
    {
        "gold": {
            "text": [
                "Another possibly critical feature is the 'mention of names'.",
                "In multi-party discussion people usually mention each other 's name for the purpose of disentanglement ( #TARGET_REF ) .",
                "In our corpus we found 175 instances where a participant mentions other participant's name.",
                "In addition to these, 'Subject of the email', 'topic-shift cue words' can also be beneficial for a model.",
                "As a next step for this research, we will investigate how to exploit these features in our methods.",
                "We are also interested in the near future to transfer our approach to other similar domains by hierarchical Bayesian multi-task learning and other domain adaptation methods.",
                "We plan to work on both synchronous (e.g., chats, meetings) and asynchronous (e.g., blogs) domains."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:Another possibly critical feature is the 'mention of names'. In multi-party discussion people usually mention each other 's name for the purpose of disentanglement ( #TARGET_REF ) . In our corpus we found 175 instances where a participant mentions other participant's name. In addition to these, 'Subject of the email', 'topic-shift cue words' can also be beneficial for a model. As a next step for this research, we will investigate how to exploit these features in our methods. We are also interested in the near future to transfer our approach to other similar domains by hierarchical Bayesian multi-task learning and other domain adaptation methods. We plan to work on both synchronous (e.g., chats, meetings) and asynchronous (e.g., blogs) domains.",
        "output": "conclusion:Another possibly critical feature is the 'mention of names'. In multi-party discussion people usually mention each other 's name for the purpose of disentanglement ( #TARGET_REF<BACKGROUND/> ) . In our corpus we found 175 instances where a participant mentions other participant's name. In addition to these, 'Subject of the email', 'topic-shift cue words' can also be beneficial for a model. As a next step for this research, we will investigate how to exploit these features in our methods. We are also interested in the near future to transfer our approach to other similar domains by hierarchical Bayesian multi-task learning and other domain adaptation methods. We plan to work on both synchronous (e.g., chats, meetings) and asynchronous (e.g., blogs) domains."
    },
    {
        "gold": {
            "text": [
                "Finally, we introduced the idea of evaluating induction systems based on their ability to produce useful cluster prototypes.",
                "We found that the oldest system ( #TARGET_REF ) yielded the best prototypes , and that using these prototypes gave state-of-the-art performance on WSJ , as well as improvements on nearly all of the non-English corpora .",
                "These promising results suggest a new direction for future research: improving POS induction by developing methods targeted towards extracting better prototypes, rather than focusing on improving clustering of the entire data set."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:Finally, we introduced the idea of evaluating induction systems based on their ability to produce useful cluster prototypes. We found that the oldest system ( #TARGET_REF ) yielded the best prototypes , and that using these prototypes gave state-of-the-art performance on WSJ , as well as improvements on nearly all of the non-English corpora . These promising results suggest a new direction for future research: improving POS induction by developing methods targeted towards extracting better prototypes, rather than focusing on improving clustering of the entire data set.",
        "output": "conclusion:Finally, we introduced the idea of evaluating induction systems based on their ability to produce useful cluster prototypes. We found that the oldest system ( #TARGET_REF<BACKGROUND/> ) yielded the best prototypes , and that using these prototypes gave state-of-the-art performance on WSJ , as well as improvements on nearly all of the non-English corpora . These promising results suggest a new direction for future research: improving POS induction by developing methods targeted towards extracting better prototypes, rather than focusing on improving clustering of the entire data set."
    },
    {
        "gold": {
            "text": [
                "We run our techniques on a large set of relations to output a first repository of typed functional relations.",
                "We release this list for further use by the research community. 2",
                "Future Work: Functionality is one of the several properties a relation can possess.",
                "Others include selectional preferences , transitivity ( #TARGET_REF ) , mutual exclusion , symmetry , etc. .",
                "These properties are very useful in increasing our understanding about these Open IE relation strings.",
                "We believe that the general principles developed in this work, for example, connecting the Open IE knowledge with an existing knowledge resource, will come in very handy in identifying these other properties."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:We run our techniques on a large set of relations to output a first repository of typed functional relations. We release this list for further use by the research community. 2 Future Work: Functionality is one of the several properties a relation can possess. Others include selectional preferences , transitivity ( #TARGET_REF ) , mutual exclusion , symmetry , etc. . These properties are very useful in increasing our understanding about these Open IE relation strings. We believe that the general principles developed in this work, for example, connecting the Open IE knowledge with an existing knowledge resource, will come in very handy in identifying these other properties.",
        "output": "conclusion:We run our techniques on a large set of relations to output a first repository of typed functional relations. We release this list for further use by the research community. 2 Future Work: Functionality is one of the several properties a relation can possess. Others include selectional preferences , transitivity ( #TARGET_REF<BACKGROUND/> ) , mutual exclusion , symmetry , etc. . These properties are very useful in increasing our understanding about these Open IE relation strings. We believe that the general principles developed in this work, for example, connecting the Open IE knowledge with an existing knowledge resource, will come in very handy in identifying these other properties."
    },
    {
        "gold": {
            "text": [
                "Sophisticated phrase table combination.",
                "Finally , we experiment with a method for combining phrase tables proposed in ( #TARGET_REF ; #REF ) .",
                "The first phrase table is extracted from word alignments for the balanced concatenation with repetitions, which are then truncated so that they are kept for only one copy of the Indonesian-English bi-text.",
                "The second table is built from the simple concatenation.",
                "The two tables are then merged as follows: all phrase pairs from the first one are retained, and to them are added those phrase pairs from the second one that are not present in the first one.",
                "Each phrase pair retains its original scores, which are further augmented with 1-3 additional feature scores indicating its origin: the first/second/third feature is 1 if the pair came from the first/second/both table(s), and 0 otherwise.",
                "We experiment using all three, the first two, or the first feature only; we also try setting the features to 0.5 instead of 0. This makes the following six combinations (0, 00, 000, .5, .5.5, .5.5.5); on testing, we use the one that achieves the highest BLEU score on the development set."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:Sophisticated phrase table combination. Finally , we experiment with a method for combining phrase tables proposed in ( #TARGET_REF ; #REF ) . The first phrase table is extracted from word alignments for the balanced concatenation with repetitions, which are then truncated so that they are kept for only one copy of the Indonesian-English bi-text. The second table is built from the simple concatenation. The two tables are then merged as follows: all phrase pairs from the first one are retained, and to them are added those phrase pairs from the second one that are not present in the first one. Each phrase pair retains its original scores, which are further augmented with 1-3 additional feature scores indicating its origin: the first/second/third feature is 1 if the pair came from the first/second/both table(s), and 0 otherwise. We experiment using all three, the first two, or the first feature only; we also try setting the features to 0.5 instead of 0. This makes the following six combinations (0, 00, 000, .5, .5.5, .5.5.5); on testing, we use the one that achieves the highest BLEU score on the development set.",
        "output": "method:Sophisticated phrase table combination. Finally , we experiment with a method for combining phrase tables proposed in ( #TARGET_REF<FUTURE/> ; #REF ) . The first phrase table is extracted from word alignments for the balanced concatenation with repetitions, which are then truncated so that they are kept for only one copy of the Indonesian-English bi-text. The second table is built from the simple concatenation. The two tables are then merged as follows: all phrase pairs from the first one are retained, and to them are added those phrase pairs from the second one that are not present in the first one. Each phrase pair retains its original scores, which are further augmented with 1-3 additional feature scores indicating its origin: the first/second/third feature is 1 if the pair came from the first/second/both table(s), and 0 otherwise. We experiment using all three, the first two, or the first feature only; we also try setting the features to 0.5 instead of 0. This makes the following six combinations (0, 00, 000, .5, .5.5, .5.5.5); on testing, we use the one that achieves the highest BLEU score on the development set."
    },
    {
        "gold": {
            "text": [
                "A third relevant line of research is on reusing bitexts between related languages without or with very little adaptation, which works well for very closely related languages.",
                "For example , our previous work ( #TARGET_REF ; #REF ) experimented with various techniques for combining a small bi-text for a resource-poor language ( Indonesian or Spanish , pretending that Spanish is resource-poor ) with a much larger bi-text for a related resource-rich language ( Malay or Portuguese ) ; the target language of all bi-texts was English .",
                "However, our previous work did not attempt language adaptation, except for very simple transliteration for Portuguese-Spanish that ignored context entirely; since it could not substitute one word for a completely different word, it did not help much for Malay-Indonesian, which use unified spelling.",
                "Still, once we have language-adapted the large bi-text, it makes sense to try to combine it further with the small bi-text; thus, below we will directly compare and combine these two approaches."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:A third relevant line of research is on reusing bitexts between related languages without or with very little adaptation, which works well for very closely related languages. For example , our previous work ( #TARGET_REF ; #REF ) experimented with various techniques for combining a small bi-text for a resource-poor language ( Indonesian or Spanish , pretending that Spanish is resource-poor ) with a much larger bi-text for a related resource-rich language ( Malay or Portuguese ) ; the target language of all bi-texts was English . However, our previous work did not attempt language adaptation, except for very simple transliteration for Portuguese-Spanish that ignored context entirely; since it could not substitute one word for a completely different word, it did not help much for Malay-Indonesian, which use unified spelling. Still, once we have language-adapted the large bi-text, it makes sense to try to combine it further with the small bi-text; thus, below we will directly compare and combine these two approaches.",
        "output": "related work:A third relevant line of research is on reusing bitexts between related languages without or with very little adaptation, which works well for very closely related languages. For example , our previous work ( #TARGET_REF<USE/> ; #REF ) experimented with various techniques for combining a small bi-text for a resource-poor language ( Indonesian or Spanish , pretending that Spanish is resource-poor ) with a much larger bi-text for a related resource-rich language ( Malay or Portuguese ) ; the target language of all bi-texts was English . However, our previous work did not attempt language adaptation, except for very simple transliteration for Portuguese-Spanish that ignored context entirely; since it could not substitute one word for a completely different word, it did not help much for Malay-Indonesian, which use unified spelling. Still, once we have language-adapted the large bi-text, it makes sense to try to combine it further with the small bi-text; thus, below we will directly compare and combine these two approaches."
    },
    {
        "gold": {
            "text": [
                "We mainly compute precision for this task, as the recall of paraphrase fragments is difficult to define.",
                "However, we do include a measure we call productivity to indicate the algorithm's completeness.",
                "It is defined as the ratio between the number of resulting fragment pairs and the number of sentence pairs used as input.",
                "Tab. 2 shows the evaluation results.",
                "We reach our best precision by using the VP-fragment heuristics, which is still more productive than the LCS method.",
                "The grammatical filter gives us a higher precision compared to the purely alignment-based approaches.",
                "Enhancing the system with coreference resolution raises the score even further.",
                "We cannot directly compare this performance to other systems, as all other approaches have different data sources.",
                "However, precision is usually manually evaluated, so the figures are at least indicative for a comparison with previous work: One state-of-theart system introduced by #REF extracts paraphrase fragments from bilingual parallel corpora and reaches a precision of 0.67.",
                "We found the same number using our previous approach ( #TARGET_REF ) , which is roughly equivalent to our core module .",
                "Our approach outperforms both by 17% with similar estimated productivity."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "experiments:We mainly compute precision for this task, as the recall of paraphrase fragments is difficult to define. However, we do include a measure we call productivity to indicate the algorithm's completeness. It is defined as the ratio between the number of resulting fragment pairs and the number of sentence pairs used as input. Tab. 2 shows the evaluation results. We reach our best precision by using the VP-fragment heuristics, which is still more productive than the LCS method. The grammatical filter gives us a higher precision compared to the purely alignment-based approaches. Enhancing the system with coreference resolution raises the score even further. We cannot directly compare this performance to other systems, as all other approaches have different data sources. However, precision is usually manually evaluated, so the figures are at least indicative for a comparison with previous work: One state-of-theart system introduced by #REF extracts paraphrase fragments from bilingual parallel corpora and reaches a precision of 0.67. We found the same number using our previous approach ( #TARGET_REF ) , which is roughly equivalent to our core module . Our approach outperforms both by 17% with similar estimated productivity.",
        "output": "experiments:We mainly compute precision for this task, as the recall of paraphrase fragments is difficult to define. However, we do include a measure we call productivity to indicate the algorithm's completeness. It is defined as the ratio between the number of resulting fragment pairs and the number of sentence pairs used as input. Tab. 2 shows the evaluation results. We reach our best precision by using the VP-fragment heuristics, which is still more productive than the LCS method. The grammatical filter gives us a higher precision compared to the purely alignment-based approaches. Enhancing the system with coreference resolution raises the score even further. We cannot directly compare this performance to other systems, as all other approaches have different data sources. However, precision is usually manually evaluated, so the figures are at least indicative for a comparison with previous work: One state-of-theart system introduced by #REF extracts paraphrase fragments from bilingual parallel corpora and reaches a precision of 0.67. We found the same number using our previous approach ( #TARGET_REF<COMPARISON/> ) , which is roughly equivalent to our core module . Our approach outperforms both by 17% with similar estimated productivity."
    },
    {
        "gold": {
            "text": [
                "We take some core ideas from our previous work on mining script information ( #TARGET_REF ) .",
                "In this earlier work, we focused on event structures and their possible realizations in natural language.",
                "The corpus used in those experiments were short crowd-sourced descriptions of everyday tasks written in bullet point style.",
                "We aligned them with a hand-crafted similarity measure that was specifically designed for this text type.",
                "In this current work, we target the general task of extracting paraphrases for events rather than the much more specific scriptrelated task.",
                "The current approach uses a domainindependent similarity measure instead of a specific hand-crafted similarity score and is thus applicable to standard texts."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "related work:We take some core ideas from our previous work on mining script information ( #TARGET_REF ) . In this earlier work, we focused on event structures and their possible realizations in natural language. The corpus used in those experiments were short crowd-sourced descriptions of everyday tasks written in bullet point style. We aligned them with a hand-crafted similarity measure that was specifically designed for this text type. In this current work, we target the general task of extracting paraphrases for events rather than the much more specific scriptrelated task. The current approach uses a domainindependent similarity measure instead of a specific hand-crafted similarity score and is thus applicable to standard texts.",
        "output": "related work:We take some core ideas from our previous work on mining script information ( #TARGET_REF<COMPARISON/> ) . In this earlier work, we focused on event structures and their possible realizations in natural language. The corpus used in those experiments were short crowd-sourced descriptions of everyday tasks written in bullet point style. We aligned them with a hand-crafted similarity measure that was specifically designed for this text type. In this current work, we target the general task of extracting paraphrases for events rather than the much more specific scriptrelated task. The current approach uses a domainindependent similarity measure instead of a specific hand-crafted similarity score and is thus applicable to standard texts."
    },
    {
        "gold": {
            "text": [
                "From an applicational point of view, sentential paraphrases are difficult to use in other NLP tasks.",
                "At the phrasal level, interchangeable patterns (#REF;#REF) or inference rules (#REF) are extracted.",
                "In both cases, each pattern or rule contains one or several slots, which are restricted to certain type of words, e.g., named entities (NE) or content words.",
                "They are quite successful in NE-centered tasks, like information extraction, but their level of generalization or coverage is insufficient for applications like Recognizing Textual Entailment (#REF).",
                "The research on general paraphrase fragment extraction at the sub-sentential level is mainly based on phrase pair extraction techniques from the MT literature.",
                "#REF extract subsentential translation pairs from comparable corpora using the log-likelihood-ratio of word translation probability.",
                "#REF extract fragments using a generative model of noisy translations.",
                "Our own work ( #TARGET_REF ) extends the first idea to paraphrase fragment extraction on monolingual parallel and comparable corpora .",
                "Our current approach also uses word-word alignment, however, we use syntactic dependency trees to compute grammatical fragments.",
                "Our use of dependency trees is inspired by the constituent-tree-based experiments of #REF."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "related work:From an applicational point of view, sentential paraphrases are difficult to use in other NLP tasks. At the phrasal level, interchangeable patterns (#REF;#REF) or inference rules (#REF) are extracted. In both cases, each pattern or rule contains one or several slots, which are restricted to certain type of words, e.g., named entities (NE) or content words. They are quite successful in NE-centered tasks, like information extraction, but their level of generalization or coverage is insufficient for applications like Recognizing Textual Entailment (#REF). The research on general paraphrase fragment extraction at the sub-sentential level is mainly based on phrase pair extraction techniques from the MT literature. #REF extract subsentential translation pairs from comparable corpora using the log-likelihood-ratio of word translation probability. #REF extract fragments using a generative model of noisy translations. Our own work ( #TARGET_REF ) extends the first idea to paraphrase fragment extraction on monolingual parallel and comparable corpora . Our current approach also uses word-word alignment, however, we use syntactic dependency trees to compute grammatical fragments. Our use of dependency trees is inspired by the constituent-tree-based experiments of #REF.",
        "output": "related work:From an applicational point of view, sentential paraphrases are difficult to use in other NLP tasks. At the phrasal level, interchangeable patterns (#REF;#REF) or inference rules (#REF) are extracted. In both cases, each pattern or rule contains one or several slots, which are restricted to certain type of words, e.g., named entities (NE) or content words. They are quite successful in NE-centered tasks, like information extraction, but their level of generalization or coverage is insufficient for applications like Recognizing Textual Entailment (#REF). The research on general paraphrase fragment extraction at the sub-sentential level is mainly based on phrase pair extraction techniques from the MT literature. #REF extract subsentential translation pairs from comparable corpora using the log-likelihood-ratio of word translation probability. #REF extract fragments using a generative model of noisy translations. Our own work ( #TARGET_REF<COMPARISON/> ) extends the first idea to paraphrase fragment extraction on monolingual parallel and comparable corpora . Our current approach also uses word-word alignment, however, we use syntactic dependency trees to compute grammatical fragments. Our use of dependency trees is inspired by the constituent-tree-based experiments of #REF."
    },
    {
        "gold": {
            "text": [
                "Provided with the candidate fragment elements , we previously ( #TARGET_REF ) used a chunker3 to finalize the output fragments , in order to follow the linguistic definition of a ( para - ) phrase .",
                "We extend this step in the current system by applying a dependency parser to constrain the boundary of the fragments (Sec.",
                "5.3).",
                "Finally, we filter out trivial fragment pairs, such as identical or the original sentence pairs."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "nan:Provided with the candidate fragment elements , we previously ( #TARGET_REF ) used a chunker3 to finalize the output fragments , in order to follow the linguistic definition of a ( para - ) phrase . We extend this step in the current system by applying a dependency parser to constrain the boundary of the fragments (Sec. 5.3). Finally, we filter out trivial fragment pairs, such as identical or the original sentence pairs.",
        "output": "nan:Provided with the candidate fragment elements , we previously ( #TARGET_REF<COMPARISON/> ) used a chunker3 to finalize the output fragments , in order to follow the linguistic definition of a ( para - ) phrase . We extend this step in the current system by applying a dependency parser to constrain the boundary of the fragments (Sec. 5.3). Finally, we filter out trivial fragment pairs, such as identical or the original sentence pairs."
    },
    {
        "gold": {
            "text": [
                "Similar to ( #TARGET_REFa ) , our summarization system is , which consists of three key components : an initial sentence pre-selection module to select some important sentence candidates ; the above compression model to generate n-best compressions for each sentence ; and then an ILP summarization method to select the best summary sentences from the multiple compressed sentences ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:Similar to ( #TARGET_REFa ) , our summarization system is , which consists of three key components : an initial sentence pre-selection module to select some important sentence candidates ; the above compression model to generate n-best compressions for each sentence ; and then an ILP summarization method to select the best summary sentences from the multiple compressed sentences .",
        "output": "experiments:Similar to ( #TARGET_REF<USE/>a ) , our summarization system is , which consists of three key components : an initial sentence pre-selection module to select some important sentence candidates ; the above compression model to generate n-best compressions for each sentence ; and then an ILP summarization method to select the best summary sentences from the multiple compressed sentences ."
    },
    {
        "gold": {
            "text": [
                "Our approach to the problem is more compatible with the empirical evidence we presented in our prior work ( #TARGET_REF ) where we analyzed the output of Chinese to English machine translation and found that there is no correlation between sentence length and MT quality .",
                "Rather we showed that the quality of translation was markedly inferior, compared to overall translation quality, for sentences that were translated into multiple English sentences.",
                "This prior work was carried over a dataset containing a single reference translation for each Chinese sentence.",
                "In the work presented in this paper, we strengthen our findings by examining multiple reference translations for each Chinese sentence.",
                "We define heavy sentences based on agreement of translator choices and reader preferences."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:Our approach to the problem is more compatible with the empirical evidence we presented in our prior work ( #TARGET_REF ) where we analyzed the output of Chinese to English machine translation and found that there is no correlation between sentence length and MT quality . Rather we showed that the quality of translation was markedly inferior, compared to overall translation quality, for sentences that were translated into multiple English sentences. This prior work was carried over a dataset containing a single reference translation for each Chinese sentence. In the work presented in this paper, we strengthen our findings by examining multiple reference translations for each Chinese sentence. We define heavy sentences based on agreement of translator choices and reader preferences.",
        "output": "related work:Our approach to the problem is more compatible with the empirical evidence we presented in our prior work ( #TARGET_REF<USE/> ) where we analyzed the output of Chinese to English machine translation and found that there is no correlation between sentence length and MT quality . Rather we showed that the quality of translation was markedly inferior, compared to overall translation quality, for sentences that were translated into multiple English sentences. This prior work was carried over a dataset containing a single reference translation for each Chinese sentence. In the work presented in this paper, we strengthen our findings by examining multiple reference translations for each Chinese sentence. We define heavy sentences based on agreement of translator choices and reader preferences."
    },
    {
        "gold": {
            "text": [
                "During the tectogrammatical parsing of Czech, the analytical tree structure is converted into the tectogrammatical one.",
                "These automatic transformations are based on linguistic rules ( #TARGET_REF ) .",
                "Subsequently, tectogrammatical functors are assigned by the C4.5 classifier (2abokrtsk9 et al., 2002)."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:During the tectogrammatical parsing of Czech, the analytical tree structure is converted into the tectogrammatical one. These automatic transformations are based on linguistic rules ( #TARGET_REF ) . Subsequently, tectogrammatical functors are assigned by the C4.5 classifier (2abokrtsk9 et al., 2002).",
        "output": "experiments:During the tectogrammatical parsing of Czech, the analytical tree structure is converted into the tectogrammatical one. These automatic transformations are based on linguistic rules ( #TARGET_REF<FUTURE/> ) . Subsequently, tectogrammatical functors are assigned by the C4.5 classifier (2abokrtsk9 et al., 2002)."
    },
    {
        "gold": {
            "text": [
                "The analytical parsing of Czech runs in two steps: the statistical dependency parser, which creates the structure of a dependency tree, and a classifier assigning analytical functors.",
                "We carried out two parallel experiments with two parsers available for Czech , parser I ( #REF ) and parser II ( #TARGET_REF ) .",
                "In the second step, we used a module for automatic analytical functor assignment (2abokrtskyT et al., 2002)."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:The analytical parsing of Czech runs in two steps: the statistical dependency parser, which creates the structure of a dependency tree, and a classifier assigning analytical functors. We carried out two parallel experiments with two parsers available for Czech , parser I ( #REF ) and parser II ( #TARGET_REF ) . In the second step, we used a module for automatic analytical functor assignment (2abokrtskyT et al., 2002).",
        "output": "experiments:The analytical parsing of Czech runs in two steps: the statistical dependency parser, which creates the structure of a dependency tree, and a classifier assigning analytical functors. We carried out two parallel experiments with two parsers available for Czech , parser I ( #REF ) and parser II ( #TARGET_REF<FUTURE/> ) . In the second step, we used a module for automatic analytical functor assignment (2abokrtskyT et al., 2002)."
    },
    {
        "gold": {
            "text": [
                "To make the dictionary more sensitive to a specific domain, which is in our case the domain of financial news, we created a probabilistic CzechEnglish dictionary by running GIZA + + training ( translation models 1-4 , see #TARGET_REF ) on the training part of the English-Czech WSJ parallel corpus extended by the parallel corpus of entry/translation pairs from the manual dictionary.",
                "As a result, the entry/translation pairs seen in the parallel corpus of WSJ become more probable.",
                "For entry/translation pairs not seen in the parallel text, the probability distribution among translations is uniform.",
                "The translation is \"GIZA++ se- lected\" if its probability is higher than a threshold, which is in our case set to 0.10."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:To make the dictionary more sensitive to a specific domain, which is in our case the domain of financial news, we created a probabilistic CzechEnglish dictionary by running GIZA + + training ( translation models 1-4 , see #TARGET_REF ) on the training part of the English-Czech WSJ parallel corpus extended by the parallel corpus of entry/translation pairs from the manual dictionary. As a result, the entry/translation pairs seen in the parallel corpus of WSJ become more probable. For entry/translation pairs not seen in the parallel text, the probability distribution among translations is uniform. The translation is \"GIZA++ se- lected\" if its probability is higher than a threshold, which is in our case set to 0.10.",
        "output": "nan:To make the dictionary more sensitive to a specific domain, which is in our case the domain of financial news, we created a probabilistic CzechEnglish dictionary by running GIZA + + training ( translation models 1-4 , see #TARGET_REF<FUTURE/> ) on the training part of the English-Czech WSJ parallel corpus extended by the parallel corpus of entry/translation pairs from the manual dictionary. As a result, the entry/translation pairs seen in the parallel corpus of WSJ become more probable. For entry/translation pairs not seen in the parallel text, the probability distribution among translations is uniform. The translation is \"GIZA++ se- lected\" if its probability is higher than a threshold, which is in our case set to 0.10."
    },
    {
        "gold": {
            "text": [
                "First, we summarize resources available for the experiments (Section 2).",
                "Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input.",
                "In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5).",
                "The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7.",
                "For the evaluation of the results we use the BLEU score ( #TARGET_REF ) .",
                "Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations.",
                "We also compare the results with the output generated by the statistical translation system GIZA++/ISI ReWrite Decoder (#REF;#REF;#REF), trained on the same parallel corpus."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "introduction:First, we summarize resources available for the experiments (Section 2). Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input. In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5). The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7. For the evaluation of the results we use the BLEU score ( #TARGET_REF ) . Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations. We also compare the results with the output generated by the statistical translation system GIZA++/ISI ReWrite Decoder (#REF;#REF;#REF), trained on the same parallel corpus.",
        "output": "introduction:First, we summarize resources available for the experiments (Section 2). Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input. In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5). The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7. For the evaluation of the results we use the BLEU score ( #TARGET_REF<FUTURE/> ) . Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations. We also compare the results with the output generated by the statistical translation system GIZA++/ISI ReWrite Decoder (#REF;#REF;#REF), trained on the same parallel corpus."
    },
    {
        "gold": {
            "text": [
                "First, we summarize resources available for the experiments (Section 2).",
                "Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input.",
                "In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5).",
                "The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7.",
                "For the evaluation of the results we use the BLEU score (#REF).",
                "Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations.",
                "We also compare the results with the output generated by the statistical translation system GIZA + + / ISI ReWrite Decoder ( #REF ; #TARGET_REF ; #REF ) , trained on the same parallel corpus ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:First, we summarize resources available for the experiments (Section 2). Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input. In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5). The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7. For the evaluation of the results we use the BLEU score (#REF). Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations. We also compare the results with the output generated by the statistical translation system GIZA + + / ISI ReWrite Decoder ( #REF ; #TARGET_REF ; #REF ) , trained on the same parallel corpus .",
        "output": "introduction:First, we summarize resources available for the experiments (Section 2). Section 3 describes the automatic procedures used for the preparation of both training and testing data, including morphological tagging, and analytical and tectogrammatical parsing of Czech input. In Section 4 we describe the process of the filtering of dictionaries used in the transfer procedure (for its characterization, see Section 5). The generation process consisting mainly of word reordering and lexical insertions is explained in Section 6, an example illustrating the generation steps is presented in Sec-tion 7. For the evaluation of the results we use the BLEU score (#REF). Section 8 compares translations generated from automatically built and manually annotated tectogrammatical representations. We also compare the results with the output generated by the statistical translation system GIZA + + / ISI ReWrite Decoder ( #REF ; #TARGET_REF<USE/> ; #REF ) , trained on the same parallel corpus ."
    },
    {
        "gold": {
            "text": [
                "We evaluated our translations with IBM 's BLEU evaluation metric ( #TARGET_REF ) , using the same evaluation method and reference retranslations that were used for evaluation at HLT #REF at CLSP ( Haji 6 et al. , 2002 ) .",
                "We used four reference retranslations of 490 sentences selected from the WSJ sections 22, 23, and 24, which were themselves used as the fifth reference.",
                "The evaluation method used is to hold out each reference in turn and evaluate it against the remaining four, averaging the five BLEU scores."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We evaluated our translations with IBM 's BLEU evaluation metric ( #TARGET_REF ) , using the same evaluation method and reference retranslations that were used for evaluation at HLT #REF at CLSP ( Haji 6 et al. , 2002 ) . We used four reference retranslations of 490 sentences selected from the WSJ sections 22, 23, and 24, which were themselves used as the fifth reference. The evaluation method used is to hold out each reference in turn and evaluate it against the remaining four, averaging the five BLEU scores.",
        "output": "experiments:We evaluated our translations with IBM 's BLEU evaluation metric ( #TARGET_REF<FUTURE/> ) , using the same evaluation method and reference retranslations that were used for evaluation at HLT #REF at CLSP ( Haji 6 et al. , 2002 ) . We used four reference retranslations of 490 sentences selected from the WSJ sections 22, 23, and 24, which were themselves used as the fifth reference. The evaluation method used is to hold out each reference in turn and evaluate it against the remaining four, averaging the five BLEU scores."
    },
    {
        "gold": {
            "text": [
                "We compared the two statistical lexica obtained from the baseline system and from the maximum entropy training on the transformed corpus.",
                "For the baseline lexicon, we observed an average of 5.82 Catalan translation candidates per English word and 6.16 Spanish translation candidates.",
                "These numbers are significantly reduced in the lexicon which was trained on the transformed corpus using maximum entropy: there, we have an average of 4.20 for Catalan and 4.46 for Spanish.",
                "Especially for (nominative) English pronouns (which have many verbs as translation candidates in the baseline lexicon), the number of translation candidates was substantially scaled down by a factor around 4. This shows that our method was successful in producing a more focused lexicon probability distribution.",
                "We performed translation experiments with an implementation of the IBM-4 translation model ( #TARGET_REF ) .",
                "A description of the system can be found in (#REF).",
                "Table 5 presents an assessment of translation quality for both the language pairs English-Catalan and English-Spanish.",
                "We see that there is a significant decrease in error rate for the translation into Catalan.",
                "This change is consistent across both error rates, the WER and 100-BLEU.",
                "For translations from English into Spanish, the improvement is less substantial."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We compared the two statistical lexica obtained from the baseline system and from the maximum entropy training on the transformed corpus. For the baseline lexicon, we observed an average of 5.82 Catalan translation candidates per English word and 6.16 Spanish translation candidates. These numbers are significantly reduced in the lexicon which was trained on the transformed corpus using maximum entropy: there, we have an average of 4.20 for Catalan and 4.46 for Spanish. Especially for (nominative) English pronouns (which have many verbs as translation candidates in the baseline lexicon), the number of translation candidates was substantially scaled down by a factor around 4. This shows that our method was successful in producing a more focused lexicon probability distribution. We performed translation experiments with an implementation of the IBM-4 translation model ( #TARGET_REF ) . A description of the system can be found in (#REF). Table 5 presents an assessment of translation quality for both the language pairs English-Catalan and English-Spanish. We see that there is a significant decrease in error rate for the translation into Catalan. This change is consistent across both error rates, the WER and 100-BLEU. For translations from English into Spanish, the improvement is less substantial.",
        "output": "experiments:We compared the two statistical lexica obtained from the baseline system and from the maximum entropy training on the transformed corpus. For the baseline lexicon, we observed an average of 5.82 Catalan translation candidates per English word and 6.16 Spanish translation candidates. These numbers are significantly reduced in the lexicon which was trained on the transformed corpus using maximum entropy: there, we have an average of 4.20 for Catalan and 4.46 for Spanish. Especially for (nominative) English pronouns (which have many verbs as translation candidates in the baseline lexicon), the number of translation candidates was substantially scaled down by a factor around 4. This shows that our method was successful in producing a more focused lexicon probability distribution. We performed translation experiments with an implementation of the IBM-4 translation model ( #TARGET_REF<FUTURE/> ) . A description of the system can be found in (#REF). Table 5 presents an assessment of translation quality for both the language pairs English-Catalan and English-Spanish. We see that there is a significant decrease in error rate for the translation into Catalan. This change is consistent across both error rates, the WER and 100-BLEU. For translations from English into Spanish, the improvement is less substantial."
    },
    {
        "gold": {
            "text": [
                "The maximum entropy approach ( #TARGET_REF ) presents a powerful framework for the combination of several knowledge sources .",
                "This principle recommends to choose the distribution which preserves as much uncertainty as possible in terms of maximizing the entropy.",
                "The distribution is required to satisfy constraints, which represent facts known from the data.",
                "These constraints are expressed on the basis of feature functions hu,(s,t),"
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:The maximum entropy approach ( #TARGET_REF ) presents a powerful framework for the combination of several knowledge sources . This principle recommends to choose the distribution which preserves as much uncertainty as possible in terms of maximizing the entropy. The distribution is required to satisfy constraints, which represent facts known from the data. These constraints are expressed on the basis of feature functions hu,(s,t),",
        "output": "nan:The maximum entropy approach ( #TARGET_REF<FUTURE/> ) presents a powerful framework for the combination of several knowledge sources . This principle recommends to choose the distribution which preserves as much uncertainty as possible in terms of maximizing the entropy. The distribution is required to satisfy constraints, which represent facts known from the data. These constraints are expressed on the basis of feature functions hu,(s,t),"
    },
    {
        "gold": {
            "text": [
                "The input string can be preprocessed before being passed to the search algorithm.",
                "If necessary, the inverse of these transformations will be applied to the generated output string.",
                "In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology.",
                "For descriptions of SMT systems see for example ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:The input string can be preprocessed before being passed to the search algorithm. If necessary, the inverse of these transformations will be applied to the generated output string. In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology. For descriptions of SMT systems see for example ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ) .",
        "output": "nan:The input string can be preprocessed before being passed to the search algorithm. If necessary, the inverse of these transformations will be applied to the generated output string. In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology. For descriptions of SMT systems see for example ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "where A = {Am } is the set of model parameters with one weight A, for each feature function hm .",
                "For an introduction to maximum entropy modeling and training procedures , the reader is referred to the corresponding literature , for instance ( #TARGET_REF ) or ( #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:where A = {Am } is the set of model parameters with one weight A, for each feature function hm . For an introduction to maximum entropy modeling and training procedures , the reader is referred to the corresponding literature , for instance ( #TARGET_REF ) or ( #REF ) .",
        "output": "nan:where A = {Am } is the set of model parameters with one weight A, for each feature function hm . For an introduction to maximum entropy modeling and training procedures , the reader is referred to the corresponding literature , for instance ( #TARGET_REF<BACKGROUND/> ) or ( #REF ) ."
    },
    {
        "gold": {
            "text": [
                "The input string can be preprocessed before being passed to the search algorithm.",
                "If necessary, the inverse of these transformations will be applied to the generated output string.",
                "In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology.",
                "For descriptions of SMT systems see for example ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:The input string can be preprocessed before being passed to the search algorithm. If necessary, the inverse of these transformations will be applied to the generated output string. In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology. For descriptions of SMT systems see for example ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) .",
        "output": "nan:The input string can be preprocessed before being passed to the search algorithm. If necessary, the inverse of these transformations will be applied to the generated output string. In the work presented here, we restrict ourselves to transforming only one language of the two: the source, which has the less inflected morphology. For descriptions of SMT systems see for example ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Due to using a global model like CRFs , our previous work in ( #REF ; #TARGET_REFc ) reported the best results over the evaluated corpora of Bakeoff-2 until now7 .",
                "Though those results are slightly better than the results here, we still see that the results of character-level dependency parsing approach (Scheme E) are comparable to those state-of-the-art ones on each evaluated corpus."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:Due to using a global model like CRFs , our previous work in ( #REF ; #TARGET_REFc ) reported the best results over the evaluated corpora of Bakeoff-2 until now7 . Though those results are slightly better than the results here, we still see that the results of character-level dependency parsing approach (Scheme E) are comparable to those state-of-the-art ones on each evaluated corpus.",
        "output": "method:Due to using a global model like CRFs , our previous work in ( #REF ; #TARGET_REF<USE/>c ) reported the best results over the evaluated corpora of Bakeoff-2 until now7 . Though those results are slightly better than the results here, we still see that the results of character-level dependency parsing approach (Scheme E) are comparable to those state-of-the-art ones on each evaluated corpus."
    },
    {
        "gold": {
            "text": [
                "1 The representation in #TARGET_REF is even more compact than ours for grammars that are not self-embedding .",
                "However, in this paper we use our representation as an intermediate result in approximating an unrestricted context-free grammar, with the final objective of obtaining a single minimal deterministic automaton.",
                "For this purpose, Mohri and Pereira's representation offers little advantage."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:1 The representation in #TARGET_REF is even more compact than ours for grammars that are not self-embedding . However, in this paper we use our representation as an intermediate result in approximating an unrestricted context-free grammar, with the final objective of obtaining a single minimal deterministic automaton. For this purpose, Mohri and Pereira's representation offers little advantage.",
        "output": "nan:1 The representation in #TARGET_REF<USE/> is even more compact than ours for grammars that are not self-embedding . However, in this paper we use our representation as an intermediate result in approximating an unrestricted context-free grammar, with the final objective of obtaining a single minimal deterministic automaton. For this purpose, Mohri and Pereira's representation offers little advantage."
    },
    {
        "gold": {
            "text": [
                "By restricting the height of the stack of a pushdown automaton, one obstructs recognition of a set of strings in the context-free language, and therefore a subset approximation results.",
                "This idea was proposed by Krauwer and des #REF , #REF , and #REF , and was rediscovered by #REF and recently by #TARGET_REF .",
                "Since the latest publication in this area is more explicit in its presentation, we will base our treatment on this, instead of going to the historical roots of the method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:By restricting the height of the stack of a pushdown automaton, one obstructs recognition of a set of strings in the context-free language, and therefore a subset approximation results. This idea was proposed by Krauwer and des #REF , #REF , and #REF , and was rediscovered by #REF and recently by #TARGET_REF . Since the latest publication in this area is more explicit in its presentation, we will base our treatment on this, instead of going to the historical roots of the method.",
        "output": "nan:By restricting the height of the stack of a pushdown automaton, one obstructs recognition of a set of strings in the context-free language, and therefore a subset approximation results. This idea was proposed by Krauwer and des #REF , #REF , and #REF , and was rediscovered by #REF and recently by #TARGET_REF<BACKGROUND/> . Since the latest publication in this area is more explicit in its presentation, we will base our treatment on this, instead of going to the historical roots of the method."
    },
    {
        "gold": {
            "text": [
                "We rephrase the method of #TARGET_REF as follows : First , we construct the approximating finite automaton according to the unparameterized RTN method above .",
                "Then an additional mechanism is introduced that ensures for each rule A --~ X1 • .. Xm separately that the list of visits to the states qo,.. • • qm satisfies some reasonable criteria: a visit to qi, with 0 < i < m, should be followed by one to qi+l or q0.",
                "The latter option amounts to a nested incarnation of the rule.",
                "There is a complementary condition for what should precede a visit to qi, with 0 < i < m."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:We rephrase the method of #TARGET_REF as follows : First , we construct the approximating finite automaton according to the unparameterized RTN method above . Then an additional mechanism is introduced that ensures for each rule A --~ X1 • .. Xm separately that the list of visits to the states qo,.. • • qm satisfies some reasonable criteria: a visit to qi, with 0 < i < m, should be followed by one to qi+l or q0. The latter option amounts to a nested incarnation of the rule. There is a complementary condition for what should precede a visit to qi, with 0 < i < m.",
        "output": "nan:We rephrase the method of #TARGET_REF<FUTURE/> as follows : First , we construct the approximating finite automaton according to the unparameterized RTN method above . Then an additional mechanism is introduced that ensures for each rule A --~ X1 • .. Xm separately that the list of visits to the states qo,.. • • qm satisfies some reasonable criteria: a visit to qi, with 0 < i < m, should be followed by one to qi+l or q0. The latter option amounts to a nested incarnation of the rule. There is a complementary condition for what should precede a visit to qi, with 0 < i < m."
    },
    {
        "gold": {
            "text": [
                "This method can be generalized , inspired by #TARGET_REF , who derive N-gram probabilities from stochastic context-free grammars .",
                "By ignoring the probabilities, each N = 1, 2, 3 .... gives rise to a superset approximation that can be described as follows: The set of strings derivable from a nonterminal A is approximated by the set of strings al ... an such that • for each substring v = ai+l ... ai+N (0 < i < n --N) we have A --+* wvy, for some w and y,"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:This method can be generalized , inspired by #TARGET_REF , who derive N-gram probabilities from stochastic context-free grammars . By ignoring the probabilities, each N = 1, 2, 3 .... gives rise to a superset approximation that can be described as follows: The set of strings derivable from a nonterminal A is approximated by the set of strings al ... an such that • for each substring v = ai+l ... ai+N (0 < i < n --N) we have A --+* wvy, for some w and y,",
        "output": "nan:This method can be generalized , inspired by #TARGET_REF<BACKGROUND/> , who derive N-gram probabilities from stochastic context-free grammars . By ignoring the probabilities, each N = 1, 2, 3 .... gives rise to a superset approximation that can be described as follows: The set of strings derivable from a nonterminal A is approximated by the set of strings al ... an such that • for each substring v = ai+l ... ai+N (0 < i < n --N) we have A --+* wvy, for some w and y,"
    },
    {
        "gold": {
            "text": [
                "See #TARGET_REF for a variant of this approximation that constructs finite transducers rather than finite automata ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:See #TARGET_REF for a variant of this approximation that constructs finite transducers rather than finite automata .",
        "output": "nan:See #TARGET_REF<BACKGROUND/> for a variant of this approximation that constructs finite transducers rather than finite automata ."
    },
    {
        "gold": {
            "text": [
                "In general, increasing d allows more of such derivations that are not of the form A ~\" o~Afl but also allows more derivations that are of that form.The reason for considering this transformation rather than any other that eliminates self-embedding is purely pragmatic: of the many variants we have tried that yield nontrivial subset approximations, this transformation has the lowest complexity in terms of the sizes of intermediate structures and of the resulting finite automata.In the actual implementation, we have integrated the grammar transformation and the construction of the finite automaton, which avoids reanalysis of the grammar to determine the partition of mutually recursive nonterminals after transformation.",
                "This integration makes use, for example, of the fact that for fixed Ni and fixed f, the set of nonterminals of the form A,f, with A c Ni, is (potentially) mutually right-recursive.A set of such nonterminals can therefore be treated as the corresponding case from Figure2, assuming the value right.The full formulation of the integrated grammar transformation and construction of the finite automaton is rather long and is therefore not given here.",
                "A very similar formulation , for another grammar transformation , is given in #TARGET_REF ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:In general, increasing d allows more of such derivations that are not of the form A ~\" o~Afl but also allows more derivations that are of that form.The reason for considering this transformation rather than any other that eliminates self-embedding is purely pragmatic: of the many variants we have tried that yield nontrivial subset approximations, this transformation has the lowest complexity in terms of the sizes of intermediate structures and of the resulting finite automata.In the actual implementation, we have integrated the grammar transformation and the construction of the finite automaton, which avoids reanalysis of the grammar to determine the partition of mutually recursive nonterminals after transformation. This integration makes use, for example, of the fact that for fixed Ni and fixed f, the set of nonterminals of the form A,f, with A c Ni, is (potentially) mutually right-recursive.A set of such nonterminals can therefore be treated as the corresponding case from Figure2, assuming the value right.The full formulation of the integrated grammar transformation and construction of the finite automaton is rather long and is therefore not given here. A very similar formulation , for another grammar transformation , is given in #TARGET_REF .",
        "output": "nan:In general, increasing d allows more of such derivations that are not of the form A ~\" o~Afl but also allows more derivations that are of that form.The reason for considering this transformation rather than any other that eliminates self-embedding is purely pragmatic: of the many variants we have tried that yield nontrivial subset approximations, this transformation has the lowest complexity in terms of the sizes of intermediate structures and of the resulting finite automata.In the actual implementation, we have integrated the grammar transformation and the construction of the finite automaton, which avoids reanalysis of the grammar to determine the partition of mutually recursive nonterminals after transformation. This integration makes use, for example, of the fact that for fixed Ni and fixed f, the set of nonterminals of the form A,f, with A c Ni, is (potentially) mutually right-recursive.A set of such nonterminals can therefore be treated as the corresponding case from Figure2, assuming the value right.The full formulation of the integrated grammar transformation and construction of the finite automaton is rather long and is therefore not given here. A very similar formulation , for another grammar transformation , is given in #TARGET_REF<USE/> ."
    },
    {
        "gold": {
            "text": [
                "which states that the letter substring B with left context A and right context C receives the pronunciation (i.e., phoneme substring) D. Such rules can also be straightforwardly cast in the IF... THEN form commonly featured in high-level programming languages and employed in expert, knowledge-based systems technology.",
                "They also constitute a formal model of universal computation (#REF).",
                "Conventionally, these rules are specified by an expert linguist, conversant with the sound and spelling systems of the language of concern.",
                "Typical letter-to-sound rule sets are those described by #REF , #REF , #REF , #REF , and #TARGET_REF ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:which states that the letter substring B with left context A and right context C receives the pronunciation (i.e., phoneme substring) D. Such rules can also be straightforwardly cast in the IF... THEN form commonly featured in high-level programming languages and employed in expert, knowledge-based systems technology. They also constitute a formal model of universal computation (#REF). Conventionally, these rules are specified by an expert linguist, conversant with the sound and spelling systems of the language of concern. Typical letter-to-sound rule sets are those described by #REF , #REF , #REF , #REF , and #TARGET_REF .",
        "output": "introduction:which states that the letter substring B with left context A and right context C receives the pronunciation (i.e., phoneme substring) D. Such rules can also be straightforwardly cast in the IF... THEN form commonly featured in high-level programming languages and employed in expert, knowledge-based systems technology. They also constitute a formal model of universal computation (#REF). Conventionally, these rules are specified by an expert linguist, conversant with the sound and spelling systems of the language of concern. Typical letter-to-sound rule sets are those described by #REF , #REF , #REF , #REF , and #TARGET_REF<BACKGROUND/> ."
    },
    {
        "gold": {
            "text": [
                "It is also conceivable that data-driven techniques can actually outperform traditional rules.",
                "However, this possibility is not usually given much credence.",
                "For instance , #TARGET_REF recently wrote : `` To our knowledge , learning algorithms , although promising , have not ( yet ) reached the level of rule sets developed by humans '' ( p. 520 ) .",
                "520).",
                "#REF takes this further, stating \"such training-based strategies are often assumed to exhibit much more intelligence than they do in practice, as revealed by their poor transcription scores\" (p.",
                "115, note 14)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:It is also conceivable that data-driven techniques can actually outperform traditional rules. However, this possibility is not usually given much credence. For instance , #TARGET_REF recently wrote : `` To our knowledge , learning algorithms , although promising , have not ( yet ) reached the level of rule sets developed by humans '' ( p. 520 ) . 520). #REF takes this further, stating \"such training-based strategies are often assumed to exhibit much more intelligence than they do in practice, as revealed by their poor transcription scores\" (p. 115, note 14).",
        "output": "introduction:It is also conceivable that data-driven techniques can actually outperform traditional rules. However, this possibility is not usually given much credence. For instance , #TARGET_REF<BACKGROUND/> recently wrote : `` To our knowledge , learning algorithms , although promising , have not ( yet ) reached the level of rule sets developed by humans '' ( p. 520 ) . 520). #REF takes this further, stating \"such training-based strategies are often assumed to exhibit much more intelligence than they do in practice, as revealed by their poor transcription scores\" (p. 115, note 14)."
    },
    {
        "gold": {
            "text": [
                "Pronunciation by analogy (PbA) is a data-driven technique for the automatic phonemization of text, originally proposed as a model of reading, e.g., by #REF and #REF.",
                "It was first proposed for TTS applications over a decade ago by Dedina andNusbaum (1986, 1991).",
                "See also the work of #TARGET_REF , which considers computer-based pronunciation by analogy but does not mention the possible application to text-to-speech synthesis .",
                "As detailed by #REF and #REF, PbA shares many similarities with the artificial intelligence paradigms variously called case-based, memory-based, or instance-based reasoning as applied to letter-to-phoneme conversion (#REF;#REF;#REF#REF#REF;#REF;van den #REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Pronunciation by analogy (PbA) is a data-driven technique for the automatic phonemization of text, originally proposed as a model of reading, e.g., by #REF and #REF. It was first proposed for TTS applications over a decade ago by Dedina andNusbaum (1986, 1991). See also the work of #TARGET_REF , which considers computer-based pronunciation by analogy but does not mention the possible application to text-to-speech synthesis . As detailed by #REF and #REF, PbA shares many similarities with the artificial intelligence paradigms variously called case-based, memory-based, or instance-based reasoning as applied to letter-to-phoneme conversion (#REF;#REF;#REF#REF#REF;#REF;van den #REF).",
        "output": "introduction:Pronunciation by analogy (PbA) is a data-driven technique for the automatic phonemization of text, originally proposed as a model of reading, e.g., by #REF and #REF. It was first proposed for TTS applications over a decade ago by Dedina andNusbaum (1986, 1991). See also the work of #TARGET_REF<BACKGROUND/> , which considers computer-based pronunciation by analogy but does not mention the possible application to text-to-speech synthesis . As detailed by #REF and #REF, PbA shares many similarities with the artificial intelligence paradigms variously called case-based, memory-based, or instance-based reasoning as applied to letter-to-phoneme conversion (#REF;#REF;#REF#REF#REF;#REF;van den #REF)."
    },
    {
        "gold": {
            "text": [
                "Clearly, the above characterization is very wide ranging.",
                "Consequently , fusion has been applied to a wide variety of pattern recognition and decision theoretic problems -- using a plethora of theories , techniques , and tools -- including some applications in computational linguistics ( e.g. , #TARGET_REF ; van Halteren , Zavrel , and #REF ) and speech technology ( e.g. , #REF ; #REF9 ) .",
                "According to Abbott (1999, 290), \"While the reasons [that] combining models works so well are not rigorously understood, there is ample evidence that improvements over single models are typical....",
                "A strong case can be made for combining models across algorithm families as a means of providing uncorrelated output estimates.\"",
                "Our purpose in this paper is to study and exploit such fusion by model (or strategy) combination as a way of achieving performance gains in PbA."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "experiments:Clearly, the above characterization is very wide ranging. Consequently , fusion has been applied to a wide variety of pattern recognition and decision theoretic problems -- using a plethora of theories , techniques , and tools -- including some applications in computational linguistics ( e.g. , #TARGET_REF ; van Halteren , Zavrel , and #REF ) and speech technology ( e.g. , #REF ; #REF9 ) . According to Abbott (1999, 290), \"While the reasons [that] combining models works so well are not rigorously understood, there is ample evidence that improvements over single models are typical.... A strong case can be made for combining models across algorithm families as a means of providing uncorrelated output estimates.\" Our purpose in this paper is to study and exploit such fusion by model (or strategy) combination as a way of achieving performance gains in PbA.",
        "output": "experiments:Clearly, the above characterization is very wide ranging. Consequently , fusion has been applied to a wide variety of pattern recognition and decision theoretic problems -- using a plethora of theories , techniques , and tools -- including some applications in computational linguistics ( e.g. , #TARGET_REF<BACKGROUND/> ; van Halteren , Zavrel , and #REF ) and speech technology ( e.g. , #REF ; #REF9 ) . According to Abbott (1999, 290), \"While the reasons [that] combining models works so well are not rigorously understood, there is ample evidence that improvements over single models are typical.... A strong case can be made for combining models across algorithm families as a means of providing uncorrelated output estimates.\" Our purpose in this paper is to study and exploit such fusion by model (or strategy) combination as a way of achieving performance gains in PbA."
    },
    {
        "gold": {
            "text": [
                "Many researchers have proposed greedy algorithms for estimating nonprobabilistic word-to-word translation models, also known as translation lexicons (e.g., Catizone, Russell, and #REF; #REF; #REF; #REF; #TARGET_REF 1995; #REF).",
                "Most of these algorithms can be summarized as follows:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Many researchers have proposed greedy algorithms for estimating nonprobabilistic word-to-word translation models, also known as translation lexicons (e.g., Catizone, Russell, and #REF; #REF; #REF; #REF; #TARGET_REF 1995; #REF). Most of these algorithms can be summarized as follows:",
        "output": "nan:Many researchers have proposed greedy algorithms for estimating nonprobabilistic word-to-word translation models, also known as translation lexicons (e.g., Catizone, Russell, and #REF; #REF; #REF; #REF; #TARGET_REF<BACKGROUND/> 1995; #REF). Most of these algorithms can be summarized as follows:"
    },
    {
        "gold": {
            "text": [
                "Most probabilistic translation model reestimation algorithms published to date are variations on the theme proposed by #TARGET_REFb ) .",
                "These models involve conditional probabilities, but they can be compared to symmetric models if the latter are normalized by the appropriate marginal distribution.",
                "I shall review these models using the notation in Table 1."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Most probabilistic translation model reestimation algorithms published to date are variations on the theme proposed by #TARGET_REFb ) . These models involve conditional probabilities, but they can be compared to symmetric models if the latter are normalized by the appropriate marginal distribution. I shall review these models using the notation in Table 1.",
        "output": "related work:Most probabilistic translation model reestimation algorithms published to date are variations on the theme proposed by #TARGET_REF<BACKGROUND/>b ) . These models involve conditional probabilities, but they can be compared to symmetric models if the latter are normalized by the appropriate marginal distribution. I shall review these models using the notation in Table 1."
    },
    {
        "gold": {
            "text": [
                "The probability distribution trans (.1, ~) is a word-to-word translation model.",
                "Unlike the models proposed by #TARGET_REFb ) , this model is symmetric , because both word bags are generated together from a joint probability distribution .",
                "Brown and his colleagues' models, reviewed in Section 4.3, generate one half of the bitext given the other hall so they are represented by conditional probability distributions.",
                "A sequenceto-sequence translation model can be obtained from a word-to-word translation model by combining Equation 11 with order information as in Equation 8."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:The probability distribution trans (.1, ~) is a word-to-word translation model. Unlike the models proposed by #TARGET_REFb ) , this model is symmetric , because both word bags are generated together from a joint probability distribution . Brown and his colleagues' models, reviewed in Section 4.3, generate one half of the bitext given the other hall so they are represented by conditional probability distributions. A sequenceto-sequence translation model can be obtained from a word-to-word translation model by combining Equation 11 with order information as in Equation 8.",
        "output": "method:The probability distribution trans (.1, ~) is a word-to-word translation model. Unlike the models proposed by #TARGET_REF<USE/>b ) , this model is symmetric , because both word bags are generated together from a joint probability distribution . Brown and his colleagues' models, reviewed in Section 4.3, generate one half of the bitext given the other hall so they are represented by conditional probability distributions. A sequenceto-sequence translation model can be obtained from a word-to-word translation model by combining Equation 11 with order information as in Equation 8."
    },
    {
        "gold": {
            "text": [
                "in bitext space is another kind of collocation.",
                "If each word 's translation is treated as a sense tag ( #TARGET_REF ) , then `` translational '' collocations have the unique property that the collocate and the word sense are one and the same !",
                "Method B exploits this property under the hypothesis that \"one sense per collocation\" holds for translational collocations.",
                "This hypothesis implies that if u and v are possible mutual translations, and a token u co-occurs with a token v in the bitext, then with very high probability the pair (u, v) was generated from the same concept and should be linked.",
                "To test this hypothesis, I ran one iteration of Method A on 300,000 aligned sentence pairs from the Canadian Hansards bitext.",
                "I then plotted the links (u,v) ratio ~ for several values of cooc (u, v) in Figure 2. The curves show that the ratio links (u,v) cooc (u,v) tends to be either very high or very low.",
                "This bimodality is not an artifact of the competitive linking process, because in the first iteration, linking decisions are based only on the initial similarity metric."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:in bitext space is another kind of collocation. If each word 's translation is treated as a sense tag ( #TARGET_REF ) , then `` translational '' collocations have the unique property that the collocate and the word sense are one and the same ! Method B exploits this property under the hypothesis that \"one sense per collocation\" holds for translational collocations. This hypothesis implies that if u and v are possible mutual translations, and a token u co-occurs with a token v in the bitext, then with very high probability the pair (u, v) was generated from the same concept and should be linked. To test this hypothesis, I ran one iteration of Method A on 300,000 aligned sentence pairs from the Canadian Hansards bitext. I then plotted the links (u,v) ratio ~ for several values of cooc (u, v) in Figure 2. The curves show that the ratio links (u,v) cooc (u,v) tends to be either very high or very low. This bimodality is not an artifact of the competitive linking process, because in the first iteration, linking decisions are based only on the initial similarity metric.",
        "output": "nan:in bitext space is another kind of collocation. If each word 's translation is treated as a sense tag ( #TARGET_REF<FUTURE/> ) , then `` translational '' collocations have the unique property that the collocate and the word sense are one and the same ! Method B exploits this property under the hypothesis that \"one sense per collocation\" holds for translational collocations. This hypothesis implies that if u and v are possible mutual translations, and a token u co-occurs with a token v in the bitext, then with very high probability the pair (u, v) was generated from the same concept and should be linked. To test this hypothesis, I ran one iteration of Method A on 300,000 aligned sentence pairs from the Canadian Hansards bitext. I then plotted the links (u,v) ratio ~ for several values of cooc (u, v) in Figure 2. The curves show that the ratio links (u,v) cooc (u,v) tends to be either very high or very low. This bimodality is not an artifact of the competitive linking process, because in the first iteration, linking decisions are based only on the initial similarity metric."
    },
    {
        "gold": {
            "text": [
                "In informal experiments described elsewhere ( #TARGET_REF ) , I found that the G2 statistic suggested by #REF slightly outperforms 02 .",
                "Let the cells of the contingency table be named as follows:"
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "nan:In informal experiments described elsewhere ( #TARGET_REF ) , I found that the G2 statistic suggested by #REF slightly outperforms 02 . Let the cells of the contingency table be named as follows:",
        "output": "nan:In informal experiments described elsewhere ( #TARGET_REF<COMPARISON/> ) , I found that the G2 statistic suggested by #REF slightly outperforms 02 . Let the cells of the contingency table be named as follows:"
    },
    {
        "gold": {
            "text": [
                "â¢ cross-language information retrieval ( e.g. , #REF ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #TARGET_REF ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:â¢ cross-language information retrieval ( e.g. , #REF ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #TARGET_REF ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,",
        "output": "method:â¢ cross-language information retrieval ( e.g. , #REF ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #TARGET_REF<BACKGROUND/> ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,"
    },
    {
        "gold": {
            "text": [
                "In this situation , #TARGET_REFb , 293 ) recommend `` evaluating the expectations using only a single , probable alignment . ''",
                "The single most probable assignment Ama~ is the maximum a posteriori (MAP) assignment:"
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:In this situation , #TARGET_REFb , 293 ) recommend `` evaluating the expectations using only a single , probable alignment . '' The single most probable assignment Ama~ is the maximum a posteriori (MAP) assignment:",
        "output": "nan:In this situation , #TARGET_REF<EXTENSION/>b , 293 ) recommend `` evaluating the expectations using only a single , probable alignment . '' The single most probable assignment Ama~ is the maximum a posteriori (MAP) assignment:"
    },
    {
        "gold": {
            "text": [
                "All word pairs that co-occur the same number of times and are linked the same number of times are assigned the same score.",
                "More accurate models can be induced by taking into account various features of the linked tokens.",
                "For example, frequent words are translated less consistently than rare words (Catizone, Russell, and #REF).",
                "To account for these differences, we can estimate separate values of A + and A-for different ranges of cooc (u, v).",
                "Similarly, the auxiliary parameters can be conditioned on the linked parts of speech.",
                "A kind of word order correlation bias can be effected by conditioning the auxiliary parameters on the relative positions of linked word tokens in their respective texts.",
                "Just as easily , we can model link types that coincide with entries in an on-line bilingual dictionary separately from those that do not ( cfXXX #TARGET_REF ) .",
                "#REF).",
                "When the auxiliary parameters are conditioned on different link classes, their optimization is carried out separately for each class: B (links (u, v)[cooc(u, v), A +) scorec (u, vlZ = class(u, v)) = log B(links(u, v)[cooc(u, v), A z)\" (37) Section 6.1.1 describes the link classes used in the experiments below."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:All word pairs that co-occur the same number of times and are linked the same number of times are assigned the same score. More accurate models can be induced by taking into account various features of the linked tokens. For example, frequent words are translated less consistently than rare words (Catizone, Russell, and #REF). To account for these differences, we can estimate separate values of A + and A-for different ranges of cooc (u, v). Similarly, the auxiliary parameters can be conditioned on the linked parts of speech. A kind of word order correlation bias can be effected by conditioning the auxiliary parameters on the relative positions of linked word tokens in their respective texts. Just as easily , we can model link types that coincide with entries in an on-line bilingual dictionary separately from those that do not ( cfXXX #TARGET_REF ) . #REF). When the auxiliary parameters are conditioned on different link classes, their optimization is carried out separately for each class: B (links (u, v)[cooc(u, v), A +) scorec (u, vlZ = class(u, v)) = log B(links(u, v)[cooc(u, v), A z)\" (37) Section 6.1.1 describes the link classes used in the experiments below.",
        "output": "nan:All word pairs that co-occur the same number of times and are linked the same number of times are assigned the same score. More accurate models can be induced by taking into account various features of the linked tokens. For example, frequent words are translated less consistently than rare words (Catizone, Russell, and #REF). To account for these differences, we can estimate separate values of A + and A-for different ranges of cooc (u, v). Similarly, the auxiliary parameters can be conditioned on the linked parts of speech. A kind of word order correlation bias can be effected by conditioning the auxiliary parameters on the relative positions of linked word tokens in their respective texts. Just as easily , we can model link types that coincide with entries in an on-line bilingual dictionary separately from those that do not ( cfXXX #TARGET_REF<FUTURE/> ) . #REF). When the auxiliary parameters are conditioned on different link classes, their optimization is carried out separately for each class: B (links (u, v)[cooc(u, v), A +) scorec (u, vlZ = class(u, v)) = log B(links(u, v)[cooc(u, v), A z)\" (37) Section 6.1.1 describes the link classes used in the experiments below."
    },
    {
        "gold": {
            "text": [
                "Until now , translation models have been evaluated either subjectively ( e.g. White and O'#REF ) or using relative metrics , such as perplexity with respect to other models ( #TARGET_REFb ) .",
                "Objective and more accurate tests can be carried out using a \"gold standard.\"",
                "I hired bilingual annotators to link roughly 16,000 corresponding words between on-line versions of the Bible in French and English.",
                "This bitext was selected to facilitate widespread use and standardization (see Melamed [1998c] for details).",
                "The entire Bible bitext comprised 29,614 verse pairs, of which 250 verse pairs were hand-linked using a specially developed annotation tool.",
                "The annotation style guide (#REFb) was based on the intuitions of the annotators, so it was not biased towards any particular translation model.",
                "The annotation was replicated five times by seven different annotators."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:Until now , translation models have been evaluated either subjectively ( e.g. White and O'#REF ) or using relative metrics , such as perplexity with respect to other models ( #TARGET_REFb ) . Objective and more accurate tests can be carried out using a \"gold standard.\" I hired bilingual annotators to link roughly 16,000 corresponding words between on-line versions of the Bible in French and English. This bitext was selected to facilitate widespread use and standardization (see Melamed [1998c] for details). The entire Bible bitext comprised 29,614 verse pairs, of which 250 verse pairs were hand-linked using a specially developed annotation tool. The annotation style guide (#REFb) was based on the intuitions of the annotators, so it was not biased towards any particular translation model. The annotation was replicated five times by seven different annotators.",
        "output": "nan:Until now , translation models have been evaluated either subjectively ( e.g. White and O'#REF ) or using relative metrics , such as perplexity with respect to other models ( #TARGET_REF<USE/>b ) . Objective and more accurate tests can be carried out using a \"gold standard.\" I hired bilingual annotators to link roughly 16,000 corresponding words between on-line versions of the Bible in French and English. This bitext was selected to facilitate widespread use and standardization (see Melamed [1998c] for details). The entire Bible bitext comprised 29,614 verse pairs, of which 250 verse pairs were hand-linked using a specially developed annotation tool. The annotation style guide (#REFb) was based on the intuitions of the annotators, so it was not biased towards any particular translation model. The annotation was replicated five times by seven different annotators."
    },
    {
        "gold": {
            "text": [
                "In informal experiments described elsewhere ( #REF ) , I found that the G2 statistic suggested by #TARGET_REF slightly outperforms 02 .",
                "Let the cells of the contingency table be named as follows:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:In informal experiments described elsewhere ( #REF ) , I found that the G2 statistic suggested by #TARGET_REF slightly outperforms 02 . Let the cells of the contingency table be named as follows:",
        "output": "nan:In informal experiments described elsewhere ( #REF ) , I found that the G2 statistic suggested by #TARGET_REF<BACKGROUND/> slightly outperforms 02 . Let the cells of the contingency table be named as follows:"
    },
    {
        "gold": {
            "text": [
                "The above equation holds regardless of how we represent concepts.",
                "There are many plausible representations , such as pairs of trees from synchronous tree adjoining grammars ( #REF ; #REF ; #TARGET_REF ) , lexical conceptual structures ( #REF ) and WordNet synsets ( #REF ; #REF ) .",
                "Of course, for a representation to be used, a method must exist for estimating its distribution in data."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:The above equation holds regardless of how we represent concepts. There are many plausible representations , such as pairs of trees from synchronous tree adjoining grammars ( #REF ; #REF ; #TARGET_REF ) , lexical conceptual structures ( #REF ) and WordNet synsets ( #REF ; #REF ) . Of course, for a representation to be used, a method must exist for estimating its distribution in data.",
        "output": "method:The above equation holds regardless of how we represent concepts. There are many plausible representations , such as pairs of trees from synchronous tree adjoining grammars ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) , lexical conceptual structures ( #REF ) and WordNet synsets ( #REF ; #REF ) . Of course, for a representation to be used, a method must exist for estimating its distribution in data."
    },
    {
        "gold": {
            "text": [
                "â¢ cross-language information retrieval ( e.g. , #TARGET_REF ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #REF ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:â¢ cross-language information retrieval ( e.g. , #TARGET_REF ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #REF ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,",
        "output": "method:â¢ cross-language information retrieval ( e.g. , #TARGET_REF<BACKGROUND/> ) , â¢ multilingual document filtering ( e.g. , #REF ) , â¢ computer-assisted language learning ( e.g. , #REF ) , â¢ certain machine-assisted translation tools ( e.g. , #REF ; #REFa ) , â¢ concordancing for bilingual lexicography ( e.g. , Catizone , Russell , and #REF ; #REF ) ,"
    },
    {
        "gold": {
            "text": [
                "Many other such cases are described in Danlos 's book ( #TARGET_REF ) .",
                "The common theme behind many of these examples is that pipelines have difficulties satisfying linguistic constraints (such as unambiguous reference) or performing linguistic optimizations (such as using pronouns instead of longer referring expressions whenever possible) in cases where the constraints or optimizations depend on decisions made in multiple modules.",
                "This is largely due to the fact that pipelined systems cannot perform general search over a decision space that includes decisions made in more than one module."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Many other such cases are described in Danlos 's book ( #TARGET_REF ) . The common theme behind many of these examples is that pipelines have difficulties satisfying linguistic constraints (such as unambiguous reference) or performing linguistic optimizations (such as using pronouns instead of longer referring expressions whenever possible) in cases where the constraints or optimizations depend on decisions made in multiple modules. This is largely due to the fact that pipelined systems cannot perform general search over a decision space that includes decisions made in more than one module.",
        "output": "introduction:Many other such cases are described in Danlos 's book ( #TARGET_REF<BACKGROUND/> ) . The common theme behind many of these examples is that pipelines have difficulties satisfying linguistic constraints (such as unambiguous reference) or performing linguistic optimizations (such as using pronouns instead of longer referring expressions whenever possible) in cases where the constraints or optimizations depend on decisions made in multiple modules. This is largely due to the fact that pipelined systems cannot perform general search over a decision space that includes decisions made in more than one module."
    },
    {
        "gold": {
            "text": [
                "Despite these arguments, most applied NLG systems use a pipelined architecture; indeed, a pipeline was used in every one of the systems surveyed by #REF and #REF.",
                "This may be because pipelines have many engineering advantages , and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Despite these arguments, most applied NLG systems use a pipelined architecture; indeed, a pipeline was used in every one of the systems surveyed by #REF and #REF. This may be because pipelines have many engineering advantages , and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems ( #TARGET_REF ) .",
        "output": "introduction:Despite these arguments, most applied NLG systems use a pipelined architecture; indeed, a pipeline was used in every one of the systems surveyed by #REF and #REF. This may be because pipelines have many engineering advantages , and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "Despite these arguments , most applied NLG systems use a pipelined architecture ; indeed , a pipeline was used in every one of the systems surveyed by #TARGET_REF and #REF .",
                "This may be because pipelines have many engineering advantages, and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems (#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Despite these arguments , most applied NLG systems use a pipelined architecture ; indeed , a pipeline was used in every one of the systems surveyed by #TARGET_REF and #REF . This may be because pipelines have many engineering advantages, and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems (#REF).",
        "output": "introduction:Despite these arguments , most applied NLG systems use a pipelined architecture ; indeed , a pipeline was used in every one of the systems surveyed by #TARGET_REF<BACKGROUND/> and #REF . This may be because pipelines have many engineering advantages, and in practice the sort of problems pointed out by Danlos and other pipeline critics do not seem to be a major problem in current applied NLG systems (#REF)."
    },
    {
        "gold": {
            "text": [
                "At first I found Chapters 4 through 8 slightly overwhelming, as they introduce several levels of representation, each with its own terminology and acronyms.",
                "However, at a second, more-careful, reading, everything falls into place.",
                "The resulting approach has at its center a lexicon that partly implements current theories of lexical semantics such as Jackendoff's (1990) and Levin's (1993).",
                "The lexicon is used to mediate and map between a language-independent domain model and a language-dependent ontology widely used in NLG , the Upper Model ( #TARGET_REF ) .",
                "Although the idea of a two-level representation accommodating language-neutral and language-specific requirements is not new (see for example Nirenburg and Levin [1992], Dorr and Voss [1993], and Di Eugenio [1998]), Stede is among the few who make effective use of those two levels in a complex system."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:At first I found Chapters 4 through 8 slightly overwhelming, as they introduce several levels of representation, each with its own terminology and acronyms. However, at a second, more-careful, reading, everything falls into place. The resulting approach has at its center a lexicon that partly implements current theories of lexical semantics such as Jackendoff's (1990) and Levin's (1993). The lexicon is used to mediate and map between a language-independent domain model and a language-dependent ontology widely used in NLG , the Upper Model ( #TARGET_REF ) . Although the idea of a two-level representation accommodating language-neutral and language-specific requirements is not new (see for example Nirenburg and Levin [1992], Dorr and Voss [1993], and Di Eugenio [1998]), Stede is among the few who make effective use of those two levels in a complex system.",
        "output": "nan:At first I found Chapters 4 through 8 slightly overwhelming, as they introduce several levels of representation, each with its own terminology and acronyms. However, at a second, more-careful, reading, everything falls into place. The resulting approach has at its center a lexicon that partly implements current theories of lexical semantics such as Jackendoff's (1990) and Levin's (1993). The lexicon is used to mediate and map between a language-independent domain model and a language-dependent ontology widely used in NLG , the Upper Model ( #TARGET_REF<BACKGROUND/> ) . Although the idea of a two-level representation accommodating language-neutral and language-specific requirements is not new (see for example Nirenburg and Levin [1992], Dorr and Voss [1993], and Di Eugenio [1998]), Stede is among the few who make effective use of those two levels in a complex system."
    },
    {
        "gold": {
            "text": [
                "Shortly after the publication of The Sound Pattern of English ( #REF ) , Kornai points out , `` #REF demonstrated that the context-sensitive machinery of SPE ... [ could ] be replaced by a much simpler one , based on finite-state transducers ( FSTs ) ; the same conclusion was reached independently by Kaplan and Kay , whose work remained an underground classic until it was finally published in #TARGET_REF . ''",
                "These works inspired Koskenniemi's two-level system, and the Xerox rule compiler (#REF).",
                "Both are now dominant tools in the fields of computational phonology and morphology, as exemplified by Tateno et al. (Chapter 6), \"The Japanese lexical transducer based on stem-suffix style forms\" and Kim and Jang (Chapter 7), \"Acquiring rules for reducing morphological ambiguity from POS tagged corpus in Korean.\"",
                "The latter includes an algorithm for automatically inferring regular grammar rules for morphological relations directly from part-of-speech tagged corpora."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Shortly after the publication of The Sound Pattern of English ( #REF ) , Kornai points out , `` #REF demonstrated that the context-sensitive machinery of SPE ... [ could ] be replaced by a much simpler one , based on finite-state transducers ( FSTs ) ; the same conclusion was reached independently by Kaplan and Kay , whose work remained an underground classic until it was finally published in #TARGET_REF . '' These works inspired Koskenniemi's two-level system, and the Xerox rule compiler (#REF). Both are now dominant tools in the fields of computational phonology and morphology, as exemplified by Tateno et al. (Chapter 6), \"The Japanese lexical transducer based on stem-suffix style forms\" and Kim and Jang (Chapter 7), \"Acquiring rules for reducing morphological ambiguity from POS tagged corpus in Korean.\" The latter includes an algorithm for automatically inferring regular grammar rules for morphological relations directly from part-of-speech tagged corpora.",
        "output": "nan:Shortly after the publication of The Sound Pattern of English ( #REF ) , Kornai points out , `` #REF demonstrated that the context-sensitive machinery of SPE ... [ could ] be replaced by a much simpler one , based on finite-state transducers ( FSTs ) ; the same conclusion was reached independently by Kaplan and Kay , whose work remained an underground classic until it was finally published in #TARGET_REF<BACKGROUND/> . '' These works inspired Koskenniemi's two-level system, and the Xerox rule compiler (#REF). Both are now dominant tools in the fields of computational phonology and morphology, as exemplified by Tateno et al. (Chapter 6), \"The Japanese lexical transducer based on stem-suffix style forms\" and Kim and Jang (Chapter 7), \"Acquiring rules for reducing morphological ambiguity from POS tagged corpus in Korean.\" The latter includes an algorithm for automatically inferring regular grammar rules for morphological relations directly from part-of-speech tagged corpora."
    },
    {
        "gold": {
            "text": [
                "OT therefore holds out the promise of simplifying grammars , by factoring all complex phenomena into simple surface-level constraints that partially mask one another .1 Whether this is always possible under an appropriate definition of \"simple constraints\" ( e.g. , #TARGET_REFb ) is of course an empirical question ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:OT therefore holds out the promise of simplifying grammars , by factoring all complex phenomena into simple surface-level constraints that partially mask one another .1 Whether this is always possible under an appropriate definition of \"simple constraints\" ( e.g. , #TARGET_REFb ) is of course an empirical question .",
        "output": "introduction:OT therefore holds out the promise of simplifying grammars , by factoring all complex phenomena into simple surface-level constraints that partially mask one another .1 Whether this is always possible under an appropriate definition of \"simple constraints\" ( e.g. , #TARGET_REF<BACKGROUND/>b ) is of course an empirical question ."
    },
    {
        "gold": {
            "text": [
                "Second, weights are an annoyance when writing grammars by hand.",
                "In some cases rankings may work well enough.",
                "#TARGET_REF report excellent part-of-speech tagging results using a handcrafted approach that is close to OT .3 More speculatively , imagine an OT grammar for stylistic revision of parsed sentences .",
                "The tension between preserving the original author's text (faithfulness to the underlying form) and making it readable in various ways (well-formedness) is right up OT's alley.",
                "The same applies to document layout: I have often wished I could write OT-style TeX macros~ Third, even in statistical corpus-based NLP, estimating a full Gibbs distribution is not always feasible.",
                "Even if strict ranking is not quite accurate, sparse data or the complexity of parameter estimation may make it easier to learn a good OT grammar than a good arbitrary Gibbs model.",
                "A well-known example is Yarowsky's (1996) work on word sense disambiguation using decision lists (a kind of OT grammar).",
                "Although decision lists are not very powerful because of their simple output space, they have the characteristic OT property that each generalization partially masks lower-ranked generalizations."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Second, weights are an annoyance when writing grammars by hand. In some cases rankings may work well enough. #TARGET_REF report excellent part-of-speech tagging results using a handcrafted approach that is close to OT .3 More speculatively , imagine an OT grammar for stylistic revision of parsed sentences . The tension between preserving the original author's text (faithfulness to the underlying form) and making it readable in various ways (well-formedness) is right up OT's alley. The same applies to document layout: I have often wished I could write OT-style TeX macros~ Third, even in statistical corpus-based NLP, estimating a full Gibbs distribution is not always feasible. Even if strict ranking is not quite accurate, sparse data or the complexity of parameter estimation may make it easier to learn a good OT grammar than a good arbitrary Gibbs model. A well-known example is Yarowsky's (1996) work on word sense disambiguation using decision lists (a kind of OT grammar). Although decision lists are not very powerful because of their simple output space, they have the characteristic OT property that each generalization partially masks lower-ranked generalizations.",
        "output": "nan:Second, weights are an annoyance when writing grammars by hand. In some cases rankings may work well enough. #TARGET_REF<BACKGROUND/> report excellent part-of-speech tagging results using a handcrafted approach that is close to OT .3 More speculatively , imagine an OT grammar for stylistic revision of parsed sentences . The tension between preserving the original author's text (faithfulness to the underlying form) and making it readable in various ways (well-formedness) is right up OT's alley. The same applies to document layout: I have often wished I could write OT-style TeX macros~ Third, even in statistical corpus-based NLP, estimating a full Gibbs distribution is not always feasible. Even if strict ranking is not quite accurate, sparse data or the complexity of parameter estimation may make it easier to learn a good OT grammar than a good arbitrary Gibbs model. A well-known example is Yarowsky's (1996) work on word sense disambiguation using decision lists (a kind of OT grammar). Although decision lists are not very powerful because of their simple output space, they have the characteristic OT property that each generalization partially masks lower-ranked generalizations."
    },
    {
        "gold": {
            "text": [
                "For example, consider the relevance to hidden Markov models (HMMs), another restricted class of Gibbs distributions used in speech recognition or part-of-speech tagging.",
                "Just like OT grammars, HMM Viterbi decoders are functions that pick the optimal output from ~', based on criteria of well-formedness (transition probabilities) and faithfulness to the input (emission probabilities).",
                "But typical OT grammars offer much richer finite-state models of left context ( #TARGET_REFa ) than provided by the traditional HMM finite-state topologies .",
                "Now, among methods that use a Gibbs distribution to choose among linguistic forms, OT generation is special in that the distribution ranks the features strictly, rather than weighting them in a gentler way that allows tradeoffs.",
                "When is this appropriate?",
                "It seems to me that there are three possible uses."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:For example, consider the relevance to hidden Markov models (HMMs), another restricted class of Gibbs distributions used in speech recognition or part-of-speech tagging. Just like OT grammars, HMM Viterbi decoders are functions that pick the optimal output from ~', based on criteria of well-formedness (transition probabilities) and faithfulness to the input (emission probabilities). But typical OT grammars offer much richer finite-state models of left context ( #TARGET_REFa ) than provided by the traditional HMM finite-state topologies . Now, among methods that use a Gibbs distribution to choose among linguistic forms, OT generation is special in that the distribution ranks the features strictly, rather than weighting them in a gentler way that allows tradeoffs. When is this appropriate? It seems to me that there are three possible uses.",
        "output": "nan:For example, consider the relevance to hidden Markov models (HMMs), another restricted class of Gibbs distributions used in speech recognition or part-of-speech tagging. Just like OT grammars, HMM Viterbi decoders are functions that pick the optimal output from ~', based on criteria of well-formedness (transition probabilities) and faithfulness to the input (emission probabilities). But typical OT grammars offer much richer finite-state models of left context ( #TARGET_REF<BACKGROUND/>a ) than provided by the traditional HMM finite-state topologies . Now, among methods that use a Gibbs distribution to choose among linguistic forms, OT generation is special in that the distribution ranks the features strictly, rather than weighting them in a gentler way that allows tradeoffs. When is this appropriate? It seems to me that there are three possible uses."
    },
    {
        "gold": {
            "text": [
                "Our original question concerned the extent to which recall and precision are influenced by the size of the window.",
                "It turns out, however, that a preliminary question needs to be answered first, namely, how to gauge the significance of the large effect of the lowest-frequency words on recall, precision, and the number of words extracted as potentially relevant terms.",
                "It is common practice in information retrieval to discard the lowest-frequency words a priori as nonsignificant (#REF).",
                "In Smadja's collocation algorithm Xtract, the lowest-frequency words are effectively discarded as well (#REF).",
                "#TARGET_REF use mutual information to identify collocations , a method they claim is reasonably effective for words with a frequency of not less than five ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Our original question concerned the extent to which recall and precision are influenced by the size of the window. It turns out, however, that a preliminary question needs to be answered first, namely, how to gauge the significance of the large effect of the lowest-frequency words on recall, precision, and the number of words extracted as potentially relevant terms. It is common practice in information retrieval to discard the lowest-frequency words a priori as nonsignificant (#REF). In Smadja's collocation algorithm Xtract, the lowest-frequency words are effectively discarded as well (#REF). #TARGET_REF use mutual information to identify collocations , a method they claim is reasonably effective for words with a frequency of not less than five .",
        "output": "introduction:Our original question concerned the extent to which recall and precision are influenced by the size of the window. It turns out, however, that a preliminary question needs to be answered first, namely, how to gauge the significance of the large effect of the lowest-frequency words on recall, precision, and the number of words extracted as potentially relevant terms. It is common practice in information retrieval to discard the lowest-frequency words a priori as nonsignificant (#REF). In Smadja's collocation algorithm Xtract, the lowest-frequency words are effectively discarded as well (#REF). #TARGET_REF<BACKGROUND/> use mutual information to identify collocations , a method they claim is reasonably effective for words with a frequency of not less than five ."
    },
    {
        "gold": {
            "text": [
                "The extraction results for both tests as measured by F are 0.31 and 0.33, respectively.",
                "This procedure allows us to extract 64/139 = 46.0% of the lowfrequency words and 66/170 -~ 38.8% of the high-frequency words using G 2, and 64/139 = 46.0%",
                "and 79/170 = 46.7%,",
                "respectively, using Fisher's exact test.",
                "Note that this technique is optimal for the extraction of the lowest-frequency words, leading to identical performance for G 2 and Fisher's exact test for these words.",
                "For the higherfrequency words, Fisher's exact test leads to a slightly better recall with the same precision scores (0.31 for both tests).",
                "While we have observed reasonable results with both G2 and Fisher 's exact test , we have not yet discussed how these results compare to the results that can be obtained with a technique commonly used in corpus linguistics based on the mutual information ( MI ) measure ( #TARGET_REF ) :"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:The extraction results for both tests as measured by F are 0.31 and 0.33, respectively. This procedure allows us to extract 64/139 = 46.0% of the lowfrequency words and 66/170 -~ 38.8% of the high-frequency words using G 2, and 64/139 = 46.0% and 79/170 = 46.7%, respectively, using Fisher's exact test. Note that this technique is optimal for the extraction of the lowest-frequency words, leading to identical performance for G 2 and Fisher's exact test for these words. For the higherfrequency words, Fisher's exact test leads to a slightly better recall with the same precision scores (0.31 for both tests). While we have observed reasonable results with both G2 and Fisher 's exact test , we have not yet discussed how these results compare to the results that can be obtained with a technique commonly used in corpus linguistics based on the mutual information ( MI ) measure ( #TARGET_REF ) :",
        "output": "conclusion:The extraction results for both tests as measured by F are 0.31 and 0.33, respectively. This procedure allows us to extract 64/139 = 46.0% of the lowfrequency words and 66/170 -~ 38.8% of the high-frequency words using G 2, and 64/139 = 46.0% and 79/170 = 46.7%, respectively, using Fisher's exact test. Note that this technique is optimal for the extraction of the lowest-frequency words, leading to identical performance for G 2 and Fisher's exact test for these words. For the higherfrequency words, Fisher's exact test leads to a slightly better recall with the same precision scores (0.31 for both tests). While we have observed reasonable results with both G2 and Fisher 's exact test , we have not yet discussed how these results compare to the results that can be obtained with a technique commonly used in corpus linguistics based on the mutual information ( MI ) measure ( #TARGET_REF<BACKGROUND/> ) :"
    },
    {
        "gold": {
            "text": [
                "However, what matters in engineering practice is the average case for a specific grammar.",
                "Specific, since a specific grammar belonging to a high complexity class may well prove to parse much faster than the worst grammar of its class, even with the general algorithm, if the possible time-consuming behavior of the algorithm never happens for this grammar.",
                "Average, since it can happen that the grammar does admit hard-toparse sentences that are not used (or at least not frequently used) in the real corpus.",
                "For example , #TARGET_REF proves that Chinese numerals such as wu zhao zhao zhao zhao zhao wu zhao zhao zhao zhao wu zhao zhao zhao wu zhao zhao wu zhao , for the number 5000000000000000005000000000000005000000000005000000005000 , are not context-free , which implies that Chinese is not a context-free language and thus might parse in exponential worst-case time ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:However, what matters in engineering practice is the average case for a specific grammar. Specific, since a specific grammar belonging to a high complexity class may well prove to parse much faster than the worst grammar of its class, even with the general algorithm, if the possible time-consuming behavior of the algorithm never happens for this grammar. Average, since it can happen that the grammar does admit hard-toparse sentences that are not used (or at least not frequently used) in the real corpus. For example , #TARGET_REF proves that Chinese numerals such as wu zhao zhao zhao zhao zhao wu zhao zhao zhao zhao wu zhao zhao zhao wu zhao zhao wu zhao , for the number 5000000000000000005000000000000005000000000005000000005000 , are not context-free , which implies that Chinese is not a context-free language and thus might parse in exponential worst-case time .",
        "output": "nan:However, what matters in engineering practice is the average case for a specific grammar. Specific, since a specific grammar belonging to a high complexity class may well prove to parse much faster than the worst grammar of its class, even with the general algorithm, if the possible time-consuming behavior of the algorithm never happens for this grammar. Average, since it can happen that the grammar does admit hard-toparse sentences that are not used (or at least not frequently used) in the real corpus. For example , #TARGET_REF<BACKGROUND/> proves that Chinese numerals such as wu zhao zhao zhao zhao zhao wu zhao zhao zhao zhao wu zhao zhao zhao wu zhao zhao wu zhao , for the number 5000000000000000005000000000000005000000000005000000005000 , are not context-free , which implies that Chinese is not a context-free language and thus might parse in exponential worst-case time ."
    },
    {
        "gold": {
            "text": [
                "The particular analysis-level style markers can be calculated only when this specific computational tool is utilized.",
                "However, the SCBD is a general-purpose tool and was not designed for providing stylistic information exclusively.",
                "Thus, any NLP tool (e.g., part-of-speech taggers, parsers, etc.) can provide similar measures.",
                "The appropriate analysis-level style markers have to be defined according to the methodology used by the tool in order to analyze the text.",
                "For example , some similar measures have been used in stylistic experiments in information retrieval on the basis of a robust parser built for information retrieval purposes ( #TARGET_REF ) .",
                "This parser produces trees to represent the structure of the sentences that compose the text.",
                "However, it is set to \"skip\" or surrender attempts to parse clauses after reaching a time-out threshold.",
                "When the parser skips, it notes that in the parse tree.",
                "The measures proposed by #REF as indicators of clausal complexity are the average parse tree depth and the number of parser skips per sentence, which in essence are analysis-level style markers."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "method:The particular analysis-level style markers can be calculated only when this specific computational tool is utilized. However, the SCBD is a general-purpose tool and was not designed for providing stylistic information exclusively. Thus, any NLP tool (e.g., part-of-speech taggers, parsers, etc.) can provide similar measures. The appropriate analysis-level style markers have to be defined according to the methodology used by the tool in order to analyze the text. For example , some similar measures have been used in stylistic experiments in information retrieval on the basis of a robust parser built for information retrieval purposes ( #TARGET_REF ) . This parser produces trees to represent the structure of the sentences that compose the text. However, it is set to \"skip\" or surrender attempts to parse clauses after reaching a time-out threshold. When the parser skips, it notes that in the parse tree. The measures proposed by #REF as indicators of clausal complexity are the average parse tree depth and the number of parser skips per sentence, which in essence are analysis-level style markers.",
        "output": "method:The particular analysis-level style markers can be calculated only when this specific computational tool is utilized. However, the SCBD is a general-purpose tool and was not designed for providing stylistic information exclusively. Thus, any NLP tool (e.g., part-of-speech taggers, parsers, etc.) can provide similar measures. The appropriate analysis-level style markers have to be defined according to the methodology used by the tool in order to analyze the text. For example , some similar measures have been used in stylistic experiments in information retrieval on the basis of a robust parser built for information retrieval purposes ( #TARGET_REF<BACKGROUND/> ) . This parser produces trees to represent the structure of the sentences that compose the text. However, it is set to \"skip\" or surrender attempts to parse clauses after reaching a time-out threshold. When the parser skips, it notes that in the parse tree. The measures proposed by #REF as indicators of clausal complexity are the average parse tree depth and the number of parser skips per sentence, which in essence are analysis-level style markers."
    },
    {
        "gold": {
            "text": [
                "where Cx is the covariance matrix of x.",
                "Using this classification method we can also derive the probability that a case belongs to a particular group (i.e., posterior probabilities), which is roughly proportional to the Mahalanobis distance from that group centroid.",
                "Discriminant analysis has been employed by researchers in automatic text genre detection ( #TARGET_REFb ; #REF ) since it offers a simple and robust solution despite the fact that it presupposes normal distributions of the discriminating variables ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:where Cx is the covariance matrix of x. Using this classification method we can also derive the probability that a case belongs to a particular group (i.e., posterior probabilities), which is roughly proportional to the Mahalanobis distance from that group centroid. Discriminant analysis has been employed by researchers in automatic text genre detection ( #TARGET_REFb ; #REF ) since it offers a simple and robust solution despite the fact that it presupposes normal distributions of the discriminating variables .",
        "output": "nan:where Cx is the covariance matrix of x. Using this classification method we can also derive the probability that a case belongs to a particular group (i.e., posterior probabilities), which is roughly proportional to the Mahalanobis distance from that group centroid. Discriminant analysis has been employed by researchers in automatic text genre detection ( #TARGET_REF<BACKGROUND/>b ; #REF ) since it offers a simple and robust solution despite the fact that it presupposes normal distributions of the discriminating variables ."
    },
    {
        "gold": {
            "text": [
                "The algorithm we implemented is inspired by the work of #TARGET_REF on word sense disambiguation .",
                "He classified the senses of a word on the basis of other words that the given word co-occurs with.",
                "#REF"
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:The algorithm we implemented is inspired by the work of #TARGET_REF on word sense disambiguation . He classified the senses of a word on the basis of other words that the given word co-occurs with. #REF",
        "output": "nan:The algorithm we implemented is inspired by the work of #TARGET_REF<EXTENSION/> on word sense disambiguation . He classified the senses of a word on the basis of other words that the given word co-occurs with. #REF"
    },
    {
        "gold": {
            "text": [
                "The automatic annotation of nouns and verbs in the corpus has been done by matching them with the WordNet database files.",
                "Before doing the annotation, though, some preprocessing of the data was required to maximize the matching between our corpus and WordNet.",
                "The changes made were inspired by those described in #TARGET_REF , page 75 ) .",
                "To lemmatize the words we used �morpha,� a lemmatizer developed by John A. Carroll and freely available at the address: http://www.informatics.susx.ac.uk./research/nlp/carroll/morph.html.",
                "Upon simple observation, it showed a better performance than the frequently used Porter Stemmer for this task."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "method:The automatic annotation of nouns and verbs in the corpus has been done by matching them with the WordNet database files. Before doing the annotation, though, some preprocessing of the data was required to maximize the matching between our corpus and WordNet. The changes made were inspired by those described in #TARGET_REF , page 75 ) . To lemmatize the words we used �morpha,� a lemmatizer developed by John A. Carroll and freely available at the address: http://www.informatics.susx.ac.uk./research/nlp/carroll/morph.html. Upon simple observation, it showed a better performance than the frequently used Porter Stemmer for this task.",
        "output": "method:The automatic annotation of nouns and verbs in the corpus has been done by matching them with the WordNet database files. Before doing the annotation, though, some preprocessing of the data was required to maximize the matching between our corpus and WordNet. The changes made were inspired by those described in #TARGET_REF<EXTENSION/> , page 75 ) . To lemmatize the words we used �morpha,� a lemmatizer developed by John A. Carroll and freely available at the address: http://www.informatics.susx.ac.uk./research/nlp/carroll/morph.html. Upon simple observation, it showed a better performance than the frequently used Porter Stemmer for this task."
    },
    {
        "gold": {
            "text": [
                "In Section 2 we describe our general framework of the generic beam-search algorithm and the generalized perceptron.",
                "Then in the subsequent sections we describe each task in turn, based on conference papers including Zhang and Clark (2007, 2008a, 2008b, presented in our single coherent framework.",
                "We give an updated set of results, plus a number of additional experiments which probe further into the advantages and disadvantages of our framework.",
                "For the segmentation task, we also compare our beam-search framework with alternative decoding algorithms including an exact dynamic-programming method, showing that the beam-search method is significantly faster with comparable accuracy.",
                "For the joint segmentation and POS-tagging task , we present a novel solution using the framework in this article , and show that it gives comparable accuracies to our previous work ( #TARGET_REFa ) , while being more than an order of magnitude faster ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:In Section 2 we describe our general framework of the generic beam-search algorithm and the generalized perceptron. Then in the subsequent sections we describe each task in turn, based on conference papers including Zhang and Clark (2007, 2008a, 2008b, presented in our single coherent framework. We give an updated set of results, plus a number of additional experiments which probe further into the advantages and disadvantages of our framework. For the segmentation task, we also compare our beam-search framework with alternative decoding algorithms including an exact dynamic-programming method, showing that the beam-search method is significantly faster with comparable accuracy. For the joint segmentation and POS-tagging task , we present a novel solution using the framework in this article , and show that it gives comparable accuracies to our previous work ( #TARGET_REFa ) , while being more than an order of magnitude faster .",
        "output": "introduction:In Section 2 we describe our general framework of the generic beam-search algorithm and the generalized perceptron. Then in the subsequent sections we describe each task in turn, based on conference papers including Zhang and Clark (2007, 2008a, 2008b, presented in our single coherent framework. We give an updated set of results, plus a number of additional experiments which probe further into the advantages and disadvantages of our framework. For the segmentation task, we also compare our beam-search framework with alternative decoding algorithms including an exact dynamic-programming method, showing that the beam-search method is significantly faster with comparable accuracy. For the joint segmentation and POS-tagging task , we present a novel solution using the framework in this article , and show that it gives comparable accuracies to our previous work ( #TARGET_REF<USE/>a ) , while being more than an order of magnitude faster ."
    },
    {
        "gold": {
            "text": [
                "Previously ( #TARGET_REF ) , we assessed the importance of various implicit argument feature groups by conducting feature ablation tests .",
                "In each test, the discriminative model was retrained and reevaluated without a particular group of features.",
                "We summarize the findings of this study in this section."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "conclusion:Previously ( #TARGET_REF ) , we assessed the importance of various implicit argument feature groups by conducting feature ablation tests . In each test, the discriminative model was retrained and reevaluated without a particular group of features. We summarize the findings of this study in this section.",
        "output": "conclusion:Previously ( #TARGET_REF<COMPARISON/> ) , we assessed the importance of various implicit argument feature groups by conducting feature ablation tests . In each test, the discriminative model was retrained and reevaluated without a particular group of features. We summarize the findings of this study in this section."
    },
    {
        "gold": {
            "text": [
                "In order to remove any confounding factors caused by specific documents, we first randomized the annotated predicate instances.",
                "Following this, we split the predicate instances evenly into ten folds and used each fold as testing data for a model trained on the instances outside the fold.",
                "This evaluation set-up is an improvement versus the one we previously reported ( #TARGET_REF ) , in which fixed partitions were used for training , development , and testing ."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "experiments:In order to remove any confounding factors caused by specific documents, we first randomized the annotated predicate instances. Following this, we split the predicate instances evenly into ten folds and used each fold as testing data for a model trained on the instances outside the fold. This evaluation set-up is an improvement versus the one we previously reported ( #TARGET_REF ) , in which fixed partitions were used for training , development , and testing .",
        "output": "experiments:In order to remove any confounding factors caused by specific documents, we first randomized the annotated predicate instances. Following this, we split the predicate instances evenly into ten folds and used each fold as testing data for a model trained on the instances outside the fold. This evaluation set-up is an improvement versus the one we previously reported ( #TARGET_REF<COMPARISON/> ) , in which fixed partitions were used for training , development , and testing ."
    },
    {
        "gold": {
            "text": [
                "We now give an overview of the training algorithm, which is crucial to both the speed and accuracy of the resulting decoder.",
                "CCGBank ( #TARGET_REF ) is used to train the model .",
                "For each training sentence, the corresponding CCGBank derivation together with all its sub-derivations are treated as gold-standard hypotheses.",
                "All other hypotheses that can be constructed from the same bag of words are non-gold hypotheses.",
                "From the generation perspective this assumption is too strong, because sentences can have multiple orderings (with multiple derivations) that are both gram- matical and fluent.",
                "Nevertheless, it is the most feasible choice given the training data available."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "introduction:We now give an overview of the training algorithm, which is crucial to both the speed and accuracy of the resulting decoder. CCGBank ( #TARGET_REF ) is used to train the model . For each training sentence, the corresponding CCGBank derivation together with all its sub-derivations are treated as gold-standard hypotheses. All other hypotheses that can be constructed from the same bag of words are non-gold hypotheses. From the generation perspective this assumption is too strong, because sentences can have multiple orderings (with multiple derivations) that are both gram- matical and fluent. Nevertheless, it is the most feasible choice given the training data available.",
        "output": "introduction:We now give an overview of the training algorithm, which is crucial to both the speed and accuracy of the resulting decoder. CCGBank ( #TARGET_REF<FUTURE/> ) is used to train the model . For each training sentence, the corresponding CCGBank derivation together with all its sub-derivations are treated as gold-standard hypotheses. All other hypotheses that can be constructed from the same bag of words are non-gold hypotheses. From the generation perspective this assumption is too strong, because sentences can have multiple orderings (with multiple derivations) that are both gram- matical and fluent. Nevertheless, it is the most feasible choice given the training data available."
    },
    {
        "gold": {
            "text": [
                "To allow the combination of hypotheses, we use an additional structure to store a set of hypotheses that have been expanded, which we call accepted hypotheses.",
                "When a hypothesis from the agenda is expanded, it is combined with all accepted hypotheses in all possible ways to produce new hypotheses.",
                "The data structure for accepted hypotheses is similar to that used for best-first parsing (#REF), and we adopt the term chart for this structure.",
                "However, note there are important differences to the parsing problem.",
                "First, the parsing problem has a fixed word order and is considerably simpler than the word ordering problem we are tackling.",
                "Second, although we use the term chart, the structure for accepted hypotheses is not a dynamic programming chart in the same way as for the parsing problem.",
                "In our previous papers ( #TARGET_REF ; Zhang , Blackwood , and #REF ) , we applied a set of beams to this structure , which makes it similar to the data structure used for phrase-based MT decoding ( #REF ) .",
                "However, we will show later that this structure is unnecessary when the model has more discriminative power, and a conceptually simpler single beam can be used.",
                "We will also investigate the possibility of applying dynamic-programming-style pruning to the chart."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:To allow the combination of hypotheses, we use an additional structure to store a set of hypotheses that have been expanded, which we call accepted hypotheses. When a hypothesis from the agenda is expanded, it is combined with all accepted hypotheses in all possible ways to produce new hypotheses. The data structure for accepted hypotheses is similar to that used for best-first parsing (#REF), and we adopt the term chart for this structure. However, note there are important differences to the parsing problem. First, the parsing problem has a fixed word order and is considerably simpler than the word ordering problem we are tackling. Second, although we use the term chart, the structure for accepted hypotheses is not a dynamic programming chart in the same way as for the parsing problem. In our previous papers ( #TARGET_REF ; Zhang , Blackwood , and #REF ) , we applied a set of beams to this structure , which makes it similar to the data structure used for phrase-based MT decoding ( #REF ) . However, we will show later that this structure is unnecessary when the model has more discriminative power, and a conceptually simpler single beam can be used. We will also investigate the possibility of applying dynamic-programming-style pruning to the chart.",
        "output": "introduction:To allow the combination of hypotheses, we use an additional structure to store a set of hypotheses that have been expanded, which we call accepted hypotheses. When a hypothesis from the agenda is expanded, it is combined with all accepted hypotheses in all possible ways to produce new hypotheses. The data structure for accepted hypotheses is similar to that used for best-first parsing (#REF), and we adopt the term chart for this structure. However, note there are important differences to the parsing problem. First, the parsing problem has a fixed word order and is considerably simpler than the word ordering problem we are tackling. Second, although we use the term chart, the structure for accepted hypotheses is not a dynamic programming chart in the same way as for the parsing problem. In our previous papers ( #TARGET_REF<USE/> ; Zhang , Blackwood , and #REF ) , we applied a set of beams to this structure , which makes it similar to the data structure used for phrase-based MT decoding ( #REF ) . However, we will show later that this structure is unnecessary when the model has more discriminative power, and a conceptually simpler single beam can be used. We will also investigate the possibility of applying dynamic-programming-style pruning to the chart."
    },
    {
        "gold": {
            "text": [
                "this experiment is to confirm our theoretical analysis by showing convergence in regret for learning from weak and strong feedback.",
                "We select feedback of varying grade by directly inspecting the optimal w * , thus this feedback is idealized.",
                "However, the experiment also has a realistic background since we show that α-informative feedback corresponds to improvements under standard evaluation metrics such as lowercased and tokenized TER, and that learning from weak and strong feedback leads to convergence in TER on test data.",
                "For this experiment, the post-edit data from the LIG corpus were randomly split into 3 subsets: PE-train (6,881 sentences), PE-dev, and PE-test (2,000 sentences each).",
                "PE-train was used for our online learning experiments.",
                "PE-test was held out for testing the algorithms' progress on unseen data.",
                "PE-dev was used to obtain w * to define the utility model.",
                "This was done by MERT optimization ( #TARGET_REF ) towards post-edits under the TER target metric .",
                "Note that the goal of our experi-  ments is not to improve SMT performance over any algorithm that has access to full information to compute w * .",
                "Rather, we want to show that learning from weak feedback leads to convergence in regret with respect to the optimal model, albeit at a slower rate than learning from strong feedback."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:this experiment is to confirm our theoretical analysis by showing convergence in regret for learning from weak and strong feedback. We select feedback of varying grade by directly inspecting the optimal w * , thus this feedback is idealized. However, the experiment also has a realistic background since we show that α-informative feedback corresponds to improvements under standard evaluation metrics such as lowercased and tokenized TER, and that learning from weak and strong feedback leads to convergence in TER on test data. For this experiment, the post-edit data from the LIG corpus were randomly split into 3 subsets: PE-train (6,881 sentences), PE-dev, and PE-test (2,000 sentences each). PE-train was used for our online learning experiments. PE-test was held out for testing the algorithms' progress on unseen data. PE-dev was used to obtain w * to define the utility model. This was done by MERT optimization ( #TARGET_REF ) towards post-edits under the TER target metric . Note that the goal of our experi-  ments is not to improve SMT performance over any algorithm that has access to full information to compute w * . Rather, we want to show that learning from weak feedback leads to convergence in regret with respect to the optimal model, albeit at a slower rate than learning from strong feedback.",
        "output": "experiments:this experiment is to confirm our theoretical analysis by showing convergence in regret for learning from weak and strong feedback. We select feedback of varying grade by directly inspecting the optimal w * , thus this feedback is idealized. However, the experiment also has a realistic background since we show that α-informative feedback corresponds to improvements under standard evaluation metrics such as lowercased and tokenized TER, and that learning from weak and strong feedback leads to convergence in TER on test data. For this experiment, the post-edit data from the LIG corpus were randomly split into 3 subsets: PE-train (6,881 sentences), PE-dev, and PE-test (2,000 sentences each). PE-train was used for our online learning experiments. PE-test was held out for testing the algorithms' progress on unseen data. PE-dev was used to obtain w * to define the utility model. This was done by MERT optimization ( #TARGET_REF<FUTURE/> ) towards post-edits under the TER target metric . Note that the goal of our experi-  ments is not to improve SMT performance over any algorithm that has access to full information to compute w * . Rather, we want to show that learning from weak feedback leads to convergence in regret with respect to the optimal model, albeit at a slower rate than learning from strong feedback."
    },
    {
        "gold": {
            "text": [
                "Generalization for Online-to-Batch Conversion.",
                "In practice , perceptron-type algorithms are often applied in a batch learning scenario , i.e. , the algorithm is applied for K epochs to a training sample of size T and then used for prediction on an unseen test set ( #REF ; #TARGET_REF ) .",
                "The difference to the online learning scenario is that we treat the multi-epoch algorithm as an empirical risk minimizer that selects a final weight vector w T,K whose expected loss on unseen data we would like to bound.",
                "We assume that the algorithm is fed with a sequence of examples x 1 , . . .",
                ", x T , and at each epoch k = 1, . . .",
                ", K it makes a prediction y t,k .",
                "The correct label is y * t .",
                "For k = 1, . . .",
                ", K and t = 1, . . .",
                ", T , let t,k = U (x t , y * t ) − U (x t , y t,k ), and denote by ∆ t,k and ξ t,k the distance at epoch k for example t, and the slack at epoch k for example t, respectively."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:Generalization for Online-to-Batch Conversion. In practice , perceptron-type algorithms are often applied in a batch learning scenario , i.e. , the algorithm is applied for K epochs to a training sample of size T and then used for prediction on an unseen test set ( #REF ; #TARGET_REF ) . The difference to the online learning scenario is that we treat the multi-epoch algorithm as an empirical risk minimizer that selects a final weight vector w T,K whose expected loss on unseen data we would like to bound. We assume that the algorithm is fed with a sequence of examples x 1 , . . . , x T , and at each epoch k = 1, . . . , K it makes a prediction y t,k . The correct label is y * t . For k = 1, . . . , K and t = 1, . . . , T , let t,k = U (x t , y * t ) − U (x t , y t,k ), and denote by ∆ t,k and ξ t,k the distance at epoch k for example t, and the slack at epoch k for example t, respectively.",
        "output": "nan:Generalization for Online-to-Batch Conversion. In practice , perceptron-type algorithms are often applied in a batch learning scenario , i.e. , the algorithm is applied for K epochs to a training sample of size T and then used for prediction on an unseen test set ( #REF ; #TARGET_REF<USE/> ) . The difference to the online learning scenario is that we treat the multi-epoch algorithm as an empirical risk minimizer that selects a final weight vector w T,K whose expected loss on unseen data we would like to bound. We assume that the algorithm is fed with a sequence of examples x 1 , . . . , x T , and at each epoch k = 1, . . . , K it makes a prediction y t,k . The correct label is y * t . For k = 1, . . . , K and t = 1, . . . , T , let t,k = U (x t , y * t ) − U (x t , y t,k ), and denote by ∆ t,k and ξ t,k the distance at epoch k for example t, and the slack at epoch k for example t, respectively."
    },
    {
        "gold": {
            "text": [
                "We used the LIG corpus 3 which consists of 10,881 tuples of French-English post-edits (#REF).",
                "The corpus is a subset of the newscommentary dataset provided at WMT 4 and contains input French sentences, MT outputs, postedited outputs and English references.",
                "To prepare SMT outputs for post-editing , the creators of the corpus used their own WMT10 system ( #REF ) , based on the Moses phrase-based decoder ( #TARGET_REF ) with dense features .",
                "We replicated a similar Moses system using the same monolingual and parallel data: a 5-gram language model was estimated with the KenLM toolkit (#REF) on news.en",
                "data (48.65M",
                "sentences, 1.13B tokens), pre-processed with the tools from the cdec toolkit (#REF).",
                "perceptron cycling theorem (#REF;#REF) should suffice to show a similar bound.",
                "Parallel data (europarl+news-comm, 1.64M sentences) were similarly pre-processed and aligned with fast align (#REF).",
                "In all experiments, training is started with the Moses default weights.",
                "The size of the n-best list, where used, was set to 1,000."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We used the LIG corpus 3 which consists of 10,881 tuples of French-English post-edits (#REF). The corpus is a subset of the newscommentary dataset provided at WMT 4 and contains input French sentences, MT outputs, postedited outputs and English references. To prepare SMT outputs for post-editing , the creators of the corpus used their own WMT10 system ( #REF ) , based on the Moses phrase-based decoder ( #TARGET_REF ) with dense features . We replicated a similar Moses system using the same monolingual and parallel data: a 5-gram language model was estimated with the KenLM toolkit (#REF) on news.en data (48.65M sentences, 1.13B tokens), pre-processed with the tools from the cdec toolkit (#REF). perceptron cycling theorem (#REF;#REF) should suffice to show a similar bound. Parallel data (europarl+news-comm, 1.64M sentences) were similarly pre-processed and aligned with fast align (#REF). In all experiments, training is started with the Moses default weights. The size of the n-best list, where used, was set to 1,000.",
        "output": "experiments:We used the LIG corpus 3 which consists of 10,881 tuples of French-English post-edits (#REF). The corpus is a subset of the newscommentary dataset provided at WMT 4 and contains input French sentences, MT outputs, postedited outputs and English references. To prepare SMT outputs for post-editing , the creators of the corpus used their own WMT10 system ( #REF ) , based on the Moses phrase-based decoder ( #TARGET_REF<FUTURE/> ) with dense features . We replicated a similar Moses system using the same monolingual and parallel data: a 5-gram language model was estimated with the KenLM toolkit (#REF) on news.en data (48.65M sentences, 1.13B tokens), pre-processed with the tools from the cdec toolkit (#REF). perceptron cycling theorem (#REF;#REF) should suffice to show a similar bound. Parallel data (europarl+news-comm, 1.64M sentences) were similarly pre-processed and aligned with fast align (#REF). In all experiments, training is started with the Moses default weights. The size of the n-best list, where used, was set to 1,000."
    },
    {
        "gold": {
            "text": [
                "In contrast , a single statistical model allows one to maintain a single table ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:In contrast , a single statistical model allows one to maintain a single table ( #TARGET_REF ) .",
        "output": "nan:In contrast , a single statistical model allows one to maintain a single table ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "IGEN uses standard chart generation techniques ( #TARGET_REF ) in its base generator to efficiently produce generation candidates ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "experiments:IGEN uses standard chart generation techniques ( #TARGET_REF ) in its base generator to efficiently produce generation candidates .",
        "output": "experiments:IGEN uses standard chart generation techniques ( #TARGET_REF<BACKGROUND/> ) in its base generator to efficiently produce generation candidates ."
    },
    {
        "gold": {
            "text": [
                "Notice that it is not possible to use corpus annotation to determine the likelihood of a given property to be chosen , unless we know in advance all of the properties that can be attributed to a given object , as in the case of Jordan 's work on the COCONUT domain ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Notice that it is not possible to use corpus annotation to determine the likelihood of a given property to be chosen , unless we know in advance all of the properties that can be attributed to a given object , as in the case of Jordan 's work on the COCONUT domain ( #TARGET_REF ) .",
        "output": "nan:Notice that it is not possible to use corpus annotation to determine the likelihood of a given property to be chosen , unless we know in advance all of the properties that can be attributed to a given object , as in the case of Jordan 's work on the COCONUT domain ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "It has been argued that generating such modifiers is not a trivial decision because it interferes with the planning of both local and global coherence ( in the sense of ( #REF ) ) ( #TARGET_REFa ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:It has been argued that generating such modifiers is not a trivial decision because it interferes with the planning of both local and global coherence ( in the sense of ( #REF ) ) ( #TARGET_REFa ) .",
        "output": "introduction:It has been argued that generating such modifiers is not a trivial decision because it interferes with the planning of both local and global coherence ( in the sense of ( #REF ) ) ( #TARGET_REF<BACKGROUND/>a ) ."
    },
    {
        "gold": {
            "text": [
                "Using WordNet , annotating the sem feature of an adjective involves first choosing the correct sense for the adjective 2Some descriptions of int modifiers can be found in ( #TARGET_REFb ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Using WordNet , annotating the sem feature of an adjective involves first choosing the correct sense for the adjective 2Some descriptions of int modifiers can be found in ( #TARGET_REFb ) .",
        "output": "nan:Using WordNet , annotating the sem feature of an adjective involves first choosing the correct sense for the adjective 2Some descriptions of int modifiers can be found in ( #TARGET_REF<BACKGROUND/>b ) ."
    },
    {
        "gold": {
            "text": [
                "In addition to a referring function , noun phrases ( NP ) can also serve communicative goals such as providing new information about the referent and expressing the speaker 's emotional attitude towards the referent ( #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:In addition to a referring function , noun phrases ( NP ) can also serve communicative goals such as providing new information about the referent and expressing the speaker 's emotional attitude towards the referent ( #REF ; #TARGET_REF ) .",
        "output": "introduction:In addition to a referring function , noun phrases ( NP ) can also serve communicative goals such as providing new information about the referent and expressing the speaker 's emotional attitude towards the referent ( #REF ; #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "In what follows we explain the properties of the model by applying it to a small number of adjective-noun combinations taken from the lexical semantics literature.",
                "Table 1 gives the interpretations of eight adjective-noun combinations discussed in #TARGET_REF and #REF .",
                "Table 2 shows the five most likely interpretations for these combinations as derived by the model discussed in the previous sections (v is the most likely interpretation, v 2 is the second most likely interpretation, etc.)."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:In what follows we explain the properties of the model by applying it to a small number of adjective-noun combinations taken from the lexical semantics literature. Table 1 gives the interpretations of eight adjective-noun combinations discussed in #TARGET_REF and #REF . Table 2 shows the five most likely interpretations for these combinations as derived by the model discussed in the previous sections (v is the most likely interpretation, v 2 is the second most likely interpretation, etc.).",
        "output": "method:In what follows we explain the properties of the model by applying it to a small number of adjective-noun combinations taken from the lexical semantics literature. Table 1 gives the interpretations of eight adjective-noun combinations discussed in #TARGET_REF<FUTURE/> and #REF . Table 2 shows the five most likely interpretations for these combinations as derived by the model discussed in the previous sections (v is the most likely interpretation, v 2 is the second most likely interpretation, etc.)."
    },
    {
        "gold": {
            "text": [
                "Much recent work in lexical semantics has been concerned with accounting for regular polysemy, i.e., the regular and predictable sense alternations certain classes of words are subject to.",
                "Adjectives , more than other categories , are a striking example of regular polysemy since they are able to take on different meanings depending on their context , viz. , the noun or noun class they modify ( see #TARGET_REF and the references therein ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Much recent work in lexical semantics has been concerned with accounting for regular polysemy, i.e., the regular and predictable sense alternations certain classes of words are subject to. Adjectives , more than other categories , are a striking example of regular polysemy since they are able to take on different meanings depending on their context , viz. , the noun or noun class they modify ( see #TARGET_REF and the references therein ) .",
        "output": "introduction:Much recent work in lexical semantics has been concerned with accounting for regular polysemy, i.e., the regular and predictable sense alternations certain classes of words are subject to. Adjectives , more than other categories , are a striking example of regular polysemy since they are able to take on different meanings depending on their context , viz. , the noun or noun class they modify ( see #TARGET_REF<BACKGROUND/> and the references therein ) ."
    },
    {
        "gold": {
            "text": [
                "We chose nine adjectives according to a set of minimal criteria and paired each adjective with 10 nouns randomly selected from the BNC.",
                "We chose the adjectives as follows : we first compiled a list of all the polysemous adjectives mentioned in the lexical semantics literature ( #REF ; #TARGET_REF ) .",
                "From these we randomly sampled nine adjectives (difficult, easy, fast, good, hard, right, safe, slow, wrong).",
                "These adjectives had to be unambiguous with respect to their part-of-speech: each adjective was unambiguously tagged as \"adjective\" 98.6% of the time, measured as the number of different part-of-speech tags assigned to the word in the BNC.",
                "We identified adjective-noun pairs using Gsearch (#REF), a chart parser which detects syntactic patterns in a tagged corpus by exploiting a userspecified context free grammar and a syntactic query.",
                "Gsearch was run on a lemmatized version of the BNC so as to compile a comprehensive corpus count of all nouns occurring in a modifier-head relationship with each of the nine adjectives."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:We chose nine adjectives according to a set of minimal criteria and paired each adjective with 10 nouns randomly selected from the BNC. We chose the adjectives as follows : we first compiled a list of all the polysemous adjectives mentioned in the lexical semantics literature ( #REF ; #TARGET_REF ) . From these we randomly sampled nine adjectives (difficult, easy, fast, good, hard, right, safe, slow, wrong). These adjectives had to be unambiguous with respect to their part-of-speech: each adjective was unambiguously tagged as \"adjective\" 98.6% of the time, measured as the number of different part-of-speech tags assigned to the word in the BNC. We identified adjective-noun pairs using Gsearch (#REF), a chart parser which detects syntactic patterns in a tagged corpus by exploiting a userspecified context free grammar and a syntactic query. Gsearch was run on a lemmatized version of the BNC so as to compile a comprehensive corpus count of all nouns occurring in a modifier-head relationship with each of the nine adjectives.",
        "output": "experiments:We chose nine adjectives according to a set of minimal criteria and paired each adjective with 10 nouns randomly selected from the BNC. We chose the adjectives as follows : we first compiled a list of all the polysemous adjectives mentioned in the lexical semantics literature ( #REF ; #TARGET_REF<FUTURE/> ) . From these we randomly sampled nine adjectives (difficult, easy, fast, good, hard, right, safe, slow, wrong). These adjectives had to be unambiguous with respect to their part-of-speech: each adjective was unambiguously tagged as \"adjective\" 98.6% of the time, measured as the number of different part-of-speech tags assigned to the word in the BNC. We identified adjective-noun pairs using Gsearch (#REF), a chart parser which detects syntactic patterns in a tagged corpus by exploiting a userspecified context free grammar and a syntactic query. Gsearch was run on a lemmatized version of the BNC so as to compile a comprehensive corpus count of all nouns occurring in a modifier-head relationship with each of the nine adjectives."
    },
    {
        "gold": {
            "text": [
                "Although fast usually triggers a verb-subject interpretation (see (1)), easy and difficult trigger verb-object interpretations (see (2a,b)).",
                "An easy problem is usually a problem that is easy to solve, whereas a difficult language is a language that is difficult to learn, speak, or write.",
                "Adjectives like good allow either verb-subject or verb-object interpretations: a good cook is a cook who cooks well whereas good soup is soup that tastes good or soup that is good to eat.",
                "#TARGET_REF avoids enumerating the various senses for adjectives like fast by exploiting the semantics of the nouns they modify .",
                "Pustejovsky treats nouns as having a qualia structure as part of their lexical entries, which among other things, specifies possible events associated with the entity.",
                "For example, the telic (purpose) role of the qualia structure for problem has a value equivalent to solve.",
                "When the adjective easy is combined with problem, it predicates over the telic role of problem and consequently the adjective-noun combination receives the interpretation a problem that is easy to solve.",
                "#REF does not give an exhaustive list of the telic roles a given noun may have."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Although fast usually triggers a verb-subject interpretation (see (1)), easy and difficult trigger verb-object interpretations (see (2a,b)). An easy problem is usually a problem that is easy to solve, whereas a difficult language is a language that is difficult to learn, speak, or write. Adjectives like good allow either verb-subject or verb-object interpretations: a good cook is a cook who cooks well whereas good soup is soup that tastes good or soup that is good to eat. #TARGET_REF avoids enumerating the various senses for adjectives like fast by exploiting the semantics of the nouns they modify . Pustejovsky treats nouns as having a qualia structure as part of their lexical entries, which among other things, specifies possible events associated with the entity. For example, the telic (purpose) role of the qualia structure for problem has a value equivalent to solve. When the adjective easy is combined with problem, it predicates over the telic role of problem and consequently the adjective-noun combination receives the interpretation a problem that is easy to solve. #REF does not give an exhaustive list of the telic roles a given noun may have.",
        "output": "introduction:Although fast usually triggers a verb-subject interpretation (see (1)), easy and difficult trigger verb-object interpretations (see (2a,b)). An easy problem is usually a problem that is easy to solve, whereas a difficult language is a language that is difficult to learn, speak, or write. Adjectives like good allow either verb-subject or verb-object interpretations: a good cook is a cook who cooks well whereas good soup is soup that tastes good or soup that is good to eat. #TARGET_REF<BACKGROUND/> avoids enumerating the various senses for adjectives like fast by exploiting the semantics of the nouns they modify . Pustejovsky treats nouns as having a qualia structure as part of their lexical entries, which among other things, specifies possible events associated with the entity. For example, the telic (purpose) role of the qualia structure for problem has a value equivalent to solve. When the adjective easy is combined with problem, it predicates over the telic role of problem and consequently the adjective-noun combination receives the interpretation a problem that is easy to solve. #REF does not give an exhaustive list of the telic roles a given noun may have."
    },
    {
        "gold": {
            "text": [
                "We have presented an ensemble approach to word sense disambiguation ( #TARGET_REF ) where multiple Naive Bayesian classifiers , each based on co -- occurrence features from varying sized windows of context , is shown to perform well on the widely studied nouns interest and line ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:We have presented an ensemble approach to word sense disambiguation ( #TARGET_REF ) where multiple Naive Bayesian classifiers , each based on co -- occurrence features from varying sized windows of context , is shown to perform well on the widely studied nouns interest and line .",
        "output": "conclusion:We have presented an ensemble approach to word sense disambiguation ( #TARGET_REF<BACKGROUND/> ) where multiple Naive Bayesian classifiers , each based on co -- occurrence features from varying sized windows of context , is shown to perform well on the widely studied nouns interest and line ."
    },
    {
        "gold": {
            "text": [
                "See ( #TARGET_REF ) for a discussion ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:See ( #TARGET_REF ) for a discussion .",
        "output": "nan:See ( #TARGET_REF<BACKGROUND/> ) for a discussion ."
    },
    {
        "gold": {
            "text": [
                "Other definitions of predicates may be found in ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Other definitions of predicates may be found in ( #TARGET_REF ) .",
        "output": "nan:Other definitions of predicates may be found in ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "This appeared to solve the problem , and the results presented later for the average degree of generalisation do not show an over-generalisation compared with those given in #TARGET_REF ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:This appeared to solve the problem , and the results presented later for the average degree of generalisation do not show an over-generalisation compared with those given in #TARGET_REF .",
        "output": "nan:This appeared to solve the problem , and the results presented later for the average degree of generalisation do not show an over-generalisation compared with those given in #TARGET_REF<USE/> ."
    },
    {
        "gold": {
            "text": [
                "The task we used to compare different generalisation techniques is similar to that used by #TARGET_REF and #REF ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:The task we used to compare different generalisation techniques is similar to that used by #TARGET_REF and #REF .",
        "output": "experiments:The task we used to compare different generalisation techniques is similar to that used by #TARGET_REF<USE/> and #REF ."
    },
    {
        "gold": {
            "text": [
                "The problem with this approach is that any threshold is , to some extent , arbitrary , and there is evidence to suggest that , for some tasks , low counts are important ( #TARGET_REF ) ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:The problem with this approach is that any threshold is , to some extent , arbitrary , and there is evidence to suggest that , for some tasks , low counts are important ( #TARGET_REF ) .",
        "output": "nan:The problem with this approach is that any threshold is , to some extent , arbitrary , and there is evidence to suggest that , for some tasks , low counts are important ( #TARGET_REF<EXTENSION/> ) ."
    },
    {
        "gold": {
            "text": [
                "However , #TARGET_REF claims that the log-likelihood chisquared statistic ( G2 ) is more appropriate for corpus-based NLP ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "Motivation:However , #TARGET_REF claims that the log-likelihood chisquared statistic ( G2 ) is more appropriate for corpus-based NLP .",
        "output": "Motivation:However , #TARGET_REF<EXTENSION/> claims that the log-likelihood chisquared statistic ( G2 ) is more appropriate for corpus-based NLP ."
    },
    {
        "gold": {
            "text": [
                "The task we used to compare different generalisation techniques is similar to that used by #REF and #TARGET_REF ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:The task we used to compare different generalisation techniques is similar to that used by #REF and #TARGET_REF .",
        "output": "experiments:The task we used to compare different generalisation techniques is similar to that used by #REF and #TARGET_REF<USE/> ."
    },
    {
        "gold": {
            "text": [
                "The X2 statistic is performing at least as well as G2 , throwing doubt on the claim by #TARGET_REF that the G2 statistic is better suited for use in corpus-based NLP ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:The X2 statistic is performing at least as well as G2 , throwing doubt on the claim by #TARGET_REF that the G2 statistic is better suited for use in corpus-based NLP .",
        "output": "experiments:The X2 statistic is performing at least as well as G2 , throwing doubt on the claim by #TARGET_REF<USE/> that the G2 statistic is better suited for use in corpus-based NLP ."
    },
    {
        "gold": {
            "text": [
                "My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing.",
                "The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #TARGET_REF ; #REF ; #REF ) ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #TARGET_REF ; #REF ; #REF ) .",
        "output": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #TARGET_REF<USE/> ; #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "These observations and this line of reasoning has not escaped the attention of theoretical linguists : #TARGET_REF propose that argument structure is , in fact , encoded syntactically .",
                "They describe a cascading verb phrase analysis with multiple phonetically empty verbal projections corresponding to concepts such as inchoativity and agentivity.",
                "This present framework builds on the work of Hale and Keyser, but in addition to advancing a more refined theory of verbal argument structure, I also describe a computational implementation."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:These observations and this line of reasoning has not escaped the attention of theoretical linguists : #TARGET_REF propose that argument structure is , in fact , encoded syntactically . They describe a cascading verb phrase analysis with multiple phonetically empty verbal projections corresponding to concepts such as inchoativity and agentivity. This present framework builds on the work of Hale and Keyser, but in addition to advancing a more refined theory of verbal argument structure, I also describe a computational implementation.",
        "output": "nan:These observations and this line of reasoning has not escaped the attention of theoretical linguists : #TARGET_REF<BACKGROUND/> propose that argument structure is , in fact , encoded syntactically . They describe a cascading verb phrase analysis with multiple phonetically empty verbal projections corresponding to concepts such as inchoativity and agentivity. This present framework builds on the work of Hale and Keyser, but in addition to advancing a more refined theory of verbal argument structure, I also describe a computational implementation."
    },
    {
        "gold": {
            "text": [
                "The light verb v DO licenses an atelic non-inchoative event, and is compatible with verbal roots expressing activity.",
                "It projects a functional head , voice ( #TARGET_REF ) , whose specifier is the external argument .",
                "Lexical entries in the system are minimally specified, each consisting of a phonetic form, a list of relevant features, and semantics in the form of a λ expression."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:The light verb v DO licenses an atelic non-inchoative event, and is compatible with verbal roots expressing activity. It projects a functional head , voice ( #TARGET_REF ) , whose specifier is the external argument . Lexical entries in the system are minimally specified, each consisting of a phonetic form, a list of relevant features, and semantics in the form of a λ expression.",
        "output": "nan:The light verb v DO licenses an atelic non-inchoative event, and is compatible with verbal roots expressing activity. It projects a functional head , voice ( #TARGET_REF<BACKGROUND/> ) , whose specifier is the external argument . Lexical entries in the system are minimally specified, each consisting of a phonetic form, a list of relevant features, and semantics in the form of a λ expression."
    },
    {
        "gold": {
            "text": [
                "My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing.",
                "The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #TARGET_REF ; #REF ) .",
        "output": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #TARGET_REF<USE/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "In this paper , I present a computational implementation of Distributed Morphology ( #TARGET_REF ) , a non-lexicalist linguistic theory that erases the distinction between syntactic derivation and morphological derivation .",
                "This framework leads to finer-grained semantics capable of better capturing linguistic generalizations."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "introduction:In this paper , I present a computational implementation of Distributed Morphology ( #TARGET_REF ) , a non-lexicalist linguistic theory that erases the distinction between syntactic derivation and morphological derivation . This framework leads to finer-grained semantics capable of better capturing linguistic generalizations.",
        "output": "introduction:In this paper , I present a computational implementation of Distributed Morphology ( #TARGET_REF<FUTURE/> ) , a non-lexicalist linguistic theory that erases the distinction between syntactic derivation and morphological derivation . This framework leads to finer-grained semantics capable of better capturing linguistic generalizations."
    },
    {
        "gold": {
            "text": [
                "A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots).",
                "Verbs are viewed as simple predicates over their arguments.",
                "This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #REF ) and PropBank ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots). Verbs are viewed as simple predicates over their arguments. This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #REF ) and PropBank ( #TARGET_REF ) .",
        "output": "introduction:A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots). Verbs are viewed as simple predicates over their arguments. This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #REF ) and PropBank ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "In ( #TARGET_REF ) , I present evidence from Mandarin Chinese that this analysis is on the right track .",
                "The rest of this paper, however, will be concerned with the computational implementation of my theoretical framework."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "nan:In ( #TARGET_REF ) , I present evidence from Mandarin Chinese that this analysis is on the right track . The rest of this paper, however, will be concerned with the computational implementation of my theoretical framework.",
        "output": "nan:In ( #TARGET_REF<COMPARISON/> ) , I present evidence from Mandarin Chinese that this analysis is on the right track . The rest of this paper, however, will be concerned with the computational implementation of my theoretical framework."
    },
    {
        "gold": {
            "text": [
                "The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content.",
                "Due to advances in statistical syntactic parsing techniques ( #REF ; #TARGET_REF ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content. Due to advances in statistical syntactic parsing techniques ( #REF ; #TARGET_REF ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences .",
        "output": "introduction:The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content. Due to advances in statistical syntactic parsing techniques ( #REF ; #TARGET_REF<BACKGROUND/> ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences ."
    },
    {
        "gold": {
            "text": [
                "There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #TARGET_REFb ; Rappaport #REF ) .",
                "Consider the following example:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #TARGET_REFb ; Rappaport #REF ) . Consider the following example:",
        "output": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #TARGET_REF<BACKGROUND/>b ; Rappaport #REF ) . Consider the following example:"
    },
    {
        "gold": {
            "text": [
                "The currently implemented system is still at the \"toy parser\" stage.",
                "Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena.",
                "With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #REF using a #TARGET_REF style analysis .",
                "I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:The currently implemented system is still at the \"toy parser\" stage. Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena. With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #REF using a #TARGET_REF style analysis . I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles.",
        "output": "nan:The currently implemented system is still at the \"toy parser\" stage. Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena. With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #REF using a #TARGET_REF<BACKGROUND/> style analysis . I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles."
    },
    {
        "gold": {
            "text": [
                "Activities know run believe walk Accomplishments Achievements paint a picture recognize make a chair find Under Vendler's classification, activities and states both depict situations that are inherently temporally unbounded (atelic); states denote static situations, whereas activities denote on-going dynamic situations.",
                "Accomplishments and achievements both express a change of state, and hence are temporally bounded (telic); achievements are punctual, whereas accomplishments extend over a period of time.",
                "#TARGET_REF observes that accomplishments differ from achievements only in terms of event duration , which is often a question of granularity ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Activities know run believe walk Accomplishments Achievements paint a picture recognize make a chair find Under Vendler's classification, activities and states both depict situations that are inherently temporally unbounded (atelic); states denote static situations, whereas activities denote on-going dynamic situations. Accomplishments and achievements both express a change of state, and hence are temporally bounded (telic); achievements are punctual, whereas accomplishments extend over a period of time. #TARGET_REF observes that accomplishments differ from achievements only in terms of event duration , which is often a question of granularity .",
        "output": "nan:Activities know run believe walk Accomplishments Achievements paint a picture recognize make a chair find Under Vendler's classification, activities and states both depict situations that are inherently temporally unbounded (atelic); states denote static situations, whereas activities denote on-going dynamic situations. Accomplishments and achievements both express a change of state, and hence are temporally bounded (telic); achievements are punctual, whereas accomplishments extend over a period of time. #TARGET_REF<BACKGROUND/> observes that accomplishments differ from achievements only in terms of event duration , which is often a question of granularity ."
    },
    {
        "gold": {
            "text": [
                "The currently implemented system is still at the \"toy parser\" stage.",
                "Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena.",
                "With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #TARGET_REF using a #REF style analysis .",
                "I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:The currently implemented system is still at the \"toy parser\" stage. Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena. With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #TARGET_REF using a #REF style analysis . I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles.",
        "output": "nan:The currently implemented system is still at the \"toy parser\" stage. Although the effectiveness and coverage  of my parser remains to be seen, similar approaches have been successful at capturing complex linguistic phenomena. With a minimal set of features and a small number of lexical entries , #REF has successfully modeled many of the argument alternations described by #TARGET_REF<BACKGROUND/> using a #REF style analysis . I believe that with a suitable lexicon (either hand crafted or automatically induced), my framework can be elaborated into a system whose performance is comparable to that of current statistical parsers, but with the added advantage of simultaneously providing a richer lexical semantic representation of the input sentence than flat predicate argument structures based on semantic roles."
    },
    {
        "gold": {
            "text": [
                "Considering that the only difference between flat.ADJ and flatten.V is the suffix -en, it must be the source of inchoativity and contribute the change of state reading that distinguishes the verb from the adjective.",
                "Here, we have evidence that derivational affixes affect the semantic representation of lexical items, that is, fragments of event structure are directly associated with derivational morphemes.",
                "We have the following situation: In this case, the complete event structure of a word can be compositionally derived from its component morphemes.",
                "This framework , where the `` semantic load '' is spread more evenly throughout the lexicon to lexical categories not typically thought to bear semantic content , is essentially the model advocated by #TARGET_REFa ) , among many others .",
                "Note that such an approach is no longer lexicalist: each lexical item does not fully encode its associated syntactic and semantic structures.",
                "Rather, meanings are composed from component morphemes."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Considering that the only difference between flat.ADJ and flatten.V is the suffix -en, it must be the source of inchoativity and contribute the change of state reading that distinguishes the verb from the adjective. Here, we have evidence that derivational affixes affect the semantic representation of lexical items, that is, fragments of event structure are directly associated with derivational morphemes. We have the following situation: In this case, the complete event structure of a word can be compositionally derived from its component morphemes. This framework , where the `` semantic load '' is spread more evenly throughout the lexicon to lexical categories not typically thought to bear semantic content , is essentially the model advocated by #TARGET_REFa ) , among many others . Note that such an approach is no longer lexicalist: each lexical item does not fully encode its associated syntactic and semantic structures. Rather, meanings are composed from component morphemes.",
        "output": "nan:Considering that the only difference between flat.ADJ and flatten.V is the suffix -en, it must be the source of inchoativity and contribute the change of state reading that distinguishes the verb from the adjective. Here, we have evidence that derivational affixes affect the semantic representation of lexical items, that is, fragments of event structure are directly associated with derivational morphemes. We have the following situation: In this case, the complete event structure of a word can be compositionally derived from its component morphemes. This framework , where the `` semantic load '' is spread more evenly throughout the lexicon to lexical categories not typically thought to bear semantic content , is essentially the model advocated by #TARGET_REF<BACKGROUND/>a ) , among many others . Note that such an approach is no longer lexicalist: each lexical item does not fully encode its associated syntactic and semantic structures. Rather, meanings are composed from component morphemes."
    },
    {
        "gold": {
            "text": [
                "My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing.",
                "The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #REF ; #TARGET_REF ) .",
        "output": "nan:My theory of verbal argument structure can be imple- mented in a unified morpho-syntactic parsing model that interleaves syntactic and semantic parsing. The system is in the form of an agenda-driven chart-based parser whose foundation is similar to previous formalizations of Chomsky 's Minimalist Program ( #REF ; #REF ; #TARGET_REF<USE/> ) ."
    },
    {
        "gold": {
            "text": [
                "Following the non-lexicalist tradition, these primitives are argued to occupy functional projections in the syntactic structure, as so-called light verbs.",
                "Here , I adopt the model proposed by #TARGET_REF and decompose lexical verbs into verbalizing heads and verbal roots .",
                "Verbalizing heads introduce relevant eventive interpretations in the syntax, and correspond to (assumed) universal primitives of the human cognitive system.",
                "On the other hand, verbal roots represent abstract (categoryless) concepts and basically correspond to open-class items drawn from encyclopedic knowledge.",
                "I assume an inventory of three verbalizing heads, each corresponding to an aforementioned primitive:"
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:Following the non-lexicalist tradition, these primitives are argued to occupy functional projections in the syntactic structure, as so-called light verbs. Here , I adopt the model proposed by #TARGET_REF and decompose lexical verbs into verbalizing heads and verbal roots . Verbalizing heads introduce relevant eventive interpretations in the syntax, and correspond to (assumed) universal primitives of the human cognitive system. On the other hand, verbal roots represent abstract (categoryless) concepts and basically correspond to open-class items drawn from encyclopedic knowledge. I assume an inventory of three verbalizing heads, each corresponding to an aforementioned primitive:",
        "output": "nan:Following the non-lexicalist tradition, these primitives are argued to occupy functional projections in the syntactic structure, as so-called light verbs. Here , I adopt the model proposed by #TARGET_REF<FUTURE/> and decompose lexical verbs into verbalizing heads and verbal roots . Verbalizing heads introduce relevant eventive interpretations in the syntax, and correspond to (assumed) universal primitives of the human cognitive system. On the other hand, verbal roots represent abstract (categoryless) concepts and basically correspond to open-class items drawn from encyclopedic knowledge. I assume an inventory of three verbalizing heads, each corresponding to an aforementioned primitive:"
    },
    {
        "gold": {
            "text": [
                "A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots).",
                "Verbs are viewed as simple predicates over their arguments.",
                "This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #TARGET_REF ) and PropBank ( #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots). Verbs are viewed as simple predicates over their arguments. This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #TARGET_REF ) and PropBank ( #REF ) .",
        "output": "introduction:A common lexical semantic representation in the computational linguistics literature is a frame-based model where syntactic arguments are associated with various semantic roles (essentially frame slots). Verbs are viewed as simple predicates over their arguments. This approach has its roots in Fillmore 's Case #REF , and serves as the foundation for two current large-scale semantic annotation projects : FrameNet ( #TARGET_REF<BACKGROUND/> ) and PropBank ( #REF ) ."
    },
    {
        "gold": {
            "text": [
                "There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #TARGET_REF ; #REF ; #REFb ; Rappaport #REF ) .",
                "Consider the following example:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #TARGET_REF ; #REF ; #REFb ; Rappaport #REF ) . Consider the following example:",
        "output": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #TARGET_REF<BACKGROUND/> ; #REF ; #REFb ; Rappaport #REF ) . Consider the following example:"
    },
    {
        "gold": {
            "text": [
                "The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content.",
                "Due to advances in statistical syntactic parsing techniques ( #TARGET_REF ; #REF ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content. Due to advances in statistical syntactic parsing techniques ( #TARGET_REF ; #REF ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences .",
        "output": "introduction:The understanding of natural language text includes not only analysis of syntactic structure, but also of semantic content. Due to advances in statistical syntactic parsing techniques ( #TARGET_REF<BACKGROUND/> ; #REF ) , attention has recently shifted towards the harder question of analyzing the meaning of natural language sentences ."
    },
    {
        "gold": {
            "text": [
                "There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #TARGET_REF ; #REFb ; Rappaport #REF ) .",
                "Consider the following example:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #TARGET_REF ; #REFb ; Rappaport #REF ) . Consider the following example:",
        "output": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #TARGET_REF<BACKGROUND/> ; #REFb ; Rappaport #REF ) . Consider the following example:"
    },
    {
        "gold": {
            "text": [
                "#TARGET_REF has developed an agenda-driven chart parser for the feature-driven formalism described above ; please refer to his paper for a description of the parsing algorithm .",
                "I have adapted it for my needs and developed grammar fragments that reflect my non-lexicalist semantic framework.",
                "As an example, a simplified derivation of the sentence \"The tire flattened.\" is shown in Figure 1."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "nan:#TARGET_REF has developed an agenda-driven chart parser for the feature-driven formalism described above ; please refer to his paper for a description of the parsing algorithm . I have adapted it for my needs and developed grammar fragments that reflect my non-lexicalist semantic framework. As an example, a simplified derivation of the sentence \"The tire flattened.\" is shown in Figure 1.",
        "output": "nan:#TARGET_REF<COMPARISON/> has developed an agenda-driven chart parser for the feature-driven formalism described above ; please refer to his paper for a description of the parsing algorithm . I have adapted it for my needs and developed grammar fragments that reflect my non-lexicalist semantic framework. As an example, a simplified derivation of the sentence \"The tire flattened.\" is shown in Figure 1."
    },
    {
        "gold": {
            "text": [
                "The typical solution to the redundancy problem is to group verbs according to their argument realization patterns ( #TARGET_REF ) , possibly arranged in an inheritance hierarchy .",
                "The argument structure and syntax-tosemantics mapping would then only need to be specified once for each verb class.",
                "In addition, lexical rules could be formulated to derive certain alternations from more basic forms."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:The typical solution to the redundancy problem is to group verbs according to their argument realization patterns ( #TARGET_REF ) , possibly arranged in an inheritance hierarchy . The argument structure and syntax-tosemantics mapping would then only need to be specified once for each verb class. In addition, lexical rules could be formulated to derive certain alternations from more basic forms.",
        "output": "introduction:The typical solution to the redundancy problem is to group verbs according to their argument realization patterns ( #TARGET_REF<USE/> ) , possibly arranged in an inheritance hierarchy . The argument structure and syntax-tosemantics mapping would then only need to be specified once for each verb class. In addition, lexical rules could be formulated to derive certain alternations from more basic forms."
    },
    {
        "gold": {
            "text": [
                "There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #REFb ; Rappaport #TARGET_REF ) .",
                "Consider the following example:"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #REFb ; Rappaport #TARGET_REF ) . Consider the following example:",
        "output": "nan:There is a general consensus among theoretical linguists that the proper representation of verbal argument structure is event structure -- representations grounded in a theory of events that decompose semantic roles in terms of primitive predicates representing concepts such as causality and inchoativity ( #REF ; #REF ; #REFb ; Rappaport #TARGET_REF<BACKGROUND/> ) . Consider the following example:"
    },
    {
        "gold": {
            "text": [
                "Dowty breaks the event described by (2) into two subevents, the activity of sweeping the floor and its result, the state of the floor being clean.",
                "A more recent approach , advocated by Rappaport #REF , describes a basic set of event templates corresponding to Vendler 's event classes ( #TARGET_REF ) : ( 3 ) a. [ x ACT <MANNER> ] ( activity ) b. [ x <STATE> ] ( state ) c. [ BECOME [ x <STATE> ] ] ( achievement ) d. [ x CAUSE [ BECOME [ x <STATE> ] ] ] ( accomplishment )"
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "nan:Dowty breaks the event described by (2) into two subevents, the activity of sweeping the floor and its result, the state of the floor being clean. A more recent approach , advocated by Rappaport #REF , describes a basic set of event templates corresponding to Vendler 's event classes ( #TARGET_REF ) : ( 3 ) a. [ x ACT <MANNER> ] ( activity ) b. [ x <STATE> ] ( state ) c. [ BECOME [ x <STATE> ] ] ( achievement ) d. [ x CAUSE [ BECOME [ x <STATE> ] ] ] ( accomplishment )",
        "output": "nan:Dowty breaks the event described by (2) into two subevents, the activity of sweeping the floor and its result, the state of the floor being clean. A more recent approach , advocated by Rappaport #REF , describes a basic set of event templates corresponding to Vendler 's event classes ( #TARGET_REF<BACKGROUND/> ) : ( 3 ) a. [ x ACT <MANNER> ] ( activity ) b. [ x <STATE> ] ( state ) c. [ BECOME [ x <STATE> ] ] ( achievement ) d. [ x CAUSE [ BECOME [ x <STATE> ] ] ] ( accomplishment )"
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#REF, Meral et al. (2007, #REF, #REF and Topkara et al. (2006a) all belong to the syntactic transformation category.",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "#TARGET_REFb ) and Topkara et al. ( 2006a ) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF, Meral et al. (2007, #REF, #REF and Topkara et al. (2006a) all belong to the syntactic transformation category. After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. #TARGET_REFb ) and Topkara et al. ( 2006a ) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method .",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF, Meral et al. (2007, #REF, #REF and Topkara et al. (2006a) all belong to the syntactic transformation category. After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. #TARGET_REF<BACKGROUND/>b ) and Topkara et al. ( 2006a ) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method ."
    },
    {
        "gold": {
            "text": [
                "The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms.",
                "The first lexical substitution method was proposed by #TARGET_REF .",
                "Later works, such as Atallah et al. (2001a), #REF, Taskiran et al. (2006 and Topkara et al. (2006b), further made use of part-ofspeech taggers and electronic dictionaries, such as WordNet and VerbNet, to increase the robustness of the method.",
                "#REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym.",
                "#REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #TARGET_REF . Later works, such as Atallah et al. (2001a), #REF, Taskiran et al. (2006 and Topkara et al. (2006b), further made use of part-ofspeech taggers and electronic dictionaries, such as WordNet and VerbNet, to increase the robustness of the method. #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method.",
        "output": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #TARGET_REF<BACKGROUND/> . Later works, such as Atallah et al. (2001a), #REF, Taskiran et al. (2006 and Topkara et al. (2006b), further made use of part-ofspeech taggers and electronic dictionaries, such as WordNet and VerbNet, to increase the robustness of the method. #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#REF , #REF , #REF , #TARGET_REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category .",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #REF , #TARGET_REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method.",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #REF , #TARGET_REF<BACKGROUND/> and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
    },
    {
        "gold": {
            "text": [
                "The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms.",
                "The first lexical substitution method was proposed by #REF.",
                "Later works , such as #TARGET_REFa ) , #REF , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method .",
                "#REF attempt to use context by prioritizing the alternatives using an n- gram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym.",
                "#REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as #TARGET_REFa ) , #REF , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an n- gram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method.",
        "output": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as #TARGET_REF<BACKGROUND/>a ) , #REF , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an n- gram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
    },
    {
        "gold": {
            "text": [
                "The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms.",
                "The first lexical substitution method was proposed by #REF.",
                "Later works , such as Atallah et al. ( 2001a ) , #REF , #REF and #TARGET_REFb ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method .",
                "#REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym.",
                "#REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as Atallah et al. ( 2001a ) , #REF , #REF and #TARGET_REFb ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method.",
        "output": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as Atallah et al. ( 2001a ) , #REF , #REF and #TARGET_REF<BACKGROUND/>b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#REF , #REF , #TARGET_REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category .",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #TARGET_REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method.",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #TARGET_REF<BACKGROUND/> , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
    },
    {
        "gold": {
            "text": [
                "The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms.",
                "The first lexical substitution method was proposed by #REF.",
                "Later works , such as Atallah et al. ( 2001a ) , #TARGET_REF , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method .",
                "#REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym.",
                "#REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as Atallah et al. ( 2001a ) , #TARGET_REF , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method.",
        "output": "related work:The simplest and most straightforward subliminal modification of text is to substitute selected words with their synonyms. The first lexical substitution method was proposed by #REF. Later works , such as Atallah et al. ( 2001a ) , #TARGET_REF<BACKGROUND/> , #REF and Topkara et al. ( 2006b ) , further made use of part-ofspeech taggers and electronic dictionaries , such as WordNet and VerbNet , to increase the robustness of the method . #REF attempt to use context by prioritizing the alternatives using an ngram language model; that is, rather than randomly choose an option from the synonym set, the system relies on the language model to select the synonym. #REF and Topkara et al. (2006b) report an average embedding capacity of 0.67 bits per sentence for the synonym substitution method."
    },
    {
        "gold": {
            "text": [
                "The Google n-gram data was collected by Google Research for statistical language modelling , and has been used for many tasks such as lexical disambiguation ( #TARGET_REF ) , and contains English n-grams and their observed frequency counts , for counts of at least 40 .",
                "The striking feature of the n-gram corpus is the large number of n-grams and the size of the counts, since the counts were extracted from over 1 trillion word tokens of English text on publicly accessible Web pages collected in #REF.",
                "For example, the 5-gram phrase the part that you were has a count of 103.",
                "The compressed data is around 24 GB on disk."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "experiments:The Google n-gram data was collected by Google Research for statistical language modelling , and has been used for many tasks such as lexical disambiguation ( #TARGET_REF ) , and contains English n-grams and their observed frequency counts , for counts of at least 40 . The striking feature of the n-gram corpus is the large number of n-grams and the size of the counts, since the counts were extracted from over 1 trillion word tokens of English text on publicly accessible Web pages collected in #REF. For example, the 5-gram phrase the part that you were has a count of 103. The compressed data is around 24 GB on disk.",
        "output": "experiments:The Google n-gram data was collected by Google Research for statistical language modelling , and has been used for many tasks such as lexical disambiguation ( #TARGET_REF<BACKGROUND/> ) , and contains English n-grams and their observed frequency counts , for counts of at least 40 . The striking feature of the n-gram corpus is the large number of n-grams and the size of the counts, since the counts were extracted from over 1 trillion word tokens of English text on publicly accessible Web pages collected in #REF. For example, the 5-gram phrase the part that you were has a count of 103. The compressed data is around 24 GB on disk."
    },
    {
        "gold": {
            "text": [
                "Steganography is concerned with hiding information in some cover medium , by manipulating properties of the medium in such a way that the hidden information is not easily detectable by an observer ( #TARGET_REF ) .",
                "The covert communication is such that the very act of communication is to be kept secret from outside observers.",
                "A related area is Watermarking, in which modifications are made to a cover medium in order to identify it, for example for the purposes of copyright.",
                "Here the changes may be known to an observer, and the task is to make the changes in such a way that the watermark cannot easily be removed."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Steganography is concerned with hiding information in some cover medium , by manipulating properties of the medium in such a way that the hidden information is not easily detectable by an observer ( #TARGET_REF ) . The covert communication is such that the very act of communication is to be kept secret from outside observers. A related area is Watermarking, in which modifications are made to a cover medium in order to identify it, for example for the purposes of copyright. Here the changes may be known to an observer, and the task is to make the changes in such a way that the watermark cannot easily be removed.",
        "output": "introduction:Steganography is concerned with hiding information in some cover medium , by manipulating properties of the medium in such a way that the hidden information is not easily detectable by an observer ( #TARGET_REF<BACKGROUND/> ) . The covert communication is such that the very act of communication is to be kept secret from outside observers. A related area is Watermarking, in which modifications are made to a cover medium in order to identify it, for example for the purposes of copyright. Here the changes may be known to an observer, and the task is to make the changes in such a way that the watermark cannot easily be removed."
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#REF , #REF , #REF , #REF and #TARGET_REFa ) all belong to the syntactic transformation category .",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #REF , #REF and #TARGET_REFa ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method.",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #REF , #REF , #REF and #TARGET_REF<BACKGROUND/>a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
    },
    {
        "gold": {
            "text": [
                "The semantic transformation method is the most sophisticated approach for linguistic steganography, and perhaps impractical given the current state-ofthe-art for NLP technology.",
                "It requires some sophisticated tools and knowledge to model natural language semantics.",
                "#REF used semantic transformations and embed information in textmeaning representation (TMR) trees of the text by either pruning, grafting or substituting the tree structure with information available from ontological semantic resources.",
                "#TARGET_REF aimed to embed information by exploiting the linguistic phenomenon of presupposition , with the idea that some presuppositional information can be removed without changing the meaning of a sentence ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The semantic transformation method is the most sophisticated approach for linguistic steganography, and perhaps impractical given the current state-ofthe-art for NLP technology. It requires some sophisticated tools and knowledge to model natural language semantics. #REF used semantic transformations and embed information in textmeaning representation (TMR) trees of the text by either pruning, grafting or substituting the tree structure with information available from ontological semantic resources. #TARGET_REF aimed to embed information by exploiting the linguistic phenomenon of presupposition , with the idea that some presuppositional information can be removed without changing the meaning of a sentence .",
        "output": "related work:The semantic transformation method is the most sophisticated approach for linguistic steganography, and perhaps impractical given the current state-ofthe-art for NLP technology. It requires some sophisticated tools and knowledge to model natural language semantics. #REF used semantic transformations and embed information in textmeaning representation (TMR) trees of the text by either pruning, grafting or substituting the tree structure with information available from ontological semantic resources. #TARGET_REF<BACKGROUND/> aimed to embed information by exploiting the linguistic phenomenon of presupposition , with the idea that some presuppositional information can be removed without changing the meaning of a sentence ."
    },
    {
        "gold": {
            "text": [
                "The coverage figure gives the percentage of sentences which have at least one phrase in the dictionary.",
                "The coverage is important for us because it determines the payload capacity of the embedding method described in Section 5.  Original phrase Paraphrases the end of this year later this year the end of the year year end a number of people some of my colleagues differences the European peoples party the PPE group dictionary is a mapping from phrases to sets of possible paraphrases.",
                "Each paraphrase also has a probability, based on a statistical machine translation model, but we do not use that feature here.",
                "The examples show that, while some of the paraphrases are of a high quality, some are not.",
                "For example, differences is unlikely to be a suitable paraphrase for a number of people in any context.",
                "Moreover, there are some phrase, paraphrase pairs which are only suitable in particular contexts.",
                "For example, year end is an unsuitable paraphrase for the end of this year in the sentence The chart compares the gold price at the end of last year with the end of this year.",
                "#TARGET_REF also note that the applicability of paraphrases is strongly influenced by context .",
                "Section 4 describes our method for determining if a paraphrase is suitable in a given context."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "experiments:The coverage figure gives the percentage of sentences which have at least one phrase in the dictionary. The coverage is important for us because it determines the payload capacity of the embedding method described in Section 5.  Original phrase Paraphrases the end of this year later this year the end of the year year end a number of people some of my colleagues differences the European peoples party the PPE group dictionary is a mapping from phrases to sets of possible paraphrases. Each paraphrase also has a probability, based on a statistical machine translation model, but we do not use that feature here. The examples show that, while some of the paraphrases are of a high quality, some are not. For example, differences is unlikely to be a suitable paraphrase for a number of people in any context. Moreover, there are some phrase, paraphrase pairs which are only suitable in particular contexts. For example, year end is an unsuitable paraphrase for the end of this year in the sentence The chart compares the gold price at the end of last year with the end of this year. #TARGET_REF also note that the applicability of paraphrases is strongly influenced by context . Section 4 describes our method for determining if a paraphrase is suitable in a given context.",
        "output": "experiments:The coverage figure gives the percentage of sentences which have at least one phrase in the dictionary. The coverage is important for us because it determines the payload capacity of the embedding method described in Section 5.  Original phrase Paraphrases the end of this year later this year the end of the year year end a number of people some of my colleagues differences the European peoples party the PPE group dictionary is a mapping from phrases to sets of possible paraphrases. Each paraphrase also has a probability, based on a statistical machine translation model, but we do not use that feature here. The examples show that, while some of the paraphrases are of a high quality, some are not. For example, differences is unlikely to be a suitable paraphrase for a number of people in any context. Moreover, there are some phrase, paraphrase pairs which are only suitable in particular contexts. For example, year end is an unsuitable paraphrase for the end of this year in the sentence The chart compares the gold price at the end of last year with the end of this year. #TARGET_REF<BACKGROUND/> also note that the applicability of paraphrases is strongly influenced by context . Section 4 describes our method for determining if a paraphrase is suitable in a given context."
    },
    {
        "gold": {
            "text": [
                "The cover text used for our experiments consists of newspaper sentences from Section 00 of the Penn Treebank (#REF).",
                "Hence we require possible paraphrases for phrases that occur in Section 00.",
                "The paraphrase dictionary that we use was generated for us by Chris Callison-Burch , using the technique described in #TARGET_REF , which exploits a parallel corpus and methods developed for statistical machine translation ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:The cover text used for our experiments consists of newspaper sentences from Section 00 of the Penn Treebank (#REF). Hence we require possible paraphrases for phrases that occur in Section 00. The paraphrase dictionary that we use was generated for us by Chris Callison-Burch , using the technique described in #TARGET_REF , which exploits a parallel corpus and methods developed for statistical machine translation .",
        "output": "experiments:The cover text used for our experiments consists of newspaper sentences from Section 00 of the Penn Treebank (#REF). Hence we require possible paraphrases for phrases that occur in Section 00. The paraphrase dictionary that we use was generated for us by Chris Callison-Burch , using the technique described in #TARGET_REF<FUTURE/> , which exploits a parallel corpus and methods developed for statistical machine translation ."
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#TARGET_REF , #REF , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category .",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #TARGET_REF , #REF , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method.",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #TARGET_REF<BACKGROUND/> , #REF , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
    },
    {
        "gold": {
            "text": [
                "Section 2 describes some of the previous transformations used in Linguistic Steganography.",
                "Note that we are concerned with transformations which are linguistic in nature , rather than dealing with superficial properties of the text , e.g. the amount of white space between words ( #TARGET_REF ) .",
                "Our proposed method is based on the automatically acquired paraphrase dictionary described in #REF, in which the application of paraphrases from the dictionary encodes secret bits.",
                "One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts.",
                "Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:Section 2 describes some of the previous transformations used in Linguistic Steganography. Note that we are concerned with transformations which are linguistic in nature , rather than dealing with superficial properties of the text , e.g. the amount of white space between words ( #TARGET_REF ) . Our proposed method is based on the automatically acquired paraphrase dictionary described in #REF, in which the application of paraphrases from the dictionary encodes secret bits. One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts. Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text.",
        "output": "introduction:Section 2 describes some of the previous transformations used in Linguistic Steganography. Note that we are concerned with transformations which are linguistic in nature , rather than dealing with superficial properties of the text , e.g. the amount of white space between words ( #TARGET_REF<USE/> ) . Our proposed method is based on the automatically acquired paraphrase dictionary described in #REF, in which the application of paraphrases from the dictionary encodes secret bits. One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts. Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text."
    },
    {
        "gold": {
            "text": [
                "Section 2 describes some of the previous transformations used in Linguistic Steganography.",
                "Note that we are concerned with transformations which are linguistic in nature, rather than dealing with superficial properties of the text, e.g. the amount of white space between words (#REF).",
                "Our proposed method is based on the automatically acquired paraphrase dictionary described in #TARGET_REF , in which the application of paraphrases from the dictionary encodes secret bits .",
                "One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts.",
                "Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:Section 2 describes some of the previous transformations used in Linguistic Steganography. Note that we are concerned with transformations which are linguistic in nature, rather than dealing with superficial properties of the text, e.g. the amount of white space between words (#REF). Our proposed method is based on the automatically acquired paraphrase dictionary described in #TARGET_REF , in which the application of paraphrases from the dictionary encodes secret bits . One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts. Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text.",
        "output": "nan:Section 2 describes some of the previous transformations used in Linguistic Steganography. Note that we are concerned with transformations which are linguistic in nature, rather than dealing with superficial properties of the text, e.g. the amount of white space between words (#REF). Our proposed method is based on the automatically acquired paraphrase dictionary described in #TARGET_REF<FUTURE/> , in which the application of paraphrases from the dictionary encodes secret bits . One advantage of the dictionary is that it has wide coverage, being automatically extracted; however, a disadvantage is that it contains many paraphrases which are either inappropriate, or only appropriate in certain contexts. Since we require any changes to be imperceptible to a human observer, it is crucial to our system that any uses of paraphrasing are grammatical and retain the meaning of the original cover text."
    },
    {
        "gold": {
            "text": [
                "For example, a standard image stegosystem uses the least-significant-bit (LSB) substitution technique.",
                "Since the difference between 11111111 and 11111110 in the value for red/green/blue intensity is likely to be undetectable by the human eye, the LSB can be used to hide information other than colour, without being perceptable by a human observer. 1",
                " key question for any steganography system is the choice of cover medium.",
                "Given the ubiquitous nature of natural languages and electronic text, text is an obvious medium to consider.",
                "However , the literature on Linguistic Steganography , in which linguistic properties of a text are modified to hide information , is small compared with other media ( #TARGET_REF ) .",
                "The likely reason is that it is easier to make changes to images and other nonlinguistic media which are undetectable by an observer.",
                "Language has the property that even small local changes to a text, e.g.",
                "replacing a word by a word with similar meaning, may result in text which is anomalous at the document level, or anomalous with respect to the state of the world.",
                "Hence finding linguistic transformations which can be applied reliably and often is a challenging problem for Linguistic Steganography."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:For example, a standard image stegosystem uses the least-significant-bit (LSB) substitution technique. Since the difference between 11111111 and 11111110 in the value for red/green/blue intensity is likely to be undetectable by the human eye, the LSB can be used to hide information other than colour, without being perceptable by a human observer. 1  key question for any steganography system is the choice of cover medium. Given the ubiquitous nature of natural languages and electronic text, text is an obvious medium to consider. However , the literature on Linguistic Steganography , in which linguistic properties of a text are modified to hide information , is small compared with other media ( #TARGET_REF ) . The likely reason is that it is easier to make changes to images and other nonlinguistic media which are undetectable by an observer. Language has the property that even small local changes to a text, e.g. replacing a word by a word with similar meaning, may result in text which is anomalous at the document level, or anomalous with respect to the state of the world. Hence finding linguistic transformations which can be applied reliably and often is a challenging problem for Linguistic Steganography.",
        "output": "introduction:For example, a standard image stegosystem uses the least-significant-bit (LSB) substitution technique. Since the difference between 11111111 and 11111110 in the value for red/green/blue intensity is likely to be undetectable by the human eye, the LSB can be used to hide information other than colour, without being perceptable by a human observer. 1  key question for any steganography system is the choice of cover medium. Given the ubiquitous nature of natural languages and electronic text, text is an obvious medium to consider. However , the literature on Linguistic Steganography , in which linguistic properties of a text are modified to hide information , is small compared with other media ( #TARGET_REF<BACKGROUND/> ) . The likely reason is that it is easier to make changes to images and other nonlinguistic media which are undetectable by an observer. Language has the property that even small local changes to a text, e.g. replacing a word by a word with similar meaning, may result in text which is anomalous at the document level, or anomalous with respect to the state of the world. Hence finding linguistic transformations which can be applied reliably and often is a challenging problem for Linguistic Steganography."
    },
    {
        "gold": {
            "text": [
                "In order to improve the grammaticality checking, we use a parser as an addition to the basic Google ngram method.",
                "We use the #TARGET_REF CCG parser to analyse the sentence before and after paraphrasing .",
                "Combinatory Categorial Grammar (CCG) is a lexicalised grammar formalism, in which CCG lexical categories -typically expressing subcategorisation information -are assigned to each word in a sentence.",
                "The grammatical check works by checking if the words in the sentence outside of the phrase and paraphrase receive the same lexical categories before and after paraphrasing.",
                "If there is any change in lexical category assignment to these words then the paraphrase is judged ungrammatical.",
                "Hence the grammar check is at the word, rather than derivation, level; however, CCG lexical categories contain a large amount of syntactic information which this method is able to exploit."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:In order to improve the grammaticality checking, we use a parser as an addition to the basic Google ngram method. We use the #TARGET_REF CCG parser to analyse the sentence before and after paraphrasing . Combinatory Categorial Grammar (CCG) is a lexicalised grammar formalism, in which CCG lexical categories -typically expressing subcategorisation information -are assigned to each word in a sentence. The grammatical check works by checking if the words in the sentence outside of the phrase and paraphrase receive the same lexical categories before and after paraphrasing. If there is any change in lexical category assignment to these words then the paraphrase is judged ungrammatical. Hence the grammar check is at the word, rather than derivation, level; however, CCG lexical categories contain a large amount of syntactic information which this method is able to exploit.",
        "output": "method:In order to improve the grammaticality checking, we use a parser as an addition to the basic Google ngram method. We use the #TARGET_REF<FUTURE/> CCG parser to analyse the sentence before and after paraphrasing . Combinatory Categorial Grammar (CCG) is a lexicalised grammar formalism, in which CCG lexical categories -typically expressing subcategorisation information -are assigned to each word in a sentence. The grammatical check works by checking if the words in the sentence outside of the phrase and paraphrase receive the same lexical categories before and after paraphrasing. If there is any change in lexical category assignment to these words then the paraphrase is judged ungrammatical. Hence the grammar check is at the word, rather than derivation, level; however, CCG lexical categories contain a large amount of syntactic information which this method is able to exploit."
    },
    {
        "gold": {
            "text": [
                "The second and the most widely used manipulations for linguistic steganography are syntactic transformations.",
                "This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting.",
                "The first syntactic transformation method is presented by Atallah et al. (2001a).",
                "Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences.",
                "In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences.",
                "#REF , #TARGET_REF , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category .",
                "After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools.",
                "Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #TARGET_REF , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method.",
        "output": "related work:The second and the most widely used manipulations for linguistic steganography are syntactic transformations. This method is based on the fact that a sentence can be transformed into more than one semantically equivalent syntactic structure, using transformations such as passivization, topicalization and clefting. The first syntactic transformation method is presented by Atallah et al. (2001a). Later, Atallah et al. (2001b) embedded information in the tree structure of the text by adjusting the structural properties of intermediate representations of sentences. In other words, instead of performing lexical substitution directly to the text, the secret message is embedded into syntactic parse trees of the sentences. #REF , #TARGET_REF<BACKGROUND/> , #REF , #REF and Topkara et al. ( 2006a ) all belong to the syntactic transformation category . After embedding the secret message, modified deep structure forms are converted into the surface structure format via language generation tools. Atallah et al. (2001b) and Topkara et al. (2006a) attained the embedding capacity of 0.5 bits per sentence with the syntactic transformation method."
    },
    {
        "gold": {
            "text": [
                "In our previous work ( #TARGET_REF ; #REF ) , we applied our approach to tokenized Arabic and our DA-MSA transfer component used feature transfer rules only .",
                "We did not use a language model to pick the best path; instead we kept the ambiguity in the lattice and passed it to our SMT system.",
                "In contrast, in this paper, we run ELISSA on untokenized Arabic, we use feature, lemma, and surface form transfer rules, and we pick the best path of the generated MSA lattice through a language model.",
                "Certain aspects of our approach are similar to #REF's, in that we use morphological analysis for DA to help DA-English MT; but unlike them, we use a rule-based approach to model DA morphology."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:In our previous work ( #TARGET_REF ; #REF ) , we applied our approach to tokenized Arabic and our DA-MSA transfer component used feature transfer rules only . We did not use a language model to pick the best path; instead we kept the ambiguity in the lattice and passed it to our SMT system. In contrast, in this paper, we run ELISSA on untokenized Arabic, we use feature, lemma, and surface form transfer rules, and we pick the best path of the generated MSA lattice through a language model. Certain aspects of our approach are similar to #REF's, in that we use morphological analysis for DA to help DA-English MT; but unlike them, we use a rule-based approach to model DA morphology.",
        "output": "related work:In our previous work ( #TARGET_REF<USE/> ; #REF ) , we applied our approach to tokenized Arabic and our DA-MSA transfer component used feature transfer rules only . We did not use a language model to pick the best path; instead we kept the ambiguity in the lattice and passed it to our SMT system. In contrast, in this paper, we run ELISSA on untokenized Arabic, we use feature, lemma, and surface form transfer rules, and we pick the best path of the generated MSA lattice through a language model. Certain aspects of our approach are similar to #REF's, in that we use morphological analysis for DA to help DA-English MT; but unlike them, we use a rule-based approach to model DA morphology."
    },
    {
        "gold": {
            "text": [
                "We use the open-source Moses toolkit (#REF) to build a phrase-based SMT system trained on mostly MSA data (64M words on the Arabic side) obtained from several LDC corpora including some limited DA data.",
                "Our system uses a standard phrase-based architecture.",
                "The parallel corpus is word-aligned using GIZA + + ( #TARGET_REF ) .",
                "Phrase translations of up to 10 words are extracted in the Moses phrase table.",
                "The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF).",
                "We use a 5-gram language model with modified Kneser-Ney smoothing.",
                "Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF).",
                "This is only done on the baseline systems.",
                "The English data is tokenized using simple punctuation-based rules.",
                "The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF).",
                "The Arabic text is also Alif/Ya normalized.",
                "MADA-produced Arabic lemmas are used for word alignment."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:We use the open-source Moses toolkit (#REF) to build a phrase-based SMT system trained on mostly MSA data (64M words on the Arabic side) obtained from several LDC corpora including some limited DA data. Our system uses a standard phrase-based architecture. The parallel corpus is word-aligned using GIZA + + ( #TARGET_REF ) . Phrase translations of up to 10 words are extracted in the Moses phrase table. The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF). We use a 5-gram language model with modified Kneser-Ney smoothing. Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF). This is only done on the baseline systems. The English data is tokenized using simple punctuation-based rules. The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF). The Arabic text is also Alif/Ya normalized. MADA-produced Arabic lemmas are used for word alignment.",
        "output": "nan:We use the open-source Moses toolkit (#REF) to build a phrase-based SMT system trained on mostly MSA data (64M words on the Arabic side) obtained from several LDC corpora including some limited DA data. Our system uses a standard phrase-based architecture. The parallel corpus is word-aligned using GIZA + + ( #TARGET_REF<FUTURE/> ) . Phrase translations of up to 10 words are extracted in the Moses phrase table. The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF). We use a 5-gram language model with modified Kneser-Ney smoothing. Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF). This is only done on the baseline systems. The English data is tokenized using simple punctuation-based rules. The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF). The Arabic text is also Alif/Ya normalized. MADA-produced Arabic lemmas are used for word alignment."
    },
    {
        "gold": {
            "text": [
                "In the last system group, phrase+word-based selection, phrase-based selection is used to select phrases and add them on top of the best performers of the previous two groups.",
                "Phrase-based trans-  lation is also added to word-based translation.",
                "Results show that selecting and translating phrases improve the three best performers of word-based selection.",
                "The best performer, shown in the last raw, suggests using phrase-based selection and restricted word-based selection.",
                "The restriction is to include OOV words and selected low frequency words that have at least one dialectal analysis or appear in our dialectal dictionaries.",
                "Comparing the best performer to the OOV selection mode system shows that translating low frequency in-vocabulary dialectal words and phrases to their MSA paraphrases can improve the English translation.",
                "This is a similar conclusion to our previous work in #TARGET_REF ."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "nan:In the last system group, phrase+word-based selection, phrase-based selection is used to select phrases and add them on top of the best performers of the previous two groups. Phrase-based trans-  lation is also added to word-based translation. Results show that selecting and translating phrases improve the three best performers of word-based selection. The best performer, shown in the last raw, suggests using phrase-based selection and restricted word-based selection. The restriction is to include OOV words and selected low frequency words that have at least one dialectal analysis or appear in our dialectal dictionaries. Comparing the best performer to the OOV selection mode system shows that translating low frequency in-vocabulary dialectal words and phrases to their MSA paraphrases can improve the English translation. This is a similar conclusion to our previous work in #TARGET_REF .",
        "output": "nan:In the last system group, phrase+word-based selection, phrase-based selection is used to select phrases and add them on top of the best performers of the previous two groups. Phrase-based trans-  lation is also added to word-based translation. Results show that selecting and translating phrases improve the three best performers of word-based selection. The best performer, shown in the last raw, suggests using phrase-based selection and restricted word-based selection. The restriction is to include OOV words and selected low frequency words that have at least one dialectal analysis or appear in our dialectal dictionaries. Comparing the best performer to the OOV selection mode system shows that translating low frequency in-vocabulary dialectal words and phrases to their MSA paraphrases can improve the English translation. This is a similar conclusion to our previous work in #TARGET_REF<USE/> ."
    },
    {
        "gold": {
            "text": [
                "We use the open-source Moses toolkit ( #TARGET_REF ) to build a phrase-based SMT system trained on mostly MSA data ( 64M words on the Arabic side ) obtained from several LDC corpora including some limited DA data .",
                "Our system uses a standard phrase-based architecture.",
                "The parallel corpus is word-aligned using GIZA++ (#REF).",
                "Phrase translations of up to 10 words are extracted in the Moses phrase table.",
                "The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF).",
                "We use a 5-gram language model with modified Kneser-Ney smoothing.",
                "Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF).",
                "This is only done on the baseline systems.",
                "The English data is tokenized using simple punctuation-based rules.",
                "The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF).",
                "The Arabic text is also Alif/Ya normalized.",
                "MADA-produced Arabic lemmas are used for word alignment."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "nan:We use the open-source Moses toolkit ( #TARGET_REF ) to build a phrase-based SMT system trained on mostly MSA data ( 64M words on the Arabic side ) obtained from several LDC corpora including some limited DA data . Our system uses a standard phrase-based architecture. The parallel corpus is word-aligned using GIZA++ (#REF). Phrase translations of up to 10 words are extracted in the Moses phrase table. The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF). We use a 5-gram language model with modified Kneser-Ney smoothing. Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF). This is only done on the baseline systems. The English data is tokenized using simple punctuation-based rules. The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF). The Arabic text is also Alif/Ya normalized. MADA-produced Arabic lemmas are used for word alignment.",
        "output": "nan:We use the open-source Moses toolkit ( #TARGET_REF<FUTURE/> ) to build a phrase-based SMT system trained on mostly MSA data ( 64M words on the Arabic side ) obtained from several LDC corpora including some limited DA data . Our system uses a standard phrase-based architecture. The parallel corpus is word-aligned using GIZA++ (#REF). Phrase translations of up to 10 words are extracted in the Moses phrase table. The language model for our system is trained on the English side of the bitext augmented with English Gigaword (#REF). We use a 5-gram language model with modified Kneser-Ney smoothing. Feature weights are tuned to maximize BLEU on the NIST MT#REF test set using Minimum Error Rate Training (#REF). This is only done on the baseline systems. The English data is tokenized using simple punctuation-based rules. The Arabic side is segmented according to the Arabic Treebank (ATB) tokenization scheme (#REF) using the MADA+TOKAN morphological analyzer and tokenizer v3.1 (#REF;#REF). The Arabic text is also Alif/Ya normalized. MADA-produced Arabic lemmas are used for word alignment."
    },
    {
        "gold": {
            "text": [
                "The rate is lower for speech to machines (#REF;#REF), due in part to utterance length; that is, disfluency rates are higher in longer utterances, where planning is more difficult, and utterances addressed to machines tend to be shorter than those addressed to people, often because dialogue interfaces are designed to take on more initiative.",
                "The average speaker may believe, quite rightly, that machines are imperfect speech processors, and plan their utterances to machines more carefully.",
                "The good news is that speakers can adapt to machines; the bad news is that they do so by recruiting limited cognitive resources that could otherwise be focused on the task itself.",
                "As for the second assumption, if the goal is to eventually process unrestricted, natural human speech, then committing to an early and exclusive focus on processing fluent utterances is risky.",
                "In humans, speech production and speech processing are done incrementally, using contextual information from the earliest moments of processing (see, e.g., #REF).",
                "This sort of processing requires quite a different architecture and different mechanisms for ambiguity resolution than one that begins processing only at the end of a complete and well-formed utterance.",
                "Few approaches to parsing have tried to handle disfluent utterances ( notable exceptions are Core & #REF ; #TARGET_REF ; Nakatani & #REF ; Shriberg , Bear , & #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:The rate is lower for speech to machines (#REF;#REF), due in part to utterance length; that is, disfluency rates are higher in longer utterances, where planning is more difficult, and utterances addressed to machines tend to be shorter than those addressed to people, often because dialogue interfaces are designed to take on more initiative. The average speaker may believe, quite rightly, that machines are imperfect speech processors, and plan their utterances to machines more carefully. The good news is that speakers can adapt to machines; the bad news is that they do so by recruiting limited cognitive resources that could otherwise be focused on the task itself. As for the second assumption, if the goal is to eventually process unrestricted, natural human speech, then committing to an early and exclusive focus on processing fluent utterances is risky. In humans, speech production and speech processing are done incrementally, using contextual information from the earliest moments of processing (see, e.g., #REF). This sort of processing requires quite a different architecture and different mechanisms for ambiguity resolution than one that begins processing only at the end of a complete and well-formed utterance. Few approaches to parsing have tried to handle disfluent utterances ( notable exceptions are Core & #REF ; #TARGET_REF ; Nakatani & #REF ; Shriberg , Bear , & #REF ) .",
        "output": "introduction:The rate is lower for speech to machines (#REF;#REF), due in part to utterance length; that is, disfluency rates are higher in longer utterances, where planning is more difficult, and utterances addressed to machines tend to be shorter than those addressed to people, often because dialogue interfaces are designed to take on more initiative. The average speaker may believe, quite rightly, that machines are imperfect speech processors, and plan their utterances to machines more carefully. The good news is that speakers can adapt to machines; the bad news is that they do so by recruiting limited cognitive resources that could otherwise be focused on the task itself. As for the second assumption, if the goal is to eventually process unrestricted, natural human speech, then committing to an early and exclusive focus on processing fluent utterances is risky. In humans, speech production and speech processing are done incrementally, using contextual information from the earliest moments of processing (see, e.g., #REF). This sort of processing requires quite a different architecture and different mechanisms for ambiguity resolution than one that begins processing only at the end of a complete and well-formed utterance. Few approaches to parsing have tried to handle disfluent utterances ( notable exceptions are Core & #REF ; #TARGET_REF<BACKGROUND/> ; Nakatani & #REF ; Shriberg , Bear , & #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Similar to our previous work ( #REFb ) , we used the supervised WSD approach described in ( #TARGET_REF ) for our experiments , using the naive Bayes algorithm as our classifier .",
                "Knowledge sources used include partsof-speech, surrounding words, and local collocations.",
                "This approach achieves state-of-the-art accuracy.",
                "All accuracies reported in our experiments are micro-averages over all test examples."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:Similar to our previous work ( #REFb ) , we used the supervised WSD approach described in ( #TARGET_REF ) for our experiments , using the naive Bayes algorithm as our classifier . Knowledge sources used include partsof-speech, surrounding words, and local collocations. This approach achieves state-of-the-art accuracy. All accuracies reported in our experiments are micro-averages over all test examples.",
        "output": "experiments:Similar to our previous work ( #REFb ) , we used the supervised WSD approach described in ( #TARGET_REF<FUTURE/> ) for our experiments , using the naive Bayes algorithm as our classifier . Knowledge sources used include partsof-speech, surrounding words, and local collocations. This approach achieves state-of-the-art accuracy. All accuracies reported in our experiments are micro-averages over all test examples."
    },
    {
        "gold": {
            "text": [
                "The overall tagging accuracy of our joint model was comparable to but less than the joint model of #REF.",
                "Despite the higher accuracy improvement from the baseline, the joint system did not give higher overall accuracy.",
                "One likely reason is that #REF included knowledge about special characters and semantic knowledge from web corpora (which may explain the higher baseline accuracy), while our system is completely data-driven.",
                "However, the comparison is indirect because our partitions of the CTB corpus are different.",
                "#REF also chunked the sentences before doing 10-fold cross validation, but used an uneven split.",
                "We chose to follow #TARGET_REF and split the sentences evenly to facilitate further comparison ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:The overall tagging accuracy of our joint model was comparable to but less than the joint model of #REF. Despite the higher accuracy improvement from the baseline, the joint system did not give higher overall accuracy. One likely reason is that #REF included knowledge about special characters and semantic knowledge from web corpora (which may explain the higher baseline accuracy), while our system is completely data-driven. However, the comparison is indirect because our partitions of the CTB corpus are different. #REF also chunked the sentences before doing 10-fold cross validation, but used an uneven split. We chose to follow #TARGET_REF and split the sentences evenly to facilitate further comparison .",
        "output": "experiments:The overall tagging accuracy of our joint model was comparable to but less than the joint model of #REF. Despite the higher accuracy improvement from the baseline, the joint system did not give higher overall accuracy. One likely reason is that #REF included knowledge about special characters and semantic knowledge from web corpora (which may explain the higher baseline accuracy), while our system is completely data-driven. However, the comparison is indirect because our partitions of the CTB corpus are different. #REF also chunked the sentences before doing 10-fold cross validation, but used an uneven split. We chose to follow #TARGET_REF<FUTURE/> and split the sentences evenly to facilitate further comparison ."
    },
    {
        "gold": {
            "text": [
                "We built a two-stage baseline system , using the perceptron segmentation model from our previous work ( #TARGET_REF ) and the perceptron POS tagging model from #REF .",
                "We use baseline system to refer to the system which performs segmentation first, followed by POS tagging (using the single-best segmentation); baseline segmentor to refer to the segmentor from (#REF) which performs segmentation only; and baseline POStagger to refer to the Collins tagger which performs POS tagging only (given segmentation).",
                "The features used by the baseline segmentor are shown in Table 1.",
                "The features used by the POS tagger, some of which are different to those from #REF and are specific to Chinese, are shown in Table 2."
            ],
            "label": [
                "COMPARISON"
            ]
        },
        "input": "experiments:We built a two-stage baseline system , using the perceptron segmentation model from our previous work ( #TARGET_REF ) and the perceptron POS tagging model from #REF . We use baseline system to refer to the system which performs segmentation first, followed by POS tagging (using the single-best segmentation); baseline segmentor to refer to the segmentor from (#REF) which performs segmentation only; and baseline POStagger to refer to the Collins tagger which performs POS tagging only (given segmentation). The features used by the baseline segmentor are shown in Table 1. The features used by the POS tagger, some of which are different to those from #REF and are specific to Chinese, are shown in Table 2.",
        "output": "experiments:We built a two-stage baseline system , using the perceptron segmentation model from our previous work ( #TARGET_REF<COMPARISON/> ) and the perceptron POS tagging model from #REF . We use baseline system to refer to the system which performs segmentation first, followed by POS tagging (using the single-best segmentation); baseline segmentor to refer to the segmentor from (#REF) which performs segmentation only; and baseline POStagger to refer to the Collins tagger which performs POS tagging only (given segmentation). The features used by the baseline segmentor are shown in Table 1. The features used by the POS tagger, some of which are different to those from #REF and are specific to Chinese, are shown in Table 2."
    },
    {
        "gold": {
            "text": [
                "We present an extension of the hierarchical Dirichlet process (HDP) model which is able to represent each observable object (i.e., event mention) by a finite number of feature types L.",
                "Our HDP extension is also inspired from the Bayesian model proposed by #TARGET_REF .",
                "However, their model is strictly customized for entity coreference resolution, and therefore, extending it to include additional features for each observable object is a challenging task (#REF; #REF)."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "method:We present an extension of the hierarchical Dirichlet process (HDP) model which is able to represent each observable object (i.e., event mention) by a finite number of feature types L. Our HDP extension is also inspired from the Bayesian model proposed by #TARGET_REF . However, their model is strictly customized for entity coreference resolution, and therefore, extending it to include additional features for each observable object is a challenging task (#REF; #REF).",
        "output": "method:We present an extension of the hierarchical Dirichlet process (HDP) model which is able to represent each observable object (i.e., event mention) by a finite number of feature types L. Our HDP extension is also inspired from the Bayesian model proposed by #TARGET_REF<EXTENSION/> . However, their model is strictly customized for entity coreference resolution, and therefore, extending it to include additional features for each observable object is a challenging task (#REF; #REF)."
    },
    {
        "gold": {
            "text": [
                "ME approach has the merit of easily combining different features to predict the probability of each class. We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM.",
                "These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) : 1 ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "method:ME approach has the merit of easily combining different features to predict the probability of each class. We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM. These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) : 1 .",
        "output": "method:ME approach has the merit of easily combining different features to predict the probability of each class. We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM. These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #REF ; #TARGET_REF<EXTENSION/> ; #REF ; #REF ; #REF ; #REF ) : 1 ."
    },
    {
        "gold": {
            "text": [
                "ME approach has the merit of easily combining different features to predict the probability of each class.",
                "We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM.",
                "These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) : 1 ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "method:ME approach has the merit of easily combining different features to predict the probability of each class. We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM. These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) : 1 .",
        "output": "method:ME approach has the merit of easily combining different features to predict the probability of each class. We incorporate into the ME based model the following informative context-based features to train CBSM and CBTM. These features are carefully designed to reduce the data sparseness problem and some of them are inspired by previous work ( #REF ; #TARGET_REF<EXTENSION/> ; #REF ; #REF ; #REF ; #REF ; #REF ) : 1 ."
    },
    {
        "gold": {
            "text": [
                "More recently , an alignment selection approach was proposed in ( #TARGET_REF ) , which computes confidence scores for each link and prunes the links from multiple sets of alignments using a hand-picked threshold .",
                "The alignments used in that work were generated from different aligners (HMM, block model, and maximum entropy model).",
                "In this work, we use soft voting with weighted confidence scores, where the weights can be tuned with a specific objective function.",
                "There is no need for a pre-determined threshold as used in (#REF).",
                "Also, we utilize various knowledge sources to enrich the alignments instead of using different aligners.",
                "Our strategy is to diversify and then combine in order to catch any complementary information captured in the word alignments for low-resource languages."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "introduction:More recently , an alignment selection approach was proposed in ( #TARGET_REF ) , which computes confidence scores for each link and prunes the links from multiple sets of alignments using a hand-picked threshold . The alignments used in that work were generated from different aligners (HMM, block model, and maximum entropy model). In this work, we use soft voting with weighted confidence scores, where the weights can be tuned with a specific objective function. There is no need for a pre-determined threshold as used in (#REF). Also, we utilize various knowledge sources to enrich the alignments instead of using different aligners. Our strategy is to diversify and then combine in order to catch any complementary information captured in the word alignments for low-resource languages.",
        "output": "introduction:More recently , an alignment selection approach was proposed in ( #TARGET_REF<USE/> ) , which computes confidence scores for each link and prunes the links from multiple sets of alignments using a hand-picked threshold . The alignments used in that work were generated from different aligners (HMM, block model, and maximum entropy model). In this work, we use soft voting with weighted confidence scores, where the weights can be tuned with a specific objective function. There is no need for a pre-determined threshold as used in (#REF). Also, we utilize various knowledge sources to enrich the alignments instead of using different aligners. Our strategy is to diversify and then combine in order to catch any complementary information captured in the word alignments for low-resource languages."
    },
    {
        "gold": {
            "text": [
                "We introduce two types of chunks.",
                "The first is simply the phrase type, such as NP, PP, of current chunk.",
                "The column CHUNK 1 illustrates this kind of chunk type definition.",
                "The second is more complicated.",
                "Inspired by ( #TARGET_REF ) , we split one phrase type into several subsymbols , which contain category information of current constituent 's parent .",
                "For example, an NP immediately dominated by a S, will be substituted by NPˆS.",
                "This strategy severely increases the number of chunk types and make it hard to train chunking models.",
                "To shrink this number, we linguistically use a cluster of CTB phrasal types, which was introduced in .",
                "The column CHUNK 2 illustrates this definition.",
                "E.g., NPˆS implicitly represents Subject while NPˆVP represents Object."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:We introduce two types of chunks. The first is simply the phrase type, such as NP, PP, of current chunk. The column CHUNK 1 illustrates this kind of chunk type definition. The second is more complicated. Inspired by ( #TARGET_REF ) , we split one phrase type into several subsymbols , which contain category information of current constituent 's parent . For example, an NP immediately dominated by a S, will be substituted by NPˆS. This strategy severely increases the number of chunk types and make it hard to train chunking models. To shrink this number, we linguistically use a cluster of CTB phrasal types, which was introduced in . The column CHUNK 2 illustrates this definition. E.g., NPˆS implicitly represents Subject while NPˆVP represents Object.",
        "output": "nan:We introduce two types of chunks. The first is simply the phrase type, such as NP, PP, of current chunk. The column CHUNK 1 illustrates this kind of chunk type definition. The second is more complicated. Inspired by ( #TARGET_REF<EXTENSION/> ) , we split one phrase type into several subsymbols , which contain category information of current constituent 's parent . For example, an NP immediately dominated by a S, will be substituted by NPˆS. This strategy severely increases the number of chunk types and make it hard to train chunking models. To shrink this number, we linguistically use a cluster of CTB phrasal types, which was introduced in . The column CHUNK 2 illustrates this definition. E.g., NPˆS implicitly represents Subject while NPˆVP represents Object."
    },
    {
        "gold": {
            "text": [
                "The feature of head word trigger which we apply to the log-linear model is motivated by the trigger-based approach ( #TARGET_REF ) .",
                "#REF introduced a second word to trigger the target word without considering any linguistic information.",
                "Furthermore, since the second word can come from any part of the sentence, there may be a prohibitively large number of parameters involved.",
                "Besides, #REF built a maximum entropy model which combines rich context information for selecting translation rules during decoding.",
                "However, as the size of the corpus increases, the maximum entropy model will become larger.",
                "Similarly, In (#REF), context language model is proposed for better rule selection.",
                "Taking the dependency edge as condition, our approach is very different from previous approaches of exploring context information."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "related work:The feature of head word trigger which we apply to the log-linear model is motivated by the trigger-based approach ( #TARGET_REF ) . #REF introduced a second word to trigger the target word without considering any linguistic information. Furthermore, since the second word can come from any part of the sentence, there may be a prohibitively large number of parameters involved. Besides, #REF built a maximum entropy model which combines rich context information for selecting translation rules during decoding. However, as the size of the corpus increases, the maximum entropy model will become larger. Similarly, In (#REF), context language model is proposed for better rule selection. Taking the dependency edge as condition, our approach is very different from previous approaches of exploring context information.",
        "output": "related work:The feature of head word trigger which we apply to the log-linear model is motivated by the trigger-based approach ( #TARGET_REF<EXTENSION/> ) . #REF introduced a second word to trigger the target word without considering any linguistic information. Furthermore, since the second word can come from any part of the sentence, there may be a prohibitively large number of parameters involved. Besides, #REF built a maximum entropy model which combines rich context information for selecting translation rules during decoding. However, as the size of the corpus increases, the maximum entropy model will become larger. Similarly, In (#REF), context language model is proposed for better rule selection. Taking the dependency edge as condition, our approach is very different from previous approaches of exploring context information."
    },
    {
        "gold": {
            "text": [
                "Previous sentiment-analysis work in different domains has considered inter-document similarity (#REF; #REF; #REF) or explicit inter-document references in the form of hyperlinks ( #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity (#REF; #REF; #REF) or explicit inter-document references in the form of hyperlinks ( #TARGET_REF ) .",
        "output": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity (#REF; #REF; #REF) or explicit inter-document references in the form of hyperlinks ( #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF).",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #TARGET_REF ; #REF ; #REF ) .",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #TARGET_REF ; #REF ; #REF ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ; #REF ) .",
                "It would be interesting to investigate the application of such methods to our problem.",
                "However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF).",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #TARGET_REF ; #REF ) .",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #TARGET_REF ; #REF ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author , where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "Notable early papers on graph-based semisupervised learning include #REF , #REF , #REF , and #TARGET_REF .",
                "#REF maintains a survey of this area."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Notable early papers on graph-based semisupervised learning include #REF , #REF , #REF , and #TARGET_REF . #REF maintains a survey of this area.",
        "output": "related work:Notable early papers on graph-based semisupervised learning include #REF , #REF , #REF , and #TARGET_REF<BACKGROUND/> . #REF maintains a survey of this area."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ; #REF ) .",
                "It would be inter- esting to investigate the application of such meth- ods to our problem.",
                "However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ; #REF ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ; #REF ; #REF ; #REF ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "More sophisticated approaches have been proposed ( #TARGET_REF ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #REF ) .",
                "Also relevant is work on the gen- eral problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF; #REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:More sophisticated approaches have been proposed ( #TARGET_REF ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #REF ) . Also relevant is work on the gen- eral problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF; #REF).",
        "output": "related work:More sophisticated approaches have been proposed ( #TARGET_REF<BACKGROUND/> ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #REF ) . Also relevant is work on the gen- eral problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF; #REF)."
    },
    {
        "gold": {
            "text": [
                "We used a simple method to learn to identify cross-speaker references indicating agreement.",
                "More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF).",
                "Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #TARGET_REF ; #REF ) .",
        "output": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #TARGET_REF<BACKGROUND/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #REF ; #TARGET_REF ) .",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF).",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #REF ; #TARGET_REF ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "Most sentiment-polarity classifiers proposed in the recent literature categorize each document in- dependently. A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF).",
                "Many interesting opinion-oriented docu- ments, however, can be linked through certain re- lationships that occur in the context of evaluative discussions.",
                "For example, we may find textual4 evidence of a high likelihood of agreement be-tween two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings (see #REF but cfXXX #TARGET_REF.",
                "Agreement evidence can be a powerful aid in our classification task: for ex- ample, we can easily categorize a complicated (or overly terse) document if we find within it indica- tions of agreement with a clearly positive text."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document in- dependently. A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF). Many interesting opinion-oriented docu- ments, however, can be linked through certain re- lationships that occur in the context of evaluative discussions. For example, we may find textual4 evidence of a high likelihood of agreement be-tween two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings (see #REF but cfXXX #TARGET_REF. Agreement evidence can be a powerful aid in our classification task: for ex- ample, we can easily categorize a complicated (or overly terse) document if we find within it indica- tions of agreement with a clearly positive text.",
        "output": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document in- dependently. A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF). Many interesting opinion-oriented docu- ments, however, can be linked through certain re- lationships that occur in the context of evaluative discussions. For example, we may find textual4 evidence of a high likelihood of agreement be-tween two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings (see #REF but cfXXX #TARGET_REF<BACKGROUND/>. Agreement evidence can be a powerful aid in our classification task: for ex- ample, we can easily categorize a complicated (or overly terse) document if we find within it indica- tions of agreement with a clearly positive text."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF).",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #REF ; #TARGET_REF ) .",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #REF ; #TARGET_REF ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) . An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "In our experiments, we employed the well-known classifier SVMlight to obtain individual-document classification scores, treating Y as the positive class and using plain unigrams as features.5",
                "Fol- lowing standard practice in sentiment analysis ( #TARGET_REF ) , the input to SVMlight con- sisted of normalized presence-of-feature (rather than frequency-of-feature) vectors.",
                "The ind value for each speech segment s was based on the signed distanceds fromthevectorrepresentingstothe trained SVM decision plane: \u000e � ds \u000e23�4s� d s �23�4s� ds ��23�4s def ds = \u000e+ 23�4s 2 ind s;Y where 3�4s is the standard deviation of d s over all speech segments s in the debate in question, and def ind s;N = \u000e�ind s;Y ."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:In our experiments, we employed the well-known classifier SVMlight to obtain individual-document classification scores, treating Y as the positive class and using plain unigrams as features.5 Fol- lowing standard practice in sentiment analysis ( #TARGET_REF ) , the input to SVMlight con- sisted of normalized presence-of-feature (rather than frequency-of-feature) vectors. The ind value for each speech segment s was based on the signed distanceds fromthevectorrepresentingstothe trained SVM decision plane: \u000e � ds \u000e23�4s� d s �23�4s� ds ��23�4s def ds = \u000e+ 23�4s 2 ind s;Y where 3�4s is the standard deviation of d s over all speech segments s in the debate in question, and def ind s;N = \u000e�ind s;Y .",
        "output": "method:In our experiments, we employed the well-known classifier SVMlight to obtain individual-document classification scores, treating Y as the positive class and using plain unigrams as features.5 Fol- lowing standard practice in sentiment analysis ( #TARGET_REF<FUTURE/> ) , the input to SVMlight con- sisted of normalized presence-of-feature (rather than frequency-of-feature) vectors. The ind value for each speech segment s was based on the signed distanceds fromthevectorrepresentingstothe trained SVM decision plane: \u000e � ds \u000e23�4s� d s �23�4s� ds ��23�4s def ds = \u000e+ 23�4s 2 ind s;Y where 3�4s is the standard deviation of d s over all speech segments s in the debate in question, and def ind s;N = \u000e�ind s;Y ."
    },
    {
        "gold": {
            "text": [
                "Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #REF ; #TARGET_REF ) .",
        "output": "related work:Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #REF ; #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF ) .",
                "It would be inter- esting to investigate the application of such meth- ods to our problem.",
                "However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography).",
                "In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #TARGET_REF ; #REF ) .",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Previous sentiment-analysis work in different domains has considered inter-document similarity ( #TARGET_REF ; #REF ; #REF ) or explicit inter-document references in the form of hyper- links (#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #TARGET_REF ; #REF ; #REF ) or explicit inter-document references in the form of hyper- links (#REF).",
        "output": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) or explicit inter-document references in the form of hyper- links (#REF)."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) .",
                "It would be inter- esting to investigate the application of such meth- ods to our problem.",
                "However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ; #REF ; #REF ) . It would be inter- esting to investigate the application of such meth- ods to our problem. However, we also believe that our approach has important advantages, in- cluding conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "SVMlight is available at svmlight.joachims.org.",
                "Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "method:SVMlight is available at svmlight.joachims.org. Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #TARGET_REF ; #REF ) .",
        "output": "method:SVMlight is available at svmlight.joachims.org. Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #TARGET_REF<MOTIVATION/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "We used a simple method to learn to identify cross-speaker references indicating agreement.",
                "More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF).",
                "Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #TARGET_REF ) , and computational rhetorical analysis ( #REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #TARGET_REF ) , and computational rhetorical analysis ( #REF ; #REF ) .",
        "output": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #TARGET_REF<BACKGROUND/> ) , and computational rhetorical analysis ( #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently.",
                "A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #TARGET_REF ; #REF ) .",
                "Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions.",
                "For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information.",
                "For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data.",
                "Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #TARGET_REF ; #REF ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available.",
        "output": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
    },
    {
        "gold": {
            "text": [
                "Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently.",
                "A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #TARGET_REF ; #REF ; #REF ) .",
                "Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions.",
                "For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information.",
                "For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data.",
                "Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #TARGET_REF ; #REF ; #REF ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available.",
        "output": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
    },
    {
        "gold": {
            "text": [
                "Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently.",
                "A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #REF ; #TARGET_REF ) .",
                "Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions.",
                "For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information.",
                "For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data.",
                "Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #REF ; #TARGET_REF ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available.",
        "output": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) . Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual 4 evidence of a high likelihood of agreement be- 4 Because we are most interested in techniques applicable across domains, we restrict consideration to NLP aspects of the problem, ignoring external problem-specific information. For example, although most votes in our corpus were almost completely along party lines (and despite the fact that sameparty information is easily incorporated via the methods we propose), we did not use party-affiliation data. Indeed, in other settings (e.g., a movie-discussion listserv) one may not be able to determine the participants' political leanings, and such information may not lead to significantly improved results even if it were available."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) .",
                "It would be interesting to investigate the application of such methods to our problem.",
                "However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "We used a simple method to learn to identify cross-speaker references indicating agreement.",
                "More sophisticated approaches have been proposed ( #REF ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #TARGET_REF ) .",
                "Also relevant is work on the general problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF;#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed ( #REF ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #TARGET_REF ) . Also relevant is work on the general problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF;#REF).",
        "output": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed ( #REF ) , including an extension that , in an interesting reversal of our problem , makes use of sentimentpolarity indicators within speech segments ( #TARGET_REF<BACKGROUND/> ) . Also relevant is work on the general problems of dialog-act tagging (#REF), citation analysis (#REF), and computational rhetorical analysis (#REF;#REF)."
    },
    {
        "gold": {
            "text": [
                "As has been previously observed and exploited in the NLP literature ( #TARGET_REF ; #REF ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs .",
                "In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:As has been previously observed and exploited in the NLP literature ( #TARGET_REF ; #REF ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision.",
        "output": "method:As has been previously observed and exploited in the NLP literature ( #TARGET_REF<USE/> ; #REF ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ) .",
                "It would be interesting to investigate the application of such methods to our problem.",
                "However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "In the United States , for example , governmental bodies are providing and soliciting political documents via the Internet , with lofty goals in mind : electronic rulemaking ( eRulemaking ) initiatives involving the `` electronic collection , distribution , synthesis , and analysis of public commentary in the regulatory rulemaking process '' , may `` [ alter ] the citizen-government relationship '' ( #TARGET_REF ) .",
                "Additionally, much media attention has been focused recently on the potential impact that Internet sites may have on politics 2 , or at least on political journalism 3 .",
                "Regardless of whether one views such claims as clear-sighted prophecy or mere hype, it is obviously important to help people understand and analyze politically oriented text, given the importance of enabling informed participation in the political process."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:In the United States , for example , governmental bodies are providing and soliciting political documents via the Internet , with lofty goals in mind : electronic rulemaking ( eRulemaking ) initiatives involving the `` electronic collection , distribution , synthesis , and analysis of public commentary in the regulatory rulemaking process '' , may `` [ alter ] the citizen-government relationship '' ( #TARGET_REF ) . Additionally, much media attention has been focused recently on the potential impact that Internet sites may have on politics 2 , or at least on political journalism 3 . Regardless of whether one views such claims as clear-sighted prophecy or mere hype, it is obviously important to help people understand and analyze politically oriented text, given the importance of enabling informed participation in the political process.",
        "output": "introduction:In the United States , for example , governmental bodies are providing and soliciting political documents via the Internet , with lofty goals in mind : electronic rulemaking ( eRulemaking ) initiatives involving the `` electronic collection , distribution , synthesis , and analysis of public commentary in the regulatory rulemaking process '' , may `` [ alter ] the citizen-government relationship '' ( #TARGET_REF<BACKGROUND/> ) . Additionally, much media attention has been focused recently on the potential impact that Internet sites may have on politics 2 , or at least on political journalism 3 . Regardless of whether one views such claims as clear-sighted prophecy or mere hype, it is obviously important to help people understand and analyze politically oriented text, given the importance of enabling informed participation in the political process."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography).",
                "In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #TARGET_REF ; #REF ; #REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #TARGET_REF ; #REF ; #REF ; #REF ) .",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Notable early papers on graph-based semisupervised learning include #REF, #REF, Kondor and#REF, and#REF.",
                "#TARGET_REF maintains a survey of this area ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Notable early papers on graph-based semisupervised learning include #REF, #REF, Kondor and#REF, and#REF. #TARGET_REF maintains a survey of this area .",
        "output": "related work:Notable early papers on graph-based semisupervised learning include #REF, #REF, Kondor and#REF, and#REF. #TARGET_REF<BACKGROUND/> maintains a survey of this area ."
    },
    {
        "gold": {
            "text": [
                "Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #TARGET_REF ; #REF ) or explicit inter-document references in the form of hyperlinks (#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #TARGET_REF ; #REF ) or explicit inter-document references in the form of hyperlinks (#REF).",
        "output": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) or explicit inter-document references in the form of hyperlinks (#REF)."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #TARGET_REF , and #REF ; see #REF for an active bibliography ) .",
                "In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #TARGET_REF , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF).",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #TARGET_REF<BACKGROUND/> , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
    },
    {
        "gold": {
            "text": [
                "As has been previously observed and exploited in the NLP literature ( #REF ; #TARGET_REF ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs .",
                "In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:As has been previously observed and exploited in the NLP literature ( #REF ; #TARGET_REF ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision.",
        "output": "method:As has been previously observed and exploited in the NLP literature ( #REF ; #TARGET_REF<USE/> ; #REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
    },
    {
        "gold": {
            "text": [
                "The support/oppose classification problem can be approached through the use of standard classifiers such as support vector machines (SVMs), which consider each text unit in isolation.",
                "As discussed in Section 1, however, the conversational nature of our data implies the existence of various relationships that can be exploited to improve cumulative classification accuracy for speech segments belonging to the same debate.",
                "Our classification framework , directly inspired by #TARGET_REF , integrates both perspectives , optimizing its labeling of speech segments based on both individual speech-segment classification scores and preferences for groups of speech segments to receive the same label .",
                "In this section, we discuss the specific classification framework that we adopt and the set of mechanisms that we propose for modeling specific types of relationships."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "method:The support/oppose classification problem can be approached through the use of standard classifiers such as support vector machines (SVMs), which consider each text unit in isolation. As discussed in Section 1, however, the conversational nature of our data implies the existence of various relationships that can be exploited to improve cumulative classification accuracy for speech segments belonging to the same debate. Our classification framework , directly inspired by #TARGET_REF , integrates both perspectives , optimizing its labeling of speech segments based on both individual speech-segment classification scores and preferences for groups of speech segments to receive the same label . In this section, we discuss the specific classification framework that we adopt and the set of mechanisms that we propose for modeling specific types of relationships.",
        "output": "method:The support/oppose classification problem can be approached through the use of standard classifiers such as support vector machines (SVMs), which consider each text unit in isolation. As discussed in Section 1, however, the conversational nature of our data implies the existence of various relationships that can be exploited to improve cumulative classification accuracy for speech segments belonging to the same debate. Our classification framework , directly inspired by #TARGET_REF<FUTURE/> , integrates both perspectives , optimizing its labeling of speech segments based on both individual speech-segment classification scores and preferences for groups of speech segments to receive the same label . In this section, we discuss the specific classification framework that we adopt and the set of mechanisms that we propose for modeling specific types of relationships."
    },
    {
        "gold": {
            "text": [
                "Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #TARGET_REF ; #REF ) .",
        "output": "related work:Others have applied the NLP technologies of near-duplicate detection and topic-based text categorization to politically oriented text ( #TARGET_REF<BACKGROUND/> ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #REF , and #TARGET_REF ; see #REF for an active bibliography ) .",
                "In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #REF , and #TARGET_REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF).",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #REF , #REF , and #TARGET_REF<BACKGROUND/> ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
    },
    {
        "gold": {
            "text": [
                "Notable early papers on graph-based semisupervised learning include #TARGET_REF , #REF , #REF , and #REF .",
                "#REF maintains a survey of this area."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Notable early papers on graph-based semisupervised learning include #TARGET_REF , #REF , #REF , and #REF . #REF maintains a survey of this area.",
        "output": "related work:Notable early papers on graph-based semisupervised learning include #TARGET_REF<BACKGROUND/> , #REF , #REF , and #REF . #REF maintains a survey of this area."
    },
    {
        "gold": {
            "text": [
                "We currently do not have an efficient means to encode disagreement information as hard constraints; we plan to investigate incorporating such information in future work.",
                "Relationships between the unlabeled items #TARGET_REF consider sequential relations between different types of emails ( e.g. , between requests and satisfactions thereof ) to classify messages , and thus also explicitly exploit the structure of conversations ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:We currently do not have an efficient means to encode disagreement information as hard constraints; we plan to investigate incorporating such information in future work. Relationships between the unlabeled items #TARGET_REF consider sequential relations between different types of emails ( e.g. , between requests and satisfactions thereof ) to classify messages , and thus also explicitly exploit the structure of conversations .",
        "output": "related work:We currently do not have an efficient means to encode disagreement information as hard constraints; we plan to investigate incorporating such information in future work. Relationships between the unlabeled items #TARGET_REF<BACKGROUND/> consider sequential relations between different types of emails ( e.g. , between requests and satisfactions thereof ) to classify messages , and thus also explicitly exploit the structure of conversations ."
    },
    {
        "gold": {
            "text": [
                "Evaluative and persuasive documents, such as a politician's speech regarding a bill or a blogger's commentary on a legislative proposal, form a particularly interesting type of politically oriented text.",
                "People are much more likely to consult such evaluative statements than the actual text of a bill or law under discussion , given the dense nature of legislative language and the fact that ( U.S. ) bills often reach several hundred pages in length ( #TARGET_REF ) .",
                "Moreover, political opinions are exsional bills and related data was launched in #REF, when Mosaic was not quite two years old and Altavista did not yet exist."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Evaluative and persuasive documents, such as a politician's speech regarding a bill or a blogger's commentary on a legislative proposal, form a particularly interesting type of politically oriented text. People are much more likely to consult such evaluative statements than the actual text of a bill or law under discussion , given the dense nature of legislative language and the fact that ( U.S. ) bills often reach several hundred pages in length ( #TARGET_REF ) . Moreover, political opinions are exsional bills and related data was launched in #REF, when Mosaic was not quite two years old and Altavista did not yet exist.",
        "output": "introduction:Evaluative and persuasive documents, such as a politician's speech regarding a bill or a blogger's commentary on a legislative proposal, form a particularly interesting type of politically oriented text. People are much more likely to consult such evaluative statements than the actual text of a bill or law under discussion , given the dense nature of legislative language and the fact that ( U.S. ) bills often reach several hundred pages in length ( #TARGET_REF<BACKGROUND/> ) . Moreover, political opinions are exsional bills and related data was launched in #REF, when Mosaic was not quite two years old and Altavista did not yet exist."
    },
    {
        "gold": {
            "text": [
                "As has been previously observed and exploited in the NLP literature ( #REF ; #REF ; #TARGET_REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs .",
                "In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "method:As has been previously observed and exploited in the NLP literature ( #REF ; #REF ; #TARGET_REF ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision.",
        "output": "method:As has been previously observed and exploited in the NLP literature ( #REF ; #REF ; #TARGET_REF<USE/> ) , the above optimization function , unlike many others that have been proposed for graph or set partitioning , can be solved exactly in an provably efficient manner via methods for finding minimum cuts in graphs . In our view, the contribution of our work is the examination of new types of relationships, not the method by which such relationships are incorporated into the classification decision."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography).",
                "In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #TARGET_REF ; #REF ; #REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #TARGET_REF ; #REF ; #REF ) .",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) ."
    },
    {
        "gold": {
            "text": [
                "Notable early papers on graph-based semisupervised learning include #REF , #TARGET_REF , #REF , and #REF .",
                "#REF maintains a survey of this area."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Notable early papers on graph-based semisupervised learning include #REF , #TARGET_REF , #REF , and #REF . #REF maintains a survey of this area.",
        "output": "related work:Notable early papers on graph-based semisupervised learning include #REF , #TARGET_REF<BACKGROUND/> , #REF , and #REF . #REF maintains a survey of this area."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography).",
                "In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #REF ; #TARGET_REF ) .",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis, an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language (early work includes #REF, #REF, #REF, and #REF; see #REF for an active bibliography). In particular , since we treat each individual speech within a debate as a single `` document '' , we are considering a version of document-level sentiment-polarity classification , namely , automatically distinguishing between positive and negative documents ( #REF ; #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #TARGET_REF ; #REF ) .",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF).",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #TARGET_REF ; #REF ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #REF ; #TARGET_REF<BACKGROUND/> ; #REF ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #TARGET_REF , #REF , #REF , and #REF ; see #REF for an active bibliography ) .",
                "In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #TARGET_REF , #REF , #REF , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF).",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #TARGET_REF<BACKGROUND/> , #REF , #REF , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
    },
    {
        "gold": {
            "text": [
                "Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) .",
                "It would be interesting to investigate the application of such methods to our problem.",
                "However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #TARGET_REF ; #REF ; #REF ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve.",
        "output": "related work:Recently , several alternative , often quite sophisticated approaches to collective classification have been proposed ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ; #REF ; #REF ; #REF ; #REF ) . It would be interesting to investigate the application of such methods to our problem. However, we also believe that our approach has important advantages, including conceptual simplicity and the fact that it is based on an underlying optimization problem that is provably and in practice easy to solve."
    },
    {
        "gold": {
            "text": [
                "Notable early papers on graph-based semisupervised learning include #REF , #REF , #TARGET_REF , and #REF .",
                "#REF maintains a survey of this area."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Notable early papers on graph-based semisupervised learning include #REF , #REF , #TARGET_REF , and #REF . #REF maintains a survey of this area.",
        "output": "related work:Notable early papers on graph-based semisupervised learning include #REF , #REF , #TARGET_REF<BACKGROUND/> , and #REF . #REF maintains a survey of this area."
    },
    {
        "gold": {
            "text": [
                "We used a simple method to learn to identify cross-speaker references indicating agreement.",
                "More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF).",
                "Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #REF ; #TARGET_REF ) .",
        "output": "related work:We used a simple method to learn to identify cross-speaker references indicating agreement. More sophisticated approaches have been proposed (#REF), including an extension that, in an interesting reversal of our problem, makes use of sentimentpolarity indicators within speech segments (#REF). Also relevant is work on the general problems of dialog-act tagging ( #REF ) , citation analysis ( #REF ) , and computational rhetorical analysis ( #REF ; #TARGET_REF<BACKGROUND/> ) ."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF).",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF).",
                "An exception is #TARGET_REF , who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site ."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #TARGET_REF , who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site .",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking, allowing the automatic analysis of the opinions that people submit (#REF;#REF;#REF). There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #TARGET_REF<BACKGROUND/> , who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site ."
    },
    {
        "gold": {
            "text": [
                "SVMlight is available at svmlight.joachims.org.",
                "Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "method:SVMlight is available at svmlight.joachims.org. Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #REF ; #TARGET_REF ) .",
        "output": "method:SVMlight is available at svmlight.joachims.org. Default parameters were used , although experimentation with different parameter settings is an important direction for future work ( #REF ; #TARGET_REF<MOTIVATION/> ) ."
    },
    {
        "gold": {
            "text": [
                "Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #TARGET_REF ; #REF ; #REF ) .",
                "There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF).",
                "An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #TARGET_REF ; #REF ; #REF ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site.",
        "output": "related work:Politically-oriented text Sentiment analysis has specifically been proposed as a key enabling technology in eRulemaking , allowing the automatic analysis of the opinions that people submit ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . There has also been work focused upon determining the political leaning (e.g., \"liberal\" vs. \"conservative\") of a document or author, where most previously-proposed methods make no direct use of relationships between the documents to be classified (the \"unlabeled\" texts) (#REF;#REF;#REF). An exception is #REF, who experimented with determining the political orientation of websites essentially by classifying the concatenation of all the documents found on that site."
    },
    {
        "gold": {
            "text": [
                "Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently.",
                "A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF).",
                "Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions.",
                "For example, we may find textual4 evidence of a high likelihood of agreement between two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings ( see #TARGET_REF but cfXXX #REF ) .",
                "Agreement evidence can be a powerful aid in our classification task: for example, we can easily categorize a complicated (or overly terse) document if we find within it indications of agreement with a clearly positive text."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF). Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual4 evidence of a high likelihood of agreement between two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings ( see #TARGET_REF but cfXXX #REF ) . Agreement evidence can be a powerful aid in our classification task: for example, we can easily categorize a complicated (or overly terse) document if we find within it indications of agreement with a clearly positive text.",
        "output": "introduction:Most sentiment-polarity classifiers proposed in the recent literature categorize each document independently. A few others incorporate various measures of inter-document similarity between the texts to be labeled (#REF; #REF; #REF). Many interesting opinion-oriented documents, however, can be linked through certain relationships that occur in the context of evaluative discussions. For example, we may find textual4 evidence of a high likelihood of agreement between two speakers, such as explicit assertions (�I second that!�) or quotation of messages in emails or postings ( see #TARGET_REF<BACKGROUND/> but cfXXX #REF ) . Agreement evidence can be a powerful aid in our classification task: for example, we can easily categorize a complicated (or overly terse) document if we find within it indications of agreement with a clearly positive text."
    },
    {
        "gold": {
            "text": [
                "Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #REF ; #TARGET_REF ) or explicit inter-document references in the form of hyperlinks (#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #REF ; #TARGET_REF ) or explicit inter-document references in the form of hyperlinks (#REF).",
        "output": "related work:Previous sentiment-analysis work in different domains has considered inter-document similarity ( #REF ; #REF ; #TARGET_REF<BACKGROUND/> ) or explicit inter-document references in the form of hyperlinks (#REF)."
    },
    {
        "gold": {
            "text": [
                "Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #TARGET_REF , #REF , and #REF ; see #REF for an active bibliography ) .",
                "In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #TARGET_REF , #REF , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF).",
        "output": "introduction:Task properties Determining whether or not a speaker supports a proposal falls within the realm of sentiment analysis , an extremely active research area devoted to the computational treatment of subjective or opinion-oriented language ( early work includes #REF , #TARGET_REF<BACKGROUND/> , #REF , and #REF ; see #REF for an active bibliography ) . In particular, since we treat each individual speech within a debate as a single \"document\", we are considering a version of document-level sentiment-polarity classification, namely, automatically distinguishing between positive and negative documents (#REF;#REF;#REF;#REF)."
    },
    {
        "gold": {
            "text": [
                "We have thus far implemented two objective functions which operate on individual sentences without regard for choices made on other sentences.",
                "When the final evaluation metric incorporates global statistics, however, an objective function which takes them into account is desirable.",
                "For example, when using BLEU, it makes a big difference whether individual sentences are both longer and shorter than the reference or systematically shorter than the reference, but these two cases can not be distinguished by single-sentence objective functions.",
                "Our plan is to implement a windowed or moving-average version of BLEU as in ( #TARGET_REF ) ."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:We have thus far implemented two objective functions which operate on individual sentences without regard for choices made on other sentences. When the final evaluation metric incorporates global statistics, however, an objective function which takes them into account is desirable. For example, when using BLEU, it makes a big difference whether individual sentences are both longer and shorter than the reference or systematically shorter than the reference, but these two cases can not be distinguished by single-sentence objective functions. Our plan is to implement a windowed or moving-average version of BLEU as in ( #TARGET_REF ) .",
        "output": "conclusion:We have thus far implemented two objective functions which operate on individual sentences without regard for choices made on other sentences. When the final evaluation metric incorporates global statistics, however, an objective function which takes them into account is desirable. For example, when using BLEU, it makes a big difference whether individual sentences are both longer and shorter than the reference or systematically shorter than the reference, but these two cases can not be distinguished by single-sentence objective functions. Our plan is to implement a windowed or moving-average version of BLEU as in ( #TARGET_REF<MOTIVATION/> ) ."
    },
    {
        "gold": {
            "text": [
                "The flexible architecture we have presented enables interesting future research : ( i ) a straightforward improvement is the use of lexical similarity to reduce data sparseness , e.g. ( #TARGET_REF ; #REF ; #REF ) .",
                "(#REF;#REF).",
                "However, the similarity between subjective words, which have multiple senses against other words may negatively impact the system accuracy.",
                "Therefore, the use of the syntactic/semantic kernels, i.e. (#REFa;#REFb), to syntactically contextualize word similarities may improve the reranker accuracy.",
                "(ii) The latter can be further boosted by studying complex structural kernels, e.g.",
                "(#REF;#REF;#REF).",
                "(iii) More specific predicate argument structures such those proposed in FrameNet, e.g.",
                "(#REF;#REF;#REF;#REFb) may be useful to characterize the opinion holder and the sentence semantic context.",
                "Finally, while the strategy based on reranking resulted in a significant performance boost, it remains to be seen whether a higher accuracy can be achieved by developing a more sophisticated inference algorithm based on dynamic programming."
            ],
            "label": [
                "BACKGROUND"
            ]
        },
        "input": "conclusion:The flexible architecture we have presented enables interesting future research : ( i ) a straightforward improvement is the use of lexical similarity to reduce data sparseness , e.g. ( #TARGET_REF ; #REF ; #REF ) . (#REF;#REF). However, the similarity between subjective words, which have multiple senses against other words may negatively impact the system accuracy. Therefore, the use of the syntactic/semantic kernels, i.e. (#REFa;#REFb), to syntactically contextualize word similarities may improve the reranker accuracy. (ii) The latter can be further boosted by studying complex structural kernels, e.g. (#REF;#REF;#REF). (iii) More specific predicate argument structures such those proposed in FrameNet, e.g. (#REF;#REF;#REF;#REFb) may be useful to characterize the opinion holder and the sentence semantic context. Finally, while the strategy based on reranking resulted in a significant performance boost, it remains to be seen whether a higher accuracy can be achieved by developing a more sophisticated inference algorithm based on dynamic programming.",
        "output": "conclusion:The flexible architecture we have presented enables interesting future research : ( i ) a straightforward improvement is the use of lexical similarity to reduce data sparseness , e.g. ( #TARGET_REF<BACKGROUND/> ; #REF ; #REF ) . (#REF;#REF). However, the similarity between subjective words, which have multiple senses against other words may negatively impact the system accuracy. Therefore, the use of the syntactic/semantic kernels, i.e. (#REFa;#REFb), to syntactically contextualize word similarities may improve the reranker accuracy. (ii) The latter can be further boosted by studying complex structural kernels, e.g. (#REF;#REF;#REF). (iii) More specific predicate argument structures such those proposed in FrameNet, e.g. (#REF;#REF;#REF;#REFb) may be useful to characterize the opinion holder and the sentence semantic context. Finally, while the strategy based on reranking resulted in a significant performance boost, it remains to be seen whether a higher accuracy can be achieved by developing a more sophisticated inference algorithm based on dynamic programming."
    },
    {
        "gold": {
            "text": [
                "The right column in Table 1 shows the scores if (using the product-of-ranks algorithm) four source languages are taken into account in parallel.",
                "As can be seen, with an average score of 51.8 the improvement over the English only variant (50.6) is minimal.",
                "This contrasts with the findings described in #TARGET_REF where significant improvements could be achieved by increasing the number of source languages .",
                "So this casts some doubt on these.",
                "However, as English was not considered as a source language there, the performance levels were mostly between 10 and 20, leaving much room for improvement.",
                "This is not the case here, where we try to improve on a score of around 50 for English.",
                "Remember that this is a somewhat conservative score as we count correct but alternative translations, as errors.",
                "As this is already a performance much closer to the optimum, making further performance gains is more difficult.",
                "Therefore, perhaps we should take it as a success that the product-of-ranks algorithm could achieve a minimal performance gain despite the fact that the influence of the non-English languages was probably mostly detrimental."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "experiments:The right column in Table 1 shows the scores if (using the product-of-ranks algorithm) four source languages are taken into account in parallel. As can be seen, with an average score of 51.8 the improvement over the English only variant (50.6) is minimal. This contrasts with the findings described in #TARGET_REF where significant improvements could be achieved by increasing the number of source languages . So this casts some doubt on these. However, as English was not considered as a source language there, the performance levels were mostly between 10 and 20, leaving much room for improvement. This is not the case here, where we try to improve on a score of around 50 for English. Remember that this is a somewhat conservative score as we count correct but alternative translations, as errors. As this is already a performance much closer to the optimum, making further performance gains is more difficult. Therefore, perhaps we should take it as a success that the product-of-ranks algorithm could achieve a minimal performance gain despite the fact that the influence of the non-English languages was probably mostly detrimental.",
        "output": "experiments:The right column in Table 1 shows the scores if (using the product-of-ranks algorithm) four source languages are taken into account in parallel. As can be seen, with an average score of 51.8 the improvement over the English only variant (50.6) is minimal. This contrasts with the findings described in #TARGET_REF<USE/> where significant improvements could be achieved by increasing the number of source languages . So this casts some doubt on these. However, as English was not considered as a source language there, the performance levels were mostly between 10 and 20, leaving much room for improvement. This is not the case here, where we try to improve on a score of around 50 for English. Remember that this is a somewhat conservative score as we count correct but alternative translations, as errors. As this is already a performance much closer to the optimum, making further performance gains is more difficult. Therefore, perhaps we should take it as a success that the product-of-ranks algorithm could achieve a minimal performance gain despite the fact that the influence of the non-English languages was probably mostly detrimental."
    },
    {
        "gold": {
            "text": [
                "So far, we always computed translations to single source words.",
                "However, if we assume, for example, that we already have word equations for four languages, and all we want is to compute the translations into a fifth language, then we can simply extend our approach to what we call the product-of-ranks algorithm.",
                "As suggested in #TARGET_REF this can be done by looking up the ranks of each of the four given words ( i.e. the words occurring in a particular word equation ) within the association vector of a translation candidate , and by multiplying these ranks .",
                "So for each candidate we obtain a product of ranks.",
                "We then assume that the candidate with the smallest product will be the best translation. 3",
                "et us illustrate this by an example: If the given words are the variants of the word nervous in English, French, German, and Spanish, i.e. nervous, nerveux, nervös, and nervioso, and if we want to find out their translation into Italian, we would look at the association vectors of each word in our Italian target vocabulary.",
                "The association strengths in these vectors need to be inversely sorted, and in each of them we will look up the positions of our four given words.",
                "Then for each vector we compute the product of the four ranks, and finally sort the Italian vocabulary according to these products."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "introduction:So far, we always computed translations to single source words. However, if we assume, for example, that we already have word equations for four languages, and all we want is to compute the translations into a fifth language, then we can simply extend our approach to what we call the product-of-ranks algorithm. As suggested in #TARGET_REF this can be done by looking up the ranks of each of the four given words ( i.e. the words occurring in a particular word equation ) within the association vector of a translation candidate , and by multiplying these ranks . So for each candidate we obtain a product of ranks. We then assume that the candidate with the smallest product will be the best translation. 3 et us illustrate this by an example: If the given words are the variants of the word nervous in English, French, German, and Spanish, i.e. nervous, nerveux, nervös, and nervioso, and if we want to find out their translation into Italian, we would look at the association vectors of each word in our Italian target vocabulary. The association strengths in these vectors need to be inversely sorted, and in each of them we will look up the positions of our four given words. Then for each vector we compute the product of the four ranks, and finally sort the Italian vocabulary according to these products.",
        "output": "introduction:So far, we always computed translations to single source words. However, if we assume, for example, that we already have word equations for four languages, and all we want is to compute the translations into a fifth language, then we can simply extend our approach to what we call the product-of-ranks algorithm. As suggested in #TARGET_REF<EXTENSION/> this can be done by looking up the ranks of each of the four given words ( i.e. the words occurring in a particular word equation ) within the association vector of a translation candidate , and by multiplying these ranks . So for each candidate we obtain a product of ranks. We then assume that the candidate with the smallest product will be the best translation. 3 et us illustrate this by an example: If the given words are the variants of the word nervous in English, French, German, and Spanish, i.e. nervous, nerveux, nervös, and nervioso, and if we want to find out their translation into Italian, we would look at the association vectors of each word in our Italian target vocabulary. The association strengths in these vectors need to be inversely sorted, and in each of them we will look up the positions of our four given words. Then for each vector we compute the product of the four ranks, and finally sort the Italian vocabulary according to these products."
    },
    {
        "gold": {
            "text": [
                "Whereas #TARGET_REF dealt only with an English corpus , the current work shows that this methodology is applicable to a wide range of languages and corpora .",
                "We were able to shed some light on criteria influencing performance, such as the selection of text type and the direction of a language pair.",
                "For example, it is more promising to look at occurrences of English words in a German corpus rather than the other way around.",
                "Because of the special status of English it is also advisable to use it as a pivot wherever possible."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "conclusion:Whereas #TARGET_REF dealt only with an English corpus , the current work shows that this methodology is applicable to a wide range of languages and corpora . We were able to shed some light on criteria influencing performance, such as the selection of text type and the direction of a language pair. For example, it is more promising to look at occurrences of English words in a German corpus rather than the other way around. Because of the special status of English it is also advisable to use it as a pivot wherever possible.",
        "output": "conclusion:Whereas #TARGET_REF<USE/> dealt only with an English corpus , the current work shows that this methodology is applicable to a wide range of languages and corpora . We were able to shed some light on criteria influencing performance, such as the selection of text type and the direction of a language pair. For example, it is more promising to look at occurrences of English words in a German corpus rather than the other way around. Because of the special status of English it is also advisable to use it as a pivot wherever possible."
    },
    {
        "gold": {
            "text": [
                "The current work has focussed on high-level mapping rules which can be used both for generation from databases and knowledge representations and also for generation from text.",
                "In future work, we will focus on mapping text (in monologue form) to dialogue.",
                "For this we need to combine the highlevel rules with rules for paraphrasing the text in the monologue with text for the dialogue acts that express the same information in dialogue form.",
                "For automatically extracting these surface level mappings we will draw on the approach to learning paraphrases from a corpus that is described in #TARGET_REF .",
                "An important component of our future effort will be to evaluate whether automatically generating dialogues from naturally-occurring monologues, following the approach described here, results in dialogues that are fluent and coherent and preserve the information from the input monologue."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:The current work has focussed on high-level mapping rules which can be used both for generation from databases and knowledge representations and also for generation from text. In future work, we will focus on mapping text (in monologue form) to dialogue. For this we need to combine the highlevel rules with rules for paraphrasing the text in the monologue with text for the dialogue acts that express the same information in dialogue form. For automatically extracting these surface level mappings we will draw on the approach to learning paraphrases from a corpus that is described in #TARGET_REF . An important component of our future effort will be to evaluate whether automatically generating dialogues from naturally-occurring monologues, following the approach described here, results in dialogues that are fluent and coherent and preserve the information from the input monologue.",
        "output": "conclusion:The current work has focussed on high-level mapping rules which can be used both for generation from databases and knowledge representations and also for generation from text. In future work, we will focus on mapping text (in monologue form) to dialogue. For this we need to combine the highlevel rules with rules for paraphrasing the text in the monologue with text for the dialogue acts that express the same information in dialogue form. For automatically extracting these surface level mappings we will draw on the approach to learning paraphrases from a corpus that is described in #TARGET_REF<MOTIVATION/> . An important component of our future effort will be to evaluate whether automatically generating dialogues from naturally-occurring monologues, following the approach described here, results in dialogues that are fluent and coherent and preserve the information from the input monologue."
    },
    {
        "gold": {
            "text": [
                "By contrast, for Super GREC there are several distinct classes for which we expected lexical resources to have fair coverage for SimString and Gazetteer features.",
                "While an advantage over Internal was observed for Super GREC, SimString features showed no benefit over Gazetteer features.",
                "The methods exhibited the expected result on only one of the six corpora, CALBC CII, where there is a clear advantage for Gazetteer over Internal and a further clear advantage for SimString over Gazetteer.",
                "Disappointingly, we did not succeed in establishing a clear improvement for more than one of the six corpora.",
                "Although we have not been successful in Figure 6: Learning curve for Super GREC Figure 7: Learning curve for EPI proving our initial hypothesis we argue that our results calls for further study due to several concerns raised by the results remaining unanswered.",
                "It may be that our notion of distance to lexical resource entries is too naive.",
                "A possible future direction would be to compare the query string to retrieved results using a method similar to that of #TARGET_REF .",
                "This would enable us to retain the advantage of fast approximate string matching, thus being able to utilise larger lexical resources than if we were to calculate sophisticated alignments for each lexical entry."
            ],
            "label": [
                "MOTIVATION"
            ]
        },
        "input": "conclusion:By contrast, for Super GREC there are several distinct classes for which we expected lexical resources to have fair coverage for SimString and Gazetteer features. While an advantage over Internal was observed for Super GREC, SimString features showed no benefit over Gazetteer features. The methods exhibited the expected result on only one of the six corpora, CALBC CII, where there is a clear advantage for Gazetteer over Internal and a further clear advantage for SimString over Gazetteer. Disappointingly, we did not succeed in establishing a clear improvement for more than one of the six corpora. Although we have not been successful in Figure 6: Learning curve for Super GREC Figure 7: Learning curve for EPI proving our initial hypothesis we argue that our results calls for further study due to several concerns raised by the results remaining unanswered. It may be that our notion of distance to lexical resource entries is too naive. A possible future direction would be to compare the query string to retrieved results using a method similar to that of #TARGET_REF . This would enable us to retain the advantage of fast approximate string matching, thus being able to utilise larger lexical resources than if we were to calculate sophisticated alignments for each lexical entry.",
        "output": "conclusion:By contrast, for Super GREC there are several distinct classes for which we expected lexical resources to have fair coverage for SimString and Gazetteer features. While an advantage over Internal was observed for Super GREC, SimString features showed no benefit over Gazetteer features. The methods exhibited the expected result on only one of the six corpora, CALBC CII, where there is a clear advantage for Gazetteer over Internal and a further clear advantage for SimString over Gazetteer. Disappointingly, we did not succeed in establishing a clear improvement for more than one of the six corpora. Although we have not been successful in Figure 6: Learning curve for Super GREC Figure 7: Learning curve for EPI proving our initial hypothesis we argue that our results calls for further study due to several concerns raised by the results remaining unanswered. It may be that our notion of distance to lexical resource entries is too naive. A possible future direction would be to compare the query string to retrieved results using a method similar to that of #TARGET_REF<MOTIVATION/> . This would enable us to retain the advantage of fast approximate string matching, thus being able to utilise larger lexical resources than if we were to calculate sophisticated alignments for each lexical entry."
    },
    {
        "gold": {
            "text": [
                "The article classifier is a discriminative model that draws on the state-of-the-art approach described in #TARGET_REF .",
                "The model makes use of the Averaged Perceptron (AP) algorithm (#REF) and is trained on the training data of the shared task with rich features.",
                "The article module uses the POS and chunker output to generate some of its features and candidates (likely contexts for missing articles)."
            ],
            "label": [
                "FUTURE"
            ]
        },
        "input": "experiments:The article classifier is a discriminative model that draws on the state-of-the-art approach described in #TARGET_REF . The model makes use of the Averaged Perceptron (AP) algorithm (#REF) and is trained on the training data of the shared task with rich features. The article module uses the POS and chunker output to generate some of its features and candidates (likely contexts for missing articles).",
        "output": "experiments:The article classifier is a discriminative model that draws on the state-of-the-art approach described in #TARGET_REF<FUTURE/> . The model makes use of the Averaged Perceptron (AP) algorithm (#REF) and is trained on the training data of the shared task with rich features. The article module uses the POS and chunker output to generate some of its features and candidates (likely contexts for missing articles)."
    },
    {
        "gold": {
            "text": [
                "The choice of learning algorithm for each classifier is motivated by earlier findings showing that discriminative classifiers outperform other machine-learning methods on error correction tasks ( #TARGET_REF ) .",
                "Thus, the classifiers trained on the learner data make use of a discriminative model.",
                "Because the Google corpus does not contain complete sentences but only n-gram counts of length up to five, training a discriminative model is not desirable, and we thus use NB (details in #REF)."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "experiments:The choice of learning algorithm for each classifier is motivated by earlier findings showing that discriminative classifiers outperform other machine-learning methods on error correction tasks ( #TARGET_REF ) . Thus, the classifiers trained on the learner data make use of a discriminative model. Because the Google corpus does not contain complete sentences but only n-gram counts of length up to five, training a discriminative model is not desirable, and we thus use NB (details in #REF).",
        "output": "experiments:The choice of learning algorithm for each classifier is motivated by earlier findings showing that discriminative classifiers outperform other machine-learning methods on error correction tasks ( #TARGET_REF<EXTENSION/> ) . Thus, the classifiers trained on the learner data make use of a discriminative model. Because the Google corpus does not contain complete sentences but only n-gram counts of length up to five, training a discriminative model is not desirable, and we thus use NB (details in #REF)."
    },
    {
        "gold": {
            "text": [
                "Another line of research that is correlated with ours is recognition of agreement/disagreement ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) and classification of stances ( #REF ; #REF ) in online forums .",
                "For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:Another line of research that is correlated with ours is recognition of agreement/disagreement ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF ; #REF ) and classification of stances ( #REF ; #REF ) in online forums . For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy.",
        "output": "related work:Another line of research that is correlated with ours is recognition of agreement/disagreement ( #REF ; #REF ; #REF ; #REF ; #TARGET_REF<USE/> ; #REF ) and classification of stances ( #REF ; #REF ) in online forums . For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy."
    },
    {
        "gold": {
            "text": [
                "As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2).",
                "We notice that the recall improves significantly when compared with the rule-based method.",
                "To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively.",
                "Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words.",
                "The feature vector includes only words present in the MI list.",
                "Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6).",
                "The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification.",
                "In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #REF ; #TARGET_REF ) ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2). We notice that the recall improves significantly when compared with the rule-based method. To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively. Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words. The feature vector includes only words present in the MI list. Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6). The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification. In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #REF ; #TARGET_REF ) .",
        "output": "nan:As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2). We notice that the recall improves significantly when compared with the rule-based method. To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively. Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words. The feature vector includes only words present in the MI list. Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6). The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification. In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #REF ; #TARGET_REF<EXTENSION/> ) ."
    },
    {
        "gold": {
            "text": [
                "Another line of research that is correlated with ours is recognition of agreement/disagreement ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) and classification of stances ( #REF ; #REF ) in online forums .",
                "For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy."
            ],
            "label": [
                "USE"
            ]
        },
        "input": "related work:Another line of research that is correlated with ours is recognition of agreement/disagreement ( #TARGET_REF ; #REF ; #REF ; #REF ; #REF ; #REF ) and classification of stances ( #REF ; #REF ) in online forums . For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy.",
        "output": "related work:Another line of research that is correlated with ours is recognition of agreement/disagreement ( #TARGET_REF<USE/> ; #REF ; #REF ; #REF ; #REF ; #REF ) and classification of stances ( #REF ; #REF ) in online forums . For future work, we can utilize textual features (contextual, dependency, discourse markers), relevant multiword expressions and topic modeling (#REF), and thread structure (#REF;#REF) to improve the Agree/Disagree classification accuracy."
    },
    {
        "gold": {
            "text": [
                "As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2).",
                "We notice that the recall improves significantly when compared with the rule-based method.",
                "To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively.",
                "Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words.",
                "The feature vector includes only words present in the MI list.",
                "Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6).",
                "The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification.",
                "In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #TARGET_REF ; #REF ) ."
            ],
            "label": [
                "EXTENSION"
            ]
        },
        "input": "nan:As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2). We notice that the recall improves significantly when compared with the rule-based method. To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively. Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words. The feature vector includes only words present in the MI list. Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6). The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification. In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #TARGET_REF ; #REF ) .",
        "output": "nan:As a SVM baseline, we first use all unigrams in Callout and Target as features (Table 6, Row 2). We notice that the recall improves significantly when compared with the rule-based method. To further improve the classification accuracy, we use Mutual Information (MI) to select the words in the Callouts and Targets that are likely to be associated with the categories Agree and Disagree, respectively. Specifically, we sort each word based on its MI value and then select the first 180 words in each of the two categories to represent our new vocabulary set of 360 words. The feature vector includes only words present in the MI list. Compared to the all unigrams baseline, the MI-based unigrams improve the F1 by 4% (Agree) and 2% (Disagree) (Table 6). The MI approach discovers the words that are highly associated with Agree/Disagree categories and these words turn to be useful features for classification. In addition , we consider several types of lexical features ( LexF ) inspired by previous work on agreement and disagreement ( #TARGET_REF<EXTENSION/> ; #REF ) ."
    }
]